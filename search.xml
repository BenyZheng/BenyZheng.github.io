<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[集合类之List]]></title>
    <url>%2F2019%2F05%2F26%2Fjava%E9%9B%86%E5%90%88%E7%B1%BB%2F%E9%9B%86%E5%90%88%E7%B1%BB%E4%B9%8BList%2F%E9%9B%86%E5%90%88%E7%B1%BB%E4%B9%8BList%2F</url>
    <content type="text"><![CDATA[集合类之ListList接口扩展自Collection，定义一个允许重复的有序集合，从List接口中的方法来看，List接口主要是增加了面向位置的操作，允许在指定位置上操作元素，同时增加了一个能够双向遍历线性表的新列表迭代器ListIterator。List接口的两个重要的具体实现类，也是我们可能最常用的类，ArrayList和LinkedList。 1.ArrayList它是用数组存储元素的，这个数组可以动态创建，如果元素个数超过了数组的容量，那么就创建一个更大的新数组（通过移位运算符&gt;&gt;1扩大1倍再加上自己原本的容量即扩充1.5倍），并将当前数组中的所有元素都复制到新数组中。假设第一次是集合没有任何元素，下面以插入一个元素为例看看源码的实现。 123456789101112131415161718192021222324252627282930313233343536371、找到add()实现方法。 public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; 2、此方法主要是确定将要创建的数组大小。 private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);//取出两个较大的容量 &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++;//记录了结构性改变的次数。结构性改变指的是那些修改了列表大小的操作，在迭代过程中可能会造成错误的结果。 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; 3、最后是创建数组，可以明显的看到先是确定了添加元素后的大小之后将元素复制到新数组中。 private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//1.5倍扩容 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; ArrayList遍历三种方法 1、通过迭代器Iterator() 12345Iterator iter = list.iterator();while (iter.hasNext())&#123; System.out.println(iter.next());&#125; 2、随机访问，通过索引值去遍历。 12345int size = list.size();for (int i=0; i&lt;size; i++) &#123; System.out.println(list.get(i)); &#125; 3、for循环遍历 1234for(String str:list)&#123;System.out.println(str); &#125; ArrayList常见问题 1、ArrayList如何实现自动增加 当试图在arraylist中增加一个对象的时候，Java会去检查arraylist，以确保已存在的数组中有足够的容量来存储这个新的对象。如果没有足够容量的话，那么就会新建一个长度更长的数组，旧的数组就会使用Arrays.copyOf方法被复制到新的数组中去，现有的数组引用指向了新的数组。 2、当传递ArrayList到某个方法中，或者某个方法返回ArrayList，什么时候要考虑安全隐患？如何修复安全违规这个问题呢？ 当array被当做参数传递到某个方法中，如果array在没有被复制的情况下直接被分配给了成员变量，那么就可能发生这种情况，即当原始的数组被调用的方法改变的时候，传递到这个方法中的数组也会改变。 3、什么情况下你会使用ArrayList？什么时候你会选择LinkedList？ 多数情况下，当你遇到访问元素比插入或者是删除元素更加频繁的时候，你应该使用ArrayList。另外一方面，当你在某个特别的索引中，插入或者是删除元素更加频繁，或者你根本就不需要访问元素的时候，你会选择LinkedList。这里的主要原因是，在ArrayList中访问元素的最糟糕的时间复杂度是”1″，而在LinkedList中可能就是”n”了。在ArrayList中增加或者删除某个元素，通常会调用System.arraycopy方法，这是一种极为消耗资源的操作，因此，在频繁的插入或者是删除元素的情况下，LinkedList的性能会更加好一点。 System.arraycopy方法消耗资源原因： 123456789101112131415public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)代码解释: Object src : 原数组 int srcPos : 从元数据的起始位置开始 Object dest : 目标数组 int destPos : 目标数组的开始起始位置 int length : 要copy的数组的长度我们使用System.arraycopy进行转换(copy)System.arrayCopy(srcBytes,0,destBytes ,0,5)上面这段代码就是 : 创建一个一维空数组,数组的总长度为 12位,然后将srcBytes源数组中 从0位 到 第5位之间的数值 copy 到 destBytes目标数组中,在目标数组的第0位开始放置.那么这行代码的运行效果应该是 2,4,0,0,0,增加或者删除都要进行一次copy，消耗资源多。 4、如何复制某个ArrayList到另一个ArrayList中去？写出你的代码？ 下面就是把某个ArrayList复制到另一个ArrayList中去的几种技术： 使用clone()方法，比如ArrayList newArray = oldArray.clone(); 使用ArrayList构造方法，比如：ArrayList myObject = new ArrayList(myTempObject); 使用Collection的copy方法。 注意1和2是浅拷贝(shallow copy)。 浅拷贝和深拷贝区别： | 浅拷贝：只复制引用，另一处修改，你当下的对象也会修改。 | 深拷贝：引用对象的值等信息，复制一份一样的。 浅拷贝—能复制变量，如果对象内还有对象，则只能复制对象的地址（指针指向同一个内存空间） 深拷贝—能复制变量，也能复制当前对象的内部对象 利用序列化实现深拷贝 把对象写到流里的过程是序列化过程（Serialization），而把对象从流中读出来的过程则叫做反序列化过程（Deserialization）。 在Java语言里深复制一个对象，常常可以先使对象实现Serializable接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。 2.LinkedList 1、继承了AbstractSequentialList抽象类：在遍历LinkedList的时候，官方更推荐使用顺序访问，也就是使用我们的迭代器。（因为LinkedList底层是通过一个双向链表来实现的）（虽然LinkedList也提供了get（int index）方法，但是底层的实现是：每次调用get（int index）方法的时候，都需要从链表的头部或者尾部进行遍历，每一的遍历时间复杂度是O(index)，而相对比ArrayList的底层实现，每次遍历的时间复杂度都是O(1)。所以不推荐通过get（int index）遍历LinkedList。 至于上面的说从链表的头部后尾部进行遍历：官方源码对遍历进行了优化：通过判断索引index更靠近链表的头部还是尾部来选择遍历的方向）（所以这里遍历LinkedList推荐使用迭代器）。 2、实现了List接口。（提供List接口中所有方法的实现）实现了Cloneable接口，它支持克隆（浅克隆），底层实现：LinkedList节点并没有被克隆，只是通过Object的clone（）方法得到的Object对象强制转化为了LinkedList,然后把它内部的实例域都置空，然后把被拷贝的LinkedList节点中的每一个值都拷贝到clone中。 3、实现了Deque接口。实现了Deque所有的可选的操作。 4、实现了Serializable接口。表明它支持序列化。（和ArrayList一样，底层都提供了两个方法：readObject（ObjectInputStream o）、writeObject（ObjectOutputStream o），用于实现序列化，底层只序列化节点的个数和节点的值） 底层重要方法分析： addAll(int index, Collection） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 首先调用一下空的构造器。//然后调用addAll(c)方法。 public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125;//通过调用addAll(int index, Collection&lt;? extends E&gt; c) 完成集合的添加。 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125;//几乎所有的涉及到在指定位置添加或者删除或修改操作都需要判断传进来的参数是否合法。// checkPositionIndex(index)方法就起这个作用。 public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; checkPositionIndex(index);//先把集合转化为数组，然后为该数组添加一个新的引用（Objext[] a）。 Object[] a = c.toArray();//新建一个变量存储数组的长度。 int numNew = a.length;//如果待添加的集合为空，直接返回，无需进行后面的步骤。后面都是用来把集合中的元素添加到//LinkedList中。 if (numNew == 0) return false;//Node&lt;E&gt; succ：指代待添加节点的位置。//Node&lt;E&gt; pred：指代待添加节点的前一个节点。//下面的代码是依据新添加的元素的位置分为两个分支：//①新添加的元素的位置位于LinkedList最后一个元素的后面。//新添加的元素的位置位于LinkedList中。//如果index==size;说明此时需要添加LinkedList中的集合中的每一个元素都是在LinkedList//最后面。所以把succ设置为空，pred指向尾节点。//否则的话succ指向插入待插入位置的节点。这里用到了node（int index）方法，这个方法//后面会详细分析，这里只需要知道该方法返回对应索引位置上的Node（节点）。pred指向succ节点的前一个节点。 Node&lt;E&gt; pred, succ; if (index == size) &#123; succ = null; pred = last; &#125; else &#123; succ = node(index); pred = succ.prev; &#125;//接着遍历数组中的每个元素。在每次遍历的时候，都新建一个节点，该节点的值存储数组a中遍历//的值，该节点的prev用来存储pred节点，next设置为空。接着判断一下该节点的前一个节点是否为//空，如果为空的话，则把当前节点设置为头节点。否则的话就把当前节点的前一个节点的next值//设置为当前节点。最后把pred指向当前节点，以便后续新节点的添加。 for (Object o : a) &#123; @SuppressWarnings("unchecked") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125;//这里仍然和上面一样，分两种情况对待：//①当succ==null（也就是新添加的节点位于LinkedList集合的最后一个元素的后面），//通过遍历上面的a的所有元素，此时pred指向的是LinkedList中的最后一个元素，所以把//last指向pred指向的节点。//当不为空的时候，表明在LinkedList集合中添加的元素，需要把pred的next指向succ上，//succ的prev指向pred。//最后把集合的大小设置为新的大小。//modCount（修改的次数）自增。 if (succ == null) &#123; last = pred; &#125; else &#123; pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true; &#125; 虽然是增加一个集合的元素，但是modCount只增加了一次 将LinkedList写入到流中。（也就是把LinkedList状态保存到流中）（序列化） 123456789101112private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out any hidden serialization magic s.defaultWriteObject(); // Write out size s.writeInt(size); // Write out all elements in the proper order. for (Node&lt;E&gt; x = first; x != null; x = x.next) s.writeObject(x.item);&#125; 从流中把LinkedList读取出来（读取流，拼装成LinkedList）（反序列化） 12345678910111213@SuppressWarnings("unchecked")private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden serialization magic s.defaultReadObject(); // Read in size int size = s.readInt(); // Read in all elements in the proper order. for (int i = 0; i &lt; size; i++) linkLast((E)s.readObject());&#125; LinkedList提供了两种迭代器，一种是返回Iterator，另一种返回ListIterator。 ①返回ListIterator迭代器： 1234public ListIterator&lt;E&gt; listIterator(int index) &#123; checkPositionIndex(index); return new ListItr(index);&#125; ②返回Iterator迭代器： 123public Iterator&lt;E&gt; descendingIterator() &#123; return new DescendingIterator();&#125;]]></content>
      <categories>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合类之SET]]></title>
    <url>%2F2019%2F05%2F26%2Fjava%E9%9B%86%E5%90%88%E7%B1%BB%2F%E9%9B%86%E5%90%88%E7%B1%BB%E4%B9%8BSET%2F%E9%9B%86%E5%90%88%E7%B1%BB%E4%B9%8BSET%2F</url>
    <content type="text"><![CDATA[集合类之SETset集合可以存储多个对象，但并不会记住元素的存储顺序，也不允许集合中有重复元素(不同的set集合有不同的判断方法)。 1.HashSetHashSet按照Hash算法存储集合中的元素，具有很好的存取和查找性能。当向HashSet中添加一些元素时，HashSet会根据该对象的HashCode()方法来得到该对象的HashCode值，然后根据这些HashCode的值来决定元素的位置。(HashSet的底层原理是HashMap) HashSet的特点：1.存储顺序和添加的顺序不同 2.HashSet不是同步的，如果多个线程同时访问一个HashSet，假设有两个或更多的线程修改了 集合中的值，则必须通过代码使线程同步。 3.HastSet允许集合中的元素为null。 ​ 4.非线程安全 在Hashset集合中，判断两个元素相同的标准是：两个对象通过equals()方法相等，且HashCode()方法的返回值也相等。如果有两个元素通过equals()方法比较相等，而HashCode()的返回值不同，HashSet会将这两个对象保存在不同的地方。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; static final long serialVersionUID = -5024744406713321676L; // 底层使用HashMap来保存HashSet中所有元素。 private transient HashMap&lt;E,Object&gt; map; // 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。 private static final Object PRESENT = new Object(); /** * 默认的无参构造器，构造一个空的HashSet。 * * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 */ public HashSet() &#123; map = new HashMap&lt;E,Object&gt;(); &#125; /** * 构造一个包含指定collection中的元素的新set。 * * 实际底层使用默认的加载因子0.75和足以包含指定 * collection中所有元素的初始容量来创建一个HashMap。 * @param c 其中的元素将存放在此set中的collection。 */ public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;E,Object&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); &#125; /** * 以指定的initialCapacity和loadFactor构造一个空的HashSet。 * * 实际底层以相应的参数构造一个空的HashMap。 * @param initialCapacity 初始容量。 * @param loadFactor 加载因子。 */ public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;E,Object&gt;(initialCapacity, loadFactor); &#125; /** * 以指定的initialCapacity构造一个空的HashSet。 * * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。 * @param initialCapacity 初始容量。 */ public HashSet(int initialCapacity) &#123; map = new HashMap&lt;E,Object&gt;(initialCapacity); &#125; /** * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 * * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 * @param initialCapacity 初始容量。 * @param loadFactor 加载因子。 * @param dummy 标记。 */ HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor); &#125; /** * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。 * * 底层实际调用底层HashMap的keySet来返回所有的key。 * 可见HashSet中的元素，只是存放在了底层HashMap的key上， * value使用一个static final的Object对象标识。 * @return 对此set中元素进行迭代的Iterator。 */ public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator(); &#125; /** * 返回此set中的元素的数量（set的容量）。 * * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。 * @return 此set中的元素的数量（set的容量）。 */ public int size() &#123; return map.size(); &#125; /** * 如果此set不包含任何元素，则返回true。 * * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。 * @return 如果此set不包含任何元素，则返回true。 */ public boolean isEmpty() &#123; return map.isEmpty(); &#125; /** * 如果此set包含指定元素，则返回true。 * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e)) * 的e元素时，返回true。 * * 底层实际调用HashMap的containsKey判断是否包含指定key。 * @param o 在此set中的存在已得到测试的元素。 * @return 如果此set包含指定元素，则返回true。 */ public boolean contains(Object o) &#123; return map.containsKey(o); &#125; /** * 如果此set中尚未包含指定元素，则添加指定元素。 * 更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2)) * 的元素e2，则向此set 添加指定的元素e。 * 如果此set已包含该元素，则该调用不更改set并返回false。 * * 底层实际将将该元素作为key放入HashMap。 * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）， * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 * @param e 将添加到此set中的元素。 * @return 如果此set尚未包含指定元素，则返回true。 */ public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125; /** * 如果指定元素存在于此set中，则将其移除。 * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e， * 则将其移除。如果此set已包含该元素，则返回true * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。 * * 底层实际调用HashMap的remove方法删除指定Entry。 * @param o 如果存在于此set中则需要将其移除的对象。 * @return 如果set包含指定元素，则返回true。 */ public boolean remove(Object o) &#123; return map.remove(o)==PRESENT; &#125; /** * 从此set中移除所有元素。此调用返回后，该set将为空。 * * 底层实际调用HashMap的clear方法清空Entry中所有元素。 */ public void clear() &#123; map.clear(); &#125; /** * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 * * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。 */ public Object clone() &#123; try &#123; HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone(); newSet.map = (HashMap&lt;E, Object&gt;) map.clone(); return newSet; &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; &#125; &#125; HashSet所有方法都直接在HashMap上运用，了解HashMap自然可以了解HashSet。 其中需要了解一下HashSet的加载因子和容量： 在HashSet中我们new对象的时候会创建一个初始默认容量是16的HashSet集合；其中默认的一个值loadFactor： 加载因子：0.75 加载因子是数组的长度的百分比；16*0.75 = 12； 意思就是数组中的桶数达到12个时数组就要扩容；（复制），扩容到原来的2倍； 0.75是一个折中的数据；是增删改查的最优速度； new的时候可以直接初始化数组长度和loadFactor（加载因子）来改变加载因子； 注意： 对于HashSet中保存的对象，主要要正确重写equals方法和hashCode方法，以保证放入Set对象的唯一性 虽说是Set是对于重复的元素不放入，倒不如直接说是底层的Map直接把原值替代了 HashSet没有提供get()方法，愿意是同HashMap一样，Set内部是无序的，只能通过迭代的方式获得 2.LinkedHashSetLinkedHashSet是继承自HashSet，底层实现是LinkedHashMap。并且其初始化时直接super(......) 查看了LinkedHashMap的构造方法后，发现其因为继承自HashMap，所以其底层实现也是HashMap!!!，然后发现了LinkedHashMap调用父类构造方法初始化时，还顺便设置了变量accessOrder = false，看上面得源码可以知道，这是给了迭代器一个参数，false代表迭代时使用插入得顺序 3.TreeSet1、TreeSet(树集)是一个有序集合，可以按照任何顺序将元素插入该集合，当对该集合进行迭代时，各个值将自动以排序后的顺序出现。TreeSet中的元素按照升序排列，缺省是按照自然顺序进行排序，意味着TreeSet中的元素要实现Comparable接口，或者有一个自定义的比较器Comparator。 2、TreeSet底层使用的是TreeMap，TreeMap的底层实现是红黑树 1234public TreeSet()&#123; this(new TreeMap&lt;E,Object&gt;());&#125; 注意： 1、TreeSet的排列顺序必须是全局顺序，也就是说任何两个元素都是必须可比的，同时只有当他们比较相同时才返回0。 2、如果树集包含了n个元素，那么平均需要进行log2n次比较，才能找到新元素的正确位置。]]></content>
      <categories>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM(1)之内存区域]]></title>
    <url>%2F2019%2F05%2F26%2Fjvm%2FJVM(1)%E4%B9%8B%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%2FJVM(1)%E4%B9%8B%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[JVM(1)之内存区域之内存区域\jvm内存区域.png) 了解如何通过参数来控制各区域的内存大小 之内存区域\jvm内存参数.png) 控制参数： -Xms：设置堆的最小空间大小。 -Xmx：设置堆的最大空间大小。 -XX:NewSize：设置新生代最小空间大小。 -XX:MaxNewSize：设置新生代最大空间大小。 -XX:PermSize：设置永久代最小空间大小。 -XX:MaxPermSize：设置永久代最大空间大小。 -Xss：设置每个线程的堆栈大小。 没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。 老年代空间大小=堆空间大小-年轻代大空间大小 程序计数器(program counter register)程序计数器的作用： 当前线程所执行的字节码的行号指示器，字节码的解析工作就是通过改变这个计数器的值来选取下一个需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。（线程私有的） 程序计数器的记录内容： 如果线程正在执行一个java方法，则程序计数器里面记录着正在执行的虚拟机字节码指令的地址； 如果正在执行的是native方法，则程序计数器里面为null。 特殊例子： 此内存区域是唯一一个在java虚拟机规范中没有OutOfMemoryError情况的区域。 java虚拟机栈(JVM Stacks)生命周期：与线程相同，线程私有。 虚拟机栈描述的是java方法执行的内存模型。 JVM栈的作用：每个方法被执行的时候，都会同时创建一个栈帧(stack frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法被调用至执行完成的过程，其实就是一个栈帧从入栈到出栈的过程。 局部变量表存放了的内容： 存放着编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。 理解性内容： 其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 该区域的异常状况： 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常； 如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。 本地方法栈(native method stacks)本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。 java堆(java heap)对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。（线程共享） Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。 作用：此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。 如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细分年轻代的有Eden空间、From Survivor空间、To Survivor空间等。(默认比例8:1:1)（详情在GC算法和回收中提到） 理解性： 根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。 异常状况： 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 方法区(method area)方法区和Java堆一样，是各个线程共享的内存区域 作用：它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。 这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载 异常状况： 根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。 运行时常量池(runtime constant pool)运行时的常量池属于方法区的一部分。 作用：用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。编译器和运行期(String 的 intern() )都可以将常量放入池中。 异常状况 当常量池无法再申请到内存时会抛出OutOfMemoryError 异常。 直接内存(direct memory)直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现。 本机直接内存的分配不会受到Java 堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括RAM 及SWAP 区或者分页文件）的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。 对象访问Object obj = new Object(); 最简单的访问，却涉及Java 栈、Java 堆、方法区这三个最重要内存区 假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java 栈的本地变量表中，作为一个reference 类型数据出现。 “new Object()”这部分的语义将会反映到Java 堆中，形成一块存储了Object 类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。 在Java 堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。 由于reference 类型在Java 虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java 堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。 如果使用句柄访问方式，Java 堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息 之内存区域\jvm内存区域句柄.jpg) 如果使用直接指针访问方式，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference 中直接存储的就是对象地址 之内存区域\jvm内存区域直接访问.jpg) 使用句柄访问方式的最大好处就是reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference 本身不需要被修改。 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。 就主要虚拟机Sun HotSpot 而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。 OutOfMemoryError分析(OOM)java堆溢出 1java.lang.OutOfMemoryError：Java heap space java栈溢出 1java.lang.StackOverflowError 运行时常量池溢出 1java.lang.OutOfMemoryError：PermGen space 方法区溢出 1java.lang.OutOfMemoryError：PermGen space 本机直接内存溢出 1java.lang.OutOfMemoryError]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM(2)之垃圾收集器与内存分配]]></title>
    <url>%2F2019%2F05%2F26%2Fjvm%2FJVM(2)%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2FJVM(2)%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[JVM(2)之垃圾收集器与内存分配垃圾回收区域： 程序计数器、虚拟机栈、本地方法栈 3 个区域随线程生灭(因为是线程私有)，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。 而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期才知道那些对象会创建，这部分内存的分配和回收都是动态的，垃圾回收期所关注的就是java堆和方法区。 判断对象死活引用计数法： 给对象添加一个引用计数器。但是难以解决循环引用问题。 之垃圾收集器与内存分配\垃圾回收引用计数法.png) 对象objA和objB都有字段instance，赋值令objA.instance = objB及objB.instance = objA，除此以外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0,如果不下小心直接把 Obj1-reference 和 Obj2-reference 置 null。则在 Java 堆当中的两块内存依然保持着互相引用无法回收。 可达性分析(根搜索算法)： 通过一系列的 ‘GC Roots’ 的对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连的时候说明对象不可用。 之垃圾收集器与内存分配\垃圾回收根搜索算法.jpg) 可作为 GC Roots 的对象： 虚拟机栈(栈帧中的本地变量表)中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象 引用的类别： 强引用：类似于 Object obj = new Object(); 创建的，只要强引用在就不回收。 软引用：SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。 弱引用：WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。 虚引用：PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 回收方法区在堆中，尤其是在新生代中，一次垃圾回收一般可以回收 70% ~ 95% 的空间，而永久代的垃圾收集效率远低于此。 永久代垃圾回收主要两部分内容：废弃的常量和无用的类。 判断废弃常量：一般是判断没有该常量的引用。 判断无用的类：要以下三个条件都满足 该类所有的实例都已经回收，也就是 Java 堆中不存在该类的任何实例 加载该类的 ClassLoader 已经被回收 该类对应的 java.lang.Class 对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法 垃圾回收算法标记-清除算法： 标记所有需要回收的对象，标记完成后统一进行回收被标记的对象 缺点： 效率不高 空间产生大量碎片 复制算法： 思路：把空间分成两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。 解决前一种方法的不足，但是会造成空间利用率低下。因为大多数新生代对象都不会熬过第一次 GC。所以没必要 1 : 1 划分空间。可以分一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另一块 Survivor 上，最后清理 Eden 和 Survivor 空间。大小比例一般是 8 : 1 : 1，每次浪费 10% 的 Survivor 空间。 但是这里有一个问题就是如果存活的大于 10% 怎么办？这里采用一种分配担保策略：多出来的对象直接进入老年代。 标记-整理算法： 与标记-清除算法不同的一点是，会把存活对象移动一端，解决空间产生大量碎片的缺点。 分代收集算法： 当前商业虚拟机的垃圾收集都采用分代收集算法。 把java堆分成新生代和老年代，根据各个年代的特点采用最合适的收集算法。 在新生代中，每次垃圾回收时都发现大批对象死去，只有少量存活，选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。 在老年代中，对象存活率高，没有额外空间对他进行分配担保，就使用标记清除或者标记整理算法回收。 垃圾收集器之垃圾收集器与内存分配\垃圾回收收集器.jpg) 说明：如果两个收集器之间存在连线说明他们之间可以搭配使用。 serial收集器 这是一个单线程收集器。意味着它只会使用一个 CPU 或一条收集线程去完成收集工作，并且在进行垃圾回收时必须暂停其它所有的工作线程直到收集结束。 之垃圾收集器与内存分配\serial收集器.jpg) ParNew收集器 Serial 收集器的多线程版本，许多运行在server模式下的虚拟机中首选的新生代收集器，原因是处理Serial收集器，只有它能与CMS收集器配合工作(真正意义上的并发收集器，实现让垃圾收集线程和用户线程同时工作) 之垃圾收集器与内存分配\ParNew收集器.jpg) Parallel Scavenge收集器 并行和并发区别： 并行(Parallel)：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态 并发(Concurrent)：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户线程继续运行，而垃圾收集程序运行于另一个CPU上。 这是一个新生代收集器，也是使用复制算法实现，同时也是并行的多线程收集器。 CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程所停顿的时间，而 Parallel Scavenge 收集器的目的是达到一个可控制的吞吐量(Throughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间) )。 Parallel Scavenge收集器提供两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数和直接设置吞吐量大小的-XX:GCTimeRatio参数。 -XX:MaxGCPauseMillis：允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过设定值。GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的(并不是把参数设置越小越好) -XX:GCTimeRatio：是一个大于0小于100的整数，是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。 -XX:+UserAdaptiveSIzePolicy：作为一个吞吐量优先的收集器，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整停顿时间。这就是 GC 的自适应调整策略(GC Ergonomics)。 Serial Old收集器 收集器的老年代版本，单线程，使用 标记 —— 整理。 Parallel Old收集器 Parallel Old 是 Parallel Scavenge 收集器的老年代版本。多线程，使用 标记 —— 整理 之垃圾收集器与内存分配\parallelold收集器.png) CMS收集器 CMS (Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器。基于 标记 —— 清除 算法实现。 运作步骤： 初始标记(CMS initial mark)：标记 GC Roots 能直接关联到的对象 并发标记(CMS concurrent mark)：进行 GC Roots Tracing(根搜索算法) 重新标记(CMS remark)：修正并发标记期间的变动部分 并发清除(CMS concurrent sweep) 其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）。 优点: 并发收集、低停顿缺点: 对 CPU 资源敏感、无法收集浮动垃圾、标记 —— 清除 算法带来的空间碎片 之垃圾收集器与内存分配\CMS收集器.png) G1收集器 G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点： 空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。 可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。 上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（物理可以不连续、逻辑连续的一段内存）Region的集合。 之垃圾收集器与内存分配\G1垃圾回收器.png) 之垃圾收集器与内存分配\G1步骤.png) 之垃圾收集器与内存分配\G1收集器运行.png) G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。 收集步骤： 1、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark) 2、Root Region Scanning根区域扫描，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。 3、Concurrent Marking并发标记，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。 4、Remark, 最终标记，会有短暂停顿(STW:stop the world)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。 5、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。 6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。 内存分配与回收策略对象的内存分配，往大方向上讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地在栈上分配），对象主要分配在新生代的Eden区上，如果启动本地线程分配缓冲(TLAB)，将线程上优先在TLAB上分配少数情况下也可能会直接分配在老年代中，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数配置。 对象优先在Eden分配 对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲区，将线程优先在 (TLAB) 上分配。少数情况会直接分配在老年代中。 之垃圾收集器与内存分配\java堆内存模型.png) 新生代和老年代： 新生代GC(minor GC)：发生在新生代的垃圾回收动作，频繁，速度快。 老年代GC(Major GC / Full GC)：发生在老年代的垃圾回收动作，出现了 Major GC 经常会伴随至少一次 Minor GC(非绝对)。Major GC 的速度一般会比 Minor GC 慢十倍以上。 大对象直接进入老年代 大对象指的是需要大量连续内存空间的java对象，最典型的大对象是那种很长字符串及数组(byte[]数组就是典型大对象) 虚拟机提供一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代中分配。目的是避免在Eden区及两个Survivor区之间发生大量的内存拷贝。 长期存活的对象直接进入老年代 虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。 动态对象年龄判断 如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。 空间分配担保 每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合类之MAP]]></title>
    <url>%2F2019%2F05%2F26%2Fjava%E9%9B%86%E5%90%88%E7%B1%BB%2F%E9%9B%86%E5%90%88%E7%B1%BB%E4%B9%8BMAP%2F%E9%9B%86%E5%90%88%E7%B1%BB%E4%B9%8BMAP%2F</url>
    <content type="text"><![CDATA[集合类之MAPmap架构 如上图：(1) Map 是映射接口，Map中存储的内容是键值对*(key-value)*。(2) AbstractMap 是继承于Map的抽象类，它实现了Map中的大部分API。其它Map的实现类可以通过继承AbstractMap来减少重复编码。(3) SortedMap 是继承于Map的接口。SortedMap中的内容是排序的键值对，排序的方法是通过比较器(Comparator)。(4) NavigableMap 是继承于SortedMap的接口。相比于SortedMap，NavigableMap有一系列的导航方法；如”获取大于/等于某对象的键值对”、“获取小于/等于某对象的键值对”等等。(5) TreeMap 继承于AbstractMap，且实现了NavigableMap接口；因此，TreeMap中的内容是“有序的键值对”！(6) HashMap 继承于AbstractMap，但没实现NavigableMap接口；因此，HashMap的内容是“键值对，但不保证次序”！(7) Hashtable 虽然不是继承于AbstractMap，但它继承于Dictionary(Dictionary也是键值对的接口)，而且也实现Map接口；因此，Hashtable的内容也是“键值对，也不保证次序”。但和HashMap相比，Hashtable是线程安全的，而且它支持通过Enumeration去遍历。(8) WeakHashMap 继承于AbstractMap。它和HashMap的键类型不同，WeakHashMap的键是“弱键”。 HashMap1、HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。 2、HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。 3、HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。 4、HashMap中的映射不是有序的。 HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。 从图中可以看出：(01) HashMap继承于AbstractMap类，实现了Map接口。Map是”key-value键值对”接口，AbstractMap实现了”键值对”的通用函数接口。(02) HashMap是通过”拉链法”实现的哈希表。它包括几个重要的成员变量：table, size, threshold, loadFactor, modCount。 table是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。 size是HashMap的大小，它是HashMap保存的键值对的数量。 threshold是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值=”容量*加载因子”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 loadFactor就是加载因子。 modCount是用来实现fail-fast机制的。 1、存储结构 hashmap底层是以数组方式进行存储。将key-value对作为数组中的一个元素进行存储。 key-value都是Map.Entry中的属性。其中将key的值进行hash之后进行存储，即每一个key都是计算hash值，然后再存储。每一个Hash值对应一个数组下标，数组下标是根据hash值和数组长度计算得来。 由于不同的key有可能hash值相同，即该位置的数组中的元素出现两个，对于这种情况，hashmap采用链表形式进行存储。 下图描述了hashmap的存储结构图 Entry结构分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key;// map中key值，可以为null。 V value; // map中的value值，可以为null。 Entry&lt;K,V&gt; next;// 链表引用，防止key值不同，hash值相同。 int hash; // 每个key的hash值 // 构造函数 Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; // 同一个key时，新值替换旧值，返回旧值 public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // key值重写equals方法 public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; // 重写hashCode值 public final int hashCode() &#123; return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue()); &#125; public final String toString() &#123; return getKey() + "=" + getValue(); &#125; // 其他方法省略 &#125; HashMap属性分析 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable&#123; /** *默认情况下，hashmap大小为16.即1&lt;&lt;4就是1乘以2的4次幂=16 */ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 /** * hashMap的最大值 */ static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /** * 默认加载加载因子，即使用空间达到总空间的0.75时，需要扩容。 */ static final float DEFAULT_LOAD_FACTOR = 0.75f; /** * 声明hashmap一个空数组。 */ static final Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;; /** * 最开始时，hashmap是一个空数组。 */ transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE; /** * map的元素的个数 */ transient int size; /* * hashmap的实际存储空间大小。这个空间是总空间*加载因子得出的大小。 * 比如默认是16，加载因子是0.74。则threshold就是12。 */ int threshold; /** * 加载因子，即使用空间达到总空间的0.75时，需要扩容。 */ final float loadFactor; /** * */ transient int modCount; /** * threshold这个值的最大值就是Integer.MAX_VALUE */ static final int ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE; put方法 put（key,value）方法是hashmap中最重要的方法，使用hashmap最主要的就是使用put,get两个方法。可以从put方法的源码进行分析 1234567891011121314151617181920212223242526272829303132public V put(K key, V value) &#123; // 首次存储元素，初始化存储空间 if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; // 如果key为null，则将null放入元素的第一个位置 if (key == null) return putForNullKey(value); // 计算key的hash值 int hash = hash(key); // 根据key的hash值，数组长度计算该Entry&lt;key,value&gt;的数组下标 int i = indexFor(hash, table.length); /** **如果当前key的已经存在于map中，则将新值替换成旧值。 **/ for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 判断同一个key，既要判断hash值相同，还要判断key是同一个key，因为 // 相同的key有可能hash值也相同。双重判断保证是同一个key。 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 如果是新的key需要存储，则增加操作次数modCount++ modCount++; // 将新增key-value键值对添加中map中。 addEntry(hash, key, value, i); return null; &#125; addEntry方法 addEntry方法是将新增的key-value键值对存入到map中。该方法主要完成两个功能：1.1. 添加新元素前， 判断是否需要对map的数组进行扩容，如果需要扩容，则扩容空间大小是原来的两倍1.2. 对于新增key-value键值对，如果key的hash值相同，则构造单向列表。 从源码分析结果如下： 123456789101112131415/**** hash:key的hash值** key:存储的键** value：存储的value对象值*** bucketIndex：数组下标位置，即key-value在数组中的位置。**/void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length);//扩容两倍 hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; // 往数组中添加新的key-value键值对 createEntry(hash, key, value, bucketIndex); &#125; createEntry方法 该方法主要完成两个功能 1、添加新的key到Entry数组中 2、对于不同key的hash值相同的情况下，在同一个数组下标处，构建单向链表进行存储。 1234567void createEntry(int hash, K key, V value, int bucketIndex) &#123; // 取出当前位置的元素，如果是新添加的key,则e为null，已经有的元素为不为空。 Entry&lt;K,V&gt; e = table[bucketIndex]; // 添加新的key-value值或构建链表 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++; &#125; 遍历HashMap的键 根据keySet()获取HashMap的“键”的Set集合。 通过Iterator迭代器遍历“第一步”得到的集合 1234567891011// 假设map是HashMap对象// map中的key是String类型，value是Integer类型String key = null;Integer integ = null;Iterator iter = map.keySet().iterator();while (iter.hasNext()) &#123; // 获取key key = (String)iter.next(); // 根据key，获取value integ = (Integer)map.get(key);&#125; 遍历HashMap的值 根据value()获取HashMap的“值”的集合。 通过Iterator迭代器遍历“第一步”得到的集合。 12345678// 假设map是HashMap对象// map中的key是String类型，value是Integer类型Integer value = null;Collection c = map.values();Iterator iter= c.iterator();while (iter.hasNext()) &#123; value = (Integer)iter.next();&#125; TreeMap TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。 TreeMap 继承于AbstractMap，所以它是一个Map，即一个key-value集合。 TreeMap 实现了NavigableMap接口，意味着它支持一系列的导航方法。比如返回有序的key集合。 TreeMap 实现了Cloneable接口，意味着它能被克隆。 TreeMap 实现了java.io.Serializable接口，意味着它支持序列化。 TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。 TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n)（jdk1.8之后加入红黑树由o(n)变为o( log(n) ) ） 。 TreeMap是非同步的。 它的iterator 方法返回的迭代器是fail-fastl的 从图中可以看出：(1) TreeMap实现继承于AbstractMap，并且实现了NavigableMap接口。(2) TreeMap的本质是R-B Tree(红黑树)，它包含几个重要的成员变量： root, size, comparator。 root 是红黑数的根节点。它是Entry类型，Entry是红黑数的节点，它包含了红黑数的6个基本组成成分：key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色)。Entry节点根据key进行排序，Entry节点包含的内容为value。 红黑数排序时，根据Entry中的key进行排序；Entry中的key比较大小是根据比较器comparator来进行判断的。size是红黑数中节点的个数。 数据结构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; K key; //键 V value; //值 Entry&lt;K,V&gt; left = null; //左孩子节点 Entry&lt;K,V&gt; right = null; //右孩子节点 Entry&lt;K,V&gt; parent; //父节点 boolean color = BLACK; //节点的颜色，在红黑树种，只有两种颜色，红色和黑色 //构造方法，用指定的key,value ,parent初始化，color默认为黑色 Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123; this.key = key; this.value = value; this.parent = parent; &#125; //返回key public K getKey() &#123; return key; &#125; //返回该节点对应的value public V getValue() &#123; return value; &#125; //替换节点的值，并返回旧值 public V setValue(V value) &#123; V oldValue = this.value; this.value = value; return oldValue; &#125; //重写equals()方法 public boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; //两个节点的key相等，value相等，这两个节点才相等 return valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue()); &#125; //重写hashCode()方法 public int hashCode() &#123; int keyHash = (key==null ? 0 : key.hashCode()); int valueHash = (value==null ? 0 : value.hashCode()); //key和vale hash值得异或运算，相同则为零，不同则为1 return keyHash ^ valueHash; &#125; //重写toString()方法 public String toString() &#123; return key + "=" + value; &#125;&#125; 构造方法 1234567891011121314151617181920212223242526//构造方法，comparator用键的顺序做比较public TreeMap() &#123; comparator = null;&#125;//构造方法，提供比较器，用指定比较器排序public TreeMap(Comparator&lt;? super K&gt; comparator) &#123; his.comparator = comparator;&#125;//将m中的元素转化daoTreeMap中，按照键的顺序做比较排序public TreeMap(Map&lt;? extends K, ? extends V&gt; m) &#123; comparator = null; putAll(m);&#125;//构造方法，指定的参数为SortedMap//采用m的比较器排序public TreeMap(SortedMap&lt;K, ? extends V&gt; m) &#123; comparator = m.comparator(); try &#123; buildFromSorted(m.size(), m.entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125;&#125; TreeMap提供了四个构造方法，实现了方法的重载。无参构造方法中比较器的值为null,采用自然排序的方法，如果指定了比较器则称之为定制排序. 自然排序：TreeMap的所有key必须实现Comparable接口，所有的key都是同一个类的对象 定制排序：创建TreeMap对象传入了一个Comparator对象，该对象负责对TreeMap中所有的key进行排序，采用定制排序不要求Map的key实现Comparable接口。 Put()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; //红黑树的根节点 if (t == null) &#123; //红黑树是否为空 compare(key, key); // type (and possibly null) check //构造根节点，因为根节点没有父节点，传入null值。 root = new Entry&lt;&gt;(key, value, null); size = 1; //size值加1 modCount++; //改变修改的次数 return null; //返回null &#125; int cmp; Entry&lt;K,V&gt; parent; //定义节点 Comparator&lt;? super K&gt; cpr = comparator; //获取比较器 if (cpr != null) &#123; //如果定义了比较器，采用自定义比较器进行比较 do &#123; parent = t; //将红黑树根节点赋值给parent cmp = cpr.compare(key, t.key); //比较key, 与根节点的大小 if (cmp &lt; 0) //如果key &lt; t.key , 指向左子树 t = t.left; //t = t.left , t == 它的做孩子节点 else if (cmp &gt; 0) t = t.right; //如果key &gt; t.key , 指向它的右孩子节点 else return t.setValue(value); //如果它们相等，替换key的值 &#125; while (t != null); //循环遍历 &#125; else &#123; //自然排序方式，没有指定比较器 if (key == null) throw new NullPointerException(); //抛出异常 Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; //类型转换 do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) // key &lt; t.key t = t.left; //左孩子 else if (cmp &gt; 0) // key &gt; t.key t = t.right; //右孩子 else return t.setValue(value); //t == t.key , 替换value值 &#125; while (t != null); &#125; Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); //创建新节点，并制定父节点 //根据比较结果，决定新节点为父节点的左孩子或者右孩子 if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e); //新插入节点后重新调整红黑树 size++; modCount++; return null;&#125;//比较方法，如果comparator==null ,采用comparable.compartTo进行比较，否则采用指定比较器比较大小final int compare(Object k1, Object k2) &#123; return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2) : comparator.compare((K)k1, (K)k2);&#125;private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; //插入的节点默认的颜色为红色 x.color = RED; // //情形1： 新节点x 是树的根节点，没有父节点不需要任何操作 //情形2： 新节点x 的父节点颜色是黑色的，也不需要任何操作 while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; //情形3：新节点x的父节点颜色是红色的 //判断x的节点的父节点位置，是否属于左孩子 if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; //获取x节点的父节点的兄弟节点，上面语句已经判断出x节点的父节点为左孩子，所以直接取右孩子 Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); //判断是否x节点的父节点的兄弟节点为红色。 if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); // x节点的父节点设置为黑色 setColor(y, BLACK); // y节点的颜色设置为黑色 setColor(parentOf(parentOf(x)), RED); // x.parent.parent设置为红色 x = parentOf(parentOf(x)); // x == x.parent.parent ,进行遍历。 &#125; else &#123; //x的父节点的兄弟节点是黑色或者缺少的 if (x == rightOf(parentOf(x))) &#123; //判断x节点是否为父节点的右孩子 x = parentOf(x); //x == 父节点 rotateLeft(x); //左旋转操作 &#125; //x节点是其父的左孩子 setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); //上面两句将x.parent 和x.parent.parent的颜色做调换 rotateRight(parentOf(parentOf(x))); //进行右旋转 &#125; &#125; else &#123; Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); //y 是x 节点的祖父节点的左孩子 if (colorOf(y) == RED) &#123; //判断颜色 setColor(parentOf(x), BLACK); //父节点设置为黑色 setColor(y, BLACK); //父节点的兄弟节点设置为黑色 setColor(parentOf(parentOf(x)), RED); //祖父节点设置为红色 x = parentOf(parentOf(x)); //将祖父节点作为新插入的节点，遍历调整 &#125; else &#123; if (x == leftOf(parentOf(x))) &#123; //x 是其父亲的左孩子 x = parentOf(x); rotateRight(x); //以父节点为旋转点，进行右旋操作 &#125; setColor(parentOf(x), BLACK); //父节点为设置为黑色 setColor(parentOf(parentOf(x)), RED); //祖父节点设置为红色 rotateLeft(parentOf(parentOf(x))); //以父节点为旋转点，进行左旋操作 &#125; &#125; &#125; root.color = BLACK; //通过节点位置的调整，最终将红色的节点条调换到了根节点的位置，根节点重新设置为黑色&#125; 增加删除节点都运用了红黑树的原理，红黑树有五个特点： 每个节点只能是红色或者黑色 根节点永远是黑色的 所有的叶子的子节点都是空节点，并且都是黑色的 每个红色节点的两个子节点都是黑色的（不会有两个连续的红色节点） 从任一个节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点（叶子节点到根节点的黑色节点数量每条路径都相同） 红黑树插入新节点的三个关键地方：1、插入新节点总是红色节点。2、插入节点的父节点是黑色，能维持性质。3、如果插入节点的父节点是红色，破坏了性质。故插入算法就是通过重新着色或旋转，来维持性质 deleteEntry()方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private void deleteEntry(Entry&lt;K,V&gt; p) &#123; modCount++; //修改次数 +1 size--; //元素个数 -1 /* * 被删除节点的左子树和右子树都不为空，那么就用 p节点的中序后继节点代替 p 节点 * successor(P)方法为寻找P的替代节点。规则是右分支最左边，或者 左分支最右边的节点 * ---------------------（1） */ if (p.left != null &amp;&amp; p.right != null) &#123; Entry&lt;K,V&gt; s = successor(p); p.key = s.key; p.value = s.value; p = s; &#125; //replacement为替代节点，如果P的左子树存在那么就用左子树替代，否则用右子树替代 Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); /* * 删除节点，分为上面提到的三种情况 * -----------------------（2） */ //如果替代节点不为空 if (replacement != null) &#123; replacement.parent = p.parent; /* *replacement来替代P节点 */ //若P没有父节点，则跟节点直接变成replacement if (p.parent == null) root = replacement; //如果P为左节点，则用replacement来替代为左节点 else if (p == p.parent.left) p.parent.left = replacement; //如果P为右节点，则用replacement来替代为右节点 else p.parent.right = replacement; //同时将P节点从这棵树中剔除掉 p.left = p.right = p.parent = null; /* * 若P为红色直接删除，红黑树保持平衡 * 但是若P为黑色，则需要调整红黑树使其保持平衡 */ if (p.color == BLACK) fixAfterDeletion(replacement); &#125; else if (p.parent == null) &#123; //p没有父节点，表示为P根节点，直接删除即可 root = null; &#125; else &#123; //P节点不存在子节点，直接删除即可 if (p.color == BLACK) //如果P节点的颜色为黑色，对红黑树进行调整 fixAfterDeletion(p); //删除P节点 if (p.parent != null) &#123; if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; &#125; &#125; &#125; TreeMap还有很多地方没有写全，后续再来补学。 TreeMap问题集锦 1、TreeMap的键、值能否为null value是可以为null的 当未实现 Comparator 接口时，key 不可以为null，否则抛 NullPointerException 异常； 当实现 Comparator 接口时，若未对 null 情况进行判断，则可能抛 NullPointerException 异常。如果针对null情况实现了，可以存入，但是却不能正常使用get()访问，只能通过遍历去访问。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748测试Value能否为null public static void main(String[] args) &#123; TreeMap&lt;String, Integer&gt; treeMap = new TreeMap&lt;&gt;(); treeMap.put("1",1); treeMap.put("2",null); System.out.println(treeMap.get("2")); &#125; 结果：null 测试key能否为null public static void main(String[] args) &#123; TreeMap&lt;String, Integer&gt; treeMap = new TreeMap&lt;&gt;(); treeMap.put("1",1); treeMap.put(null,null); System.out.println(treeMap.get("2")); &#125; 结果：Exception in thread "main" java.lang.NullPointerException at java.util.TreeMap.put(TreeMap.java:563) at com.crazy_june.test_treemap.main(test_treemap.java:9) 测试当自己实现一个comparator接口时 public static void main(String[] args) &#123; TreeMap&lt;String, Integer&gt; treeMap = new TreeMap&lt;&gt;(new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; if(o1==null)&#123; return 1; &#125;else &#123; return o2.charAt(0)-o1.charAt(0); &#125; &#125; &#125;); treeMap.put("1",1); treeMap.put(null,12); treeMap.put("2",2); System.out.println(treeMap.get(null)); &#125; 结果：null 证明不能通过get()取出来 测试通过遍历entry可以取出来不 for(Map.Entry&lt;String,Integer&gt; entry:treeMap.entrySet())&#123; System.out.println(entry.getKey()+":"+entry.getValue()); &#125; 结果： 2:2 1:1 null:12]]></content>
      <categories>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程(一)]]></title>
    <url>%2F2019%2F05%2F26%2F%E5%B9%B6%E5%8F%91%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%80)%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[多线程(一)进程和线程的基本概念进程：系统中能独立运行并作为资源分配的基本单位 进程的特征： 1.动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的。2.并发性：任何进程都可以同其他进程一起并发执行。3.独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位。4.异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。 线程：是进程中的一个实体，作为系统调度和分派的基本单位。 线程的性质： 1.线程是进程内的一个相对独立的可执行的单元。若把进程称为任务的话，那么线程则是应用中的一个子任务的执行。2.由于线程是被调度的基本单元，而进程不是调度单元。所以，每个进程在创建时，至少需要同时为该进程创建一个线程。即进程中至少要有一个或一个以上的线程，否则该进程无法被调度执行。3.进程是被分给并拥有资源的基本单元。同一进程内的多个线程共享该进程的资源，但线程并不拥有资源，只是使用他们。4.线程是操作系统中基本调度单元，因此线程中应包含有调度所需要的必要信息，且在生命周期中有状态的变化。5.由于共享资源【包括数据和文件】，所以线程间需要通信和同步机制，且需要时线程可以创建其他线程，但线程间不存在父子关系。 进程与线程的区别： 1、调度：在传统的操作系统中，CPU调度和分派的基本单位是进程。在引入线程的操作系统中，则把线程作为CPU调度和分派的基本单位，进程则作为资源拥有的基本单位，将线程作为cpu调度和分派，进程则作为资源拥有的基本单位，显著提高系统的并发性（同一进程中的线程切换不会引起进程切换，不同进程中的线程切换才会引起进程切换） 2、并发性：进程之间可以并发执行，同一个进程之间的线程也可以并发执行，提高系统资源和系统吞吐量 （例如，在一个为引入线程的单CPU操作系统中，若仅设置一个文件服务进程，当它由于某种原因被封锁时，便没有其他的文件服务进程来提供服务。在引入线程的操作系统中，可以在一个文件服务进程设置多个服务线程。当第一个线程等待时，文件服务进程中的第二个线程可以继续运行；当第二个线程封锁时，第三个线程可以继续执行，从而显著地提高了文件服务的质量以及系统的吞吐量。） 3、拥有资源：进程拥系统资源的独立单位，线程不能拥有自己的资源，但可以访问隶属进程的资源（代码段、数据段以及系统资源，可供同一个进程的其他线程共享） 4、独立性：在同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多，这是因为为了防止进程之间彼此干扰和破坏，每个进程都拥有一个独立的地址空间和其它资源，除了共享全局变量外，不允许其它进程的访问。 5、系统开销：由于在创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等。因此，操作系统为此所付出的开销将显著地大于在创建或撤消线程时的开销。 6、支持多处理机系统： 在多处理机系统中，对于传统的进程，即单线程进程，不管有多少处理机，该进程只能运行在一个处理机上。但对于多线程进程，就可以将一个进程中的多个线程分配到多个处理机上，使它们并行执行，这无疑将加速进程的完成。 创建和启动线程1、继承Thread类创建线程类 步骤： 定义一个继承Thread类的子类，并重写该类的run()方法 创建子类的实例，即创建线程对象 调用该线程对象的start()方法启动线程 1234567891011class SomeThead extends Thraad &#123; public void run() &#123; //do something here &#125; &#125; public static void main(String[] args)&#123; SomeThread oneThread = new SomeThread(); //启动线程： oneThread.start(); &#125; 2、实现Runnable接口创建线程类 步骤： 定义Runnable接口的实现类，并重写该接口的的run()方法 创建该实现类的实例 以此实例作为创建Thread对象的参数，该Thread对象即是线程对象 12345678class SomeRunnable implements Runnable &#123; public void run() &#123; //do something here &#125; &#125; Runnable oneRunnable = new SomeRunnable(); Thread oneThread = new Thread(oneRunnable); oneThread.start(); 3、通过Callable和Future创建对象 步骤： 创建Callable接口的实现类，并实现call()方法，该call()方法作为线程执行体，并且有返回值 创建Callable实现类的实例 使用FutureTask类来包装Callable对象，该FutureTask对象封装Callable对象的call()方法的返回值 使用FutureTask对象作为Thread对象的target创建并启动新线程 调用FutureTask对象的get()方法获取子线程执行结束后的返回值 12345678910111213public interface Callable &#123; V call() throws Exception; &#125; 步骤1：创建实现Callable接口的类SomeCallable(略); 步骤2：创建一个类对象： Callable oneCallable = new SomeCallable(); 步骤3：由Callable创建一个FutureTask对象： FutureTask oneTask = new FutureTask(oneCallable); 注释： FutureTask是一个包装器，它通过接受Callable来创建，它同时实现了 Future和Runnable接口。 步骤4：由FutureTask创建一个Thread对象： Thread oneThread = new Thread(oneTask); 步骤5：启动线程： oneThread.start(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ThreadTest &#123; public static void main(String[] args) &#123; Callable&lt;Integer&gt; myCallable = new MyCallable(); // 创建MyCallable对象 FutureTask&lt;Integer&gt; ft = new FutureTask&lt;Integer&gt;(myCallable); //使用FutureTask来包装MyCallable对象 for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + " " + i); if (i == 30) &#123; Thread thread = new Thread(ft); //FutureTask对象作为Thread对象的target创建新的线程 thread.start(); //线程进入到就绪状态 &#125; &#125; System.out.println("主线程for循环执行完毕.."); try &#123; int sum = ft.get(); //取得新创建的新线程中的call()方法返回的结果 System.out.println("sum = " + sum); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class MyCallable implements Callable&lt;Integer&gt; &#123; private int i = 0; // 与run()方法不同的是，call()方法具有返回值 @Override public Integer call() &#123; int sum = 0; for (; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + " " + i); sum += i; &#125; return sum; &#125;&#125; 线程的生命周期\线程生命周期.png) 1、新建状态 用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态（runnable）。 2、就绪状态 处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为cpu的调度不一定是按照先进先出的顺序来调度的），等待系统为其分配CPU。等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“cpu调度”。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。 提示：如果希望子线程调用start()方法后立即执行，可以使用Thread.sleep()方式使主线程睡眠一伙儿，转去执行子线程。 3、运行状态 处于就绪状态的线程，如果获得了cpu的调度，就会从就绪状态变为运行状态，执行run()方法中的任务。 运行状态-&gt;就绪状态：1.失去cpu资源 2.调用yield()方法 运行状态-&gt;阻塞状态： 1.调用sleep()方法主动放弃cpu资源 2.线程调用一个阻塞式IO方法，在该方法返回之前，线程被阻塞 3.线程试图获取一个同步监视器（锁），但该同步监视器正被其他线程所持有 4.线程在等待某个通知（notify） 5.程序调用线程的suspend方法被线程挂起（容易导致死锁） 4、阻塞状态 只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的I/O设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行。 5、死亡状态 当线程的run()方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 线程管理1、线程睡眠sleep 让当前正在执行的线程暂停一段时间，并进入阻塞状态，且当前线程不会失去锁 sleep是静态方法，最好不要用Thread的实例对象调用它，因为它睡眠的始终是当前正在运行的线程，而不是调用它的线程对象，它只对正在运行状态的线程对象有效 123456789101112public class Test1 &#123; public static void main(String[] args) throws InterruptedException &#123; System.out.println(Thread.currentThread().getName()); MyThread myThread=new MyThread(); myThread.start(); myThread.sleep(1000);//这里sleep的就是main线程，而非myThread线程 Thread.sleep(10); for(int i=0;i&lt;100;i++)&#123; System.out.println("main"+i); &#125; &#125; &#125; 使用sleep方法之后，线程是进入阻塞状态的，只有当睡眠的时间结束，才会重新进入到就绪状态，而就绪状态进入到运行状态，是由系统控制的，我们不可能精准的去干涉它，所以如果调用Thread.sleep(1000)使得线程睡眠1秒，可能结果会大于1秒。 2、线程让步yield() yield()方法和sleep()方法有点相似，它也是Thread类提供的一个静态的方法，它也可以让当前正在执行的线程暂停，让出cpu资源给其他的线程。但是和sleep()方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。 3、线程合并join() 线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，应用场景是当一个线程必须等待另一个线程执行完毕才能执行时，Thread类提供了join方法来完成这个功能，它不是静态方法。从上面的方法的列表可以看到，它有3个重载的方法： 123456void join() 当前线程等该加入该线程后面，等待该线程终止。 void join(long millis) 当前线程等待该线程终止的时间最长为 millis 毫秒。 如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度 void join(long millis,int nanos) 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度 4、设置线程优先级 每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级。 12345MAX_PRIORITY =10MIN_PRIORITY =1NORM_PRIORITY =5 注：虽然Java提供了10个优先级别，但这些优先级别需要操作系统的支持。不同的操作系统的优先级并不相同，而且也不能很好的和Java的10个优先级别对应。所以我们应该使用MAX_PRIORITY、MIN_PRIORITY和NORM_PRIORITY三个静态常量来设定优先级，这样才能保证程序最好的可移植性。 5、后台(守护)线程 JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。 守护线程的用途为： ​ • 守护线程通常用于执行一些后台作业，例如在应用程序运行时播放背景音乐，在文字编辑器里做自动语法检查、自动保存等功能。 ​ • Java的垃圾回收也是一个守护线程。守护线的好处就是你不需要关心它的结束问题。例如你在你的应用程序运行的时候希望播放背景音乐，如果将这个播放背景音乐的线程设定为非守护线程，那么在用户请求退出的时候，不仅要退出主线程，还要通知播放背景音乐的线程退出；如果设定为守护线程则不需要了。 123456789public final void setDaemon(boolean on) 将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。 该方法必须在启动线程前调用。 该方法首先调用该线程的 checkAccess 方法，且不带任何参数。这可能抛出 SecurityException（在当前线程中）。 参数： on - 如果为 true，则将该线程标记为守护线程。 抛出： IllegalThreadStateException - 如果该线程处于活动状态。 SecurityException - 如果当前线程无法修改该线程。 6、正确结束线程 Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！想要安全有效的结束一个线程，可以使用下面的方法： ​ • 正常执行完run方法，然后结束掉； ​ • 控制循环条件和判断条件的标识符来结束掉线程。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM(3)之类的加载机制]]></title>
    <url>%2F2019%2F05%2F26%2Fjvm%2FJVM(3)%E4%B9%8B%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2FJVM(3)%E4%B9%8B%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[JVM(3)之类的加载机制什么是类的加载类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的 Class对象。 Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。 之类的加载机制\什么是类加载.jpg) 类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。 加载.class文件的方式 从本地系统中直接加载 通过网络下载.class文件 从zip，jar等归档文件中加载.class文件 从专有数据库中提取.class文件 将Java源文件动态编译为.class文件 类的生命周期之类的加载机制\类的生命周期.png) 其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。 加载在加载阶段，虚拟机需要完成以下三件事情： 通过一个类的全限定名来获取其定义的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在Java堆中生成一个代表这个类的 java.lang.Class对象，作为对方法区中这些数据的访问入口。 连接验证：确保被加载的类的正确性 验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作： 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 准备：为类的静态变量分配内存，并将其初始化为默认值 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意： 1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。 2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。 假设一个类变量的定义为： public static int value=3； 那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的 public static指令是在程序编译后，存放于类构造器 &lt;clinit&gt;（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。 1234567891011这里还需要注意如下几点：1、对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。2、对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。3、对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。4、如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。一句话总结以上几点，类变量、引用数据类型赋予默认值，常量、局部变量必须在声明或者初始化之前显示赋值，不然不通过编译 3、如果类字段的字段属性表中存在 ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。 假设上面的类变量value被定义为： public static final int value=3； 编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据 ConstantValue的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中 解析：把类中的符号引用转换为直接引用 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 初始化初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式： ①声明类变量是指定初始值 ②使用静态代码块为类变量指定初始值 JVM初始化步骤： 1、假如这个类还没有被加载和连接，则程序先加载并连接该类 2、假如该类的直接父类还没有被初始化，则先初始化其直接父类 3、假如类中有初始化语句，则系统依次执行这些初始化语句 类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种： 创建类的实例，也就是new的方式 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（如 Class.forName(“com.shengsiyuan.Test”)） 初始化某个类的子类，则其父类也会被初始化 Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类 结束生命周期在如下几种情况下，Java虚拟机将结束生命周期 执行了 System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止 类加载器之类的加载机制\类加载器.jpg) 站在Java开发人员的角度来看，类加载器可以大致划分为以下三类： 启动类加载器： BootstrapClassLoader，负责加载存放在 JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被 -Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被 BootstrapClassLoader加载）。启动类加载器是无法被Java程序直接引用的。扩展类加载器： ExtensionClassLoader，该加载器由 sun.misc.Launcher$ExtClassLoader实现，它负责加载 JDK\jre\lib\ext目录中，或者由 java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。应用程序类加载器： ApplicationClassLoader，该类加载器由 sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点： 1、在执行非置信代码之前，自动验证数字签名。 2、动态地创建符合用户特定需要的定制化构建类。 3、从特定的场所取得java class，例如数据库中和网络中。 JVM加载机制 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效 类的加载三种方式： 1、命令行启动应用时候由JVM初始化加载 2、通过Class.forName()方法动态加载 3、通过ClassLoader.loadClass()方法动态加载 Class.forName()和ClassLoader.loadClass()区别 Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块； ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。 Class.forName(name,initialize,loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。 双亲委派模型双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 双亲委派机制: 1、当 AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。 2、当 ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader`去完成。 3、如果 BootStrapClassLoader加载失败（例如在 $JAVA_HOME/jre/lib里未查找到该class），会使用 ExtClassLoader来尝试加载； 4、若ExtClassLoader也加载失败，则会使用 AppClassLoader来加载，如果 AppClassLoader也加载失败，则会报出异常 ClassNotFoundException。 ClassLoader源码分析： 双亲委派模型意义： 系统类防止内存中出现多份同样的字节码 保证Java程序安全稳定运行]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程(二)]]></title>
    <url>%2F2019%2F05%2F26%2F%E5%B9%B6%E5%8F%91%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C)%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[多线程(二)线程同步java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。 1、同步方法 即有synchronized关键字修饰的方法。由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。 public synchronized void save(){} 注： synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类 2、同步代码块 即有synchronized关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。 12345678910111213141516171819202122232425public class Bank &#123; private int count = 0;//账户余额 //存钱 public void addMoney(int money)&#123; synchronized (this) &#123; count +=money; &#125; System.out.println(System.currentTimeMillis()+"存进："+money); &#125; //取钱 public void subMoney(int money)&#123; synchronized (this) &#123; if(count-money &lt; 0)&#123; System.out.println("余额不足"); return; &#125; count -= money; &#125; System.out.println(+System.currentTimeMillis()+"取出："+money); &#125; //查询 public void lookMoney()&#123; System.out.println("账户余额："+count); &#125; &#125; 同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。 3、使用特殊域变量（volatile）实现线程同步 volatile关键字为域变量的访问提供了一种免锁机制 使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新 每次使用该域就要重新计算，而不是使用寄存器中的值； volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class SynchronizedThread &#123; class Bank &#123; private volatile int account = 100; public int getAccount() &#123; return account; &#125; /** * 用同步方法实现 * * @param money */ public synchronized void save(int money) &#123; account += money; &#125; /** * 用同步代码块实现 * * @param money */ public void save1(int money) &#123; synchronized (this) &#123; account += money; &#125; &#125; &#125; class NewThread implements Runnable &#123; private Bank bank; public NewThread(Bank bank) &#123; this.bank = bank; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; // bank.save1(10); bank.save(10); System.out.println(i + "账户余额为：" +bank.getAccount()); &#125; &#125; &#125; /** * 建立线程，调用内部类 */ public void useThread() &#123; Bank bank = new Bank(); NewThread new_thread = new NewThread(bank); System.out.println("线程1"); Thread thread1 = new Thread(new_thread); thread1.start(); System.out.println("线程2"); Thread thread2 = new Thread(new_thread); thread2.start(); &#125; public static void main(String[] args) &#123; SynchronizedThread st = new SynchronizedThread(); st.useThread(); &#125;&#125; 多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。用final域，有锁保护的域和volatile域可以避免非同步的问题。 4、使用重入锁(Lock)实现线程同步 在javaSE5.0中新增了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和块具有相同的基本行为和语义，并且扩展了其能力。ReenreantLock类的常用方法有： 123ReentrantLock() : 创建一个ReentrantLock实例 lock() : 获得锁 unlock() : 释放锁 ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用 123456789101112131415161718//只给出要修改的代码，其余代码与上同 class Bank &#123; private int account = 100; //需要声明这个锁 private Lock lock = new ReentrantLock(); public int getAccount() &#123; return account; &#125; //这里不再需要synchronized public void save(int money) &#123; lock.lock(); try&#123; account += money; &#125;finally&#123; lock.unlock(); &#125; &#125; ｝ 线程通信1、借助于Object类的wait()、notify()和notifyAll()实现通信 线程执行wait()后，就放弃了运行资格，处于冻结状态； ​ 线程运行时，内存中会建立一个线程池，冻结状态的线程都存在于线程池中，notify()执行时唤醒的也是线程池中的线程，线程池中有多个线程时唤醒第一个被冻结的线程。notifyAll(), 唤醒线程池中所有线程。注： （1） wait(), notify(),notifyAll()都用在同步里面，因为这3个函数是对持有锁的线程进行操作，而只有同步才有锁，所以要使用在同步中；​ （2） wait(),notify(),notifyAll(), 在使用时必须标识它们所操作的线程持有的锁，因为等待和唤醒必须是同一锁下的线程；而锁可以是任意对象，所以这3个方法都是Object类中的方法。 单个消费者生产者例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Resource&#123; //生产者和消费者都要操作的资源 private String name; private int count=1; private boolean flag=false; public synchronized void set(String name)&#123; if(flag) try&#123;wait();&#125;catch(Exception e)&#123;&#125; this.name=name+"---"+count++; System.out.println(Thread.currentThread().getName()+"...生产者..."+this.name); flag=true; this.notify(); &#125; public synchronized void out()&#123; if(!flag) try&#123;wait();&#125;catch(Exception e)&#123;&#125; System.out.println(Thread.currentThread().getName()+"...消费者..."+this.name); flag=false; this.notify(); &#125; &#125; class Producer implements Runnable&#123; private Resource res; Producer(Resource res)&#123; this.res=res; &#125; public void run()&#123; while(true)&#123; res.set("商品"); &#125; &#125; &#125; class Consumer implements Runnable&#123; private Resource res; Consumer(Resource res)&#123; this.res=res; &#125; public void run()&#123; while(true)&#123; res.out(); &#125; &#125; &#125; public class ProducerConsumerDemo&#123; public static void main(String[] args)&#123; Resource r=new Resource(); Producer pro=new Producer(r); Consumer con=new Consumer(r); Thread t1=new Thread(pro); Thread t2=new Thread(con); t1.start(); t2.start(); &#125; &#125;//运行结果正常，生产者生产一个商品，紧接着消费者消费一个商品。 ​ 但是如果有多个生产者和多个消费者，上面的代码就会有问题，比如2个生产者，2个消费者，运行结果就可能出现生产的1个商品生产了一次而被消费了2次，或者连续生产2个商品而只有1个被消费，这是因为此时共有4个线程在操作Resource对象r, 而notify()唤醒的是线程池中第1个wait()的线程，所以生产者执行notify()时，唤醒的线程有可能是另1个生产者线程，这个生产者线程从wait()中醒来后不会再判断flag，而是直接向下运行打印出一个新的商品，这样就出现了连续生产2个商品。 1234567891011121314151617181920212223242526272829303132333435class Resource&#123; private String name; private int count=1; private boolean flag=false; public synchronized void set(String name)&#123; while(flag) /*原先是if,现在改成while，这样生产者线程从冻结状态醒来时，还会再判断flag.*/ try&#123;wait();&#125;catch(Exception e)&#123;&#125; this.name=name+"---"+count++; System.out.println(Thread.currentThread().getName()+"...生产者..."+this.name); flag=true; this.notifyAll();/*原先是notity(), 现在改成notifyAll(),这样生产者线程生产完一个商品后可以将等待中的消费者线程唤醒，否则只将上面改成while后，可能出现所有生产者和消费者都在wait()的情况。*/ &#125; public synchronized void out()&#123; while(!flag) /*原先是if,现在改成while，这样消费者线程从冻结状态醒来时，还会再判断flag.*/ try&#123;wait();&#125;catch(Exception e)&#123;&#125; System.out.println(Thread.currentThread().getName()+"...消费者..."+this.name); flag=false; this.notifyAll(); /*原先是notity(), 现在改成notifyAll(),这样消费者线程消费完一个商品后可以将等待中的生产者线程唤醒，否则只将上面改成while后，可能出现所有生产者和消费者都在wait()的情况。*/ &#125; &#125; public class ProducerConsumerDemo&#123; public static void main(String[] args)&#123; Resource r=new Resource(); Producer pro=new Producer(r); Consumer con=new Consumer(r); Thread t1=new Thread(pro); Thread t2=new Thread(con); Thread t3=new Thread(pro); Thread t4=new Thread(con); t1.start(); t2.start(); t3.start(); t4.start(); &#125; &#125; 2、使用Condition控制线程通信 ​]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FRedis%2FRedis%2F</url>
    <content type="text"><![CDATA[RedisNoSQLNoSQL = not only SQL 非关系型数据库 为什么需要NoSQL High Performance - 高并发读写 Huge Storage - 海量数据的高效率存储和访问 HIgh Scalability&amp;&amp;High Availability - 高可扩展性和高可用性 NoSQL数据库的四大分类 键值对(key-value)存储 列存储 文档数据库 图形数据库 NoSQL的特点： 易扩展 灵活的数据模型 大数据量 高可用 Redis支持的键值数据类型： 字符串类型 散列类型 列表类型 集合类型 有序集合类型 读每秒11万次，写每秒8万次 Redis应用场景： 缓存 任务队列 应用排行榜 网站访问统计 数据过期处理 分布式集群架构中的session分离 JedisJedis是Redis官方首选的java客户端开发包 Redis的数据结构 字符串（String） 哈希（hash） 字符串列表（list） 字符串集合（set） 有序字符串集合（sorted set） Redis持久化需要持久化的原因：Redis将数据存在内存中，容易丢失数据，需要将数据存进硬盘，称为持久化 两种持久化的方式 RDB方式 AOF方式 持久化的四种方式： RDB方式：默认支持、不需要进行配置，在指定的时间间隔内，将内存中的数据集快照写入硬盘 AOF方式：以日记的方式记录服务器处理的每一个操作，当重启时，会读取文件进行重建数据库，保证启动时数据库中的数据的完整 无持久化：通过日志禁止数据库持久化的功能 同时使用RDB方式和AOF方式]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库之基础知识]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[数据库之基础知识命令行操作MySQLDOS命令 盘符+冒号 切换逻辑盘 如：d:dir 显示目录和文件列表cd 目录名 进入目录cd ../ 进入上一级目录cd ./ 进入当前目录cd / 进入根目录exit 退出命令行 连接数据库 语法：mysql -h主机名 -u用户名 -p密码如：mysql -hlocalhost -uroot -proot注意：当提示符变成 mysql&gt; 说明我们已经进入mysql命令行模式，只能使用sql指令sql指令都需要以分号 ; 结束quit 退出mysql exit 退出命令行 数据库操作创建数据库 1create database 数据库名 显示数据库 12345678show database；显示服务器上的所有的数据库列表破show database like '%a%'; like 子命令，显示所有名字里带a的数据库名show databases like '___'; like 子命令，显示数据库名是三个字符的所有数据库名% 匹配0个或者多个任意字符_ 下划线，匹配任意一个字符show create database 数据库名; 查看建立数据库的语句 修改数据库 1alter database 数据库名 charset=gbk; 修改指定的数据库的字符集，只能修改数据的字符集，数据库名不能修改。 删除数据库 1drop database 数据库名; 删除指定的数据库 MySQL里面的三个数据库mysql、information_schema、performance_schema是系统默认自带的，不可删除，删了需重装MySQL 数据库操作创建数据表 1create table 表名(id int,username varchar(30),password varchar(30)); 查看表 123show tables; 查看所有的数据表show create table 表名; 查看数据表的建表语句desc 表名; 查看数据表的结构 删除表 1drop table 表名; 查看数据表的结构 修改表 123alter table 表名 engine=innodb; 可以修改默认引擎alter table 表名 charset=gbk; 可以修改字符集rename table 表名 to 另一个表名; 可以修改表名 字段操作增加新字段 12alter table student add column gender varchar(2);在student数据表中新增gender字段 修改字段的类型和属性 123456alter table student modify column gender varchar(10);修改student数据表中gender字段数据类型alter table student modify column gender varchar(10) after 另一个字段;修改student数据表中gender字段数据类型，并且在数据表中排在 “另一个字段” 后面alter table student modify column gender varchar(10) first;修改student数据表中gender字段数据类型，并且在数据表中排在第一位 修改字段的名字和定义 12alter table student change column gender sex varchar(2);把student数据表中gender字段名字改为sex，数据类型改为varchar(2); 删除字段 12alter table student drop column gender;删除student数据表中的gender字段; 记录操作新增记录 12345678insert into 表名(字段列表) values (值的列表);例子：insert into student(username) values('中文');insert into student(id,username,age) values(3,'中文',20);批量新增：insert into student(id,username,age) values (3,'张三',18),(4,'李四',20),(5,'刘五',22);值的个数与数据表中的字段个数一样时，可以省略字段列表insert into student values(4,'中文',20); 查询记录 完整语句：select [字段列表] [from子句] [inner join子句] [where子句] [group by子句] [having子句] [order by子句] [limit子句]; 一般使用： select [字段列表] [from子句] [where子句] [order by子句] [limit子句]; [where子句] 用于过滤数据，只取出满足条件的记录 1select * from student where age &gt;= 20; 查询出 age &gt;= 20的记录 [order by子句] 用于对查询出的数据进行排序 1select * from student where age &gt;= 20 order by age asc; 年龄升序排列 asc升序排列 （从小到大）、desc 降序排序 （从大到小） [limit子句] 用于限制输出数据的条数 123limit n; 提取前 n 条数据limit m,n; 从 第 m 条开始提取 n 条数据**（m 从 0 开始）**select * from student where age &gt;= 20 order by age asc limit 2; 查询出 age &gt;= 20的记录年龄，升序排列，提取前 2 条 修改记录 123update 表名 set 字段名1=新的值1,字段名2=新的值2,字段名n=新的值n where 子句;例子：update student set age=25 where id=8; 删除记录 123delete from 表名 where 子句;例子：delete from student where id=8; mysql中常用数据类型 数据类型 描述 INT(size) 4字节整数类型，-2147483648 到 2147483647 常规。0 到 4294967295 无符号*。在括号中规定最大位数，默认是11。 BIGINT(size) 8字节整数类型，-9223372036854775808 到 9223372036854775807 常规。0 到 18446744073709551615 无符号*。在括号中规定最大位数。默认是20。 FLOAT(size,d) 字节浮点数，带有浮动小数点的小数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。 CHAR(size) 保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。 VARCHAR(size) 保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。注释：如果值的长度大于 255，则被转换为 TEXT 类型。 TEXT 存放最大长度为 65,535 个字符的字符串。 DATE() 日期。格式：YYYY-MM-DD 注释：支持的范围是从 ‘1000-01-01’ 到 ‘9999-12-31’ DATETIME() *日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS 注释：支持的范围是从 ‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’ TIMESTAMP() *时间戳。TIMESTAMP 值使用 Unix 纪元(‘1970-01-01 00:00:00’ UTC) 至今的描述来存储。格式：YYYY-MM-DD HH:MM:SS 注释：支持的范围是从 ‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-09 03:14:07’ UTC]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库之事务和锁机制]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81%E6%9C%BA%E5%88%B6%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[数据库之事务和锁机制 事务四大特性事务的概念：事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元，要么全部执行，要么全部不执行。 1、原子性（Atomicity） 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，如果操作失败则不能对数据库有任何影响，任何一项操作都会导致整个事务的失败，同时其它已经被执行的操作都将被撤销并回滚，只有所有的操作全部成功，整个事务才算是成功完成。 2、一致性（Consistency） 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。 3、隔离性（lsolation） 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。 4、持久性（durability） 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。 事务并发引起的问题1、脏读（dirty read） 当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。 例如：用户A向用户B转账100元 1234update account set money=money+100 where name=’B’; (此时A通知B)update account set money=money - 100 where name=’A’;以上两条sql语句为转账事务 转账是一个事务，通知查看是一个事务。 当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读） 而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚 那么当B以后再次查看账户时就会发现钱其实并没有转。 脏读就是一个事务读取了另一个事务未提交的脏数据 2、不可重复读（unrepeatable reading） 不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。 例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。 不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。 在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就产生矛盾。 3、幻读（Phantom read） 幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。 事务的四种隔离级别 Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。 Repeatable read (可重复读)：可避免脏读、不可重复读的发生。 Read committed (读已提交)：可避免脏读的发生。 Read uncommitted (读未提交)：最低级别，任何情况都无法保证。 以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别。级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。 隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效。 对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。 ###]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F2%20%E7%BA%BF%E6%80%A7%E8%A1%A8%2F%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[线性表线性表是具有相同数据类型的n(n&gt;=0)个数据元素的有限序列 线性表的顺序存储是用一组地址连续的存储单元，依次存储线性表中的数据元素，顺序存储的线性表也叫顺序表 静态建表： 存储空间的起始位置 顺序表最大存储容量 顺序表当前的长度 数组是静态分配的（大小固定） 其实存储空间（数组）还可以动态分配，也就是存储数组的空间是在程序执行过程中通过动态分配语句来分配的 1234567891011typedef int Elemtype;typedef struct&#123; ElemType *data;//指示动态分配数组的指针 int MaxSize,length;//数组的最大容量和当前个数&#125;SeqList;动态分配语句#define InitSize 100SeqList L;L.data=(ElemType*)malloc(sezeof(ElemType)*InitSize); 动态分配并不是链式存储，同样还是属于顺序存储结构，只是分配的空间大小可以在运行时决定 顺序表的操作插入12345678910111213在顺序表L的第i（1&lt;=i&lt;=L.length）个位置插入新元素e。如果i的输入不合法，则返回false,表示插入失败；否则，将顺序表的第i个元素以及其后的所有元素右移一个位置，腾出一个空位置插入新元素e，顺序表长度增加1，插入成功，返回truebool ListInsert(SqlList &amp;L,int i,ElemType e)&#123; if(i&lt;1||i&gt;L.length+1)//判断i的范围是否有效 return false; if(L.length&gt;=MaxSize)//当前的存储空间已满，不能插入 return false; for(int j=L.length;j&gt;=i;j--)//将第i个元素及之后的元素后移 L.data[j]=L.data[j-1]; L.data[i-1]=e; L.lengt++; return true;&#125; 删除1234567891011删除顺序表L中第i（1&lt;=i&lt;=L.length）个位置的元素，成功则返回true，并将被删除的元素用应用变量e返回；否则返回falsebool ListDelete(SqList &amp;L,int i,ElemType &amp;e)&#123; if(i&lt;1||i&gt;L.length+1)//判断i的范围是否有效 return false; e=L.data[i-1]; for(int j=i;j&lt;L.length;j++) L.data[j-1]=L.data[j]; L.length--; return true;&#125; 优点： 存储密度大，不需要为表中元素之间的逻辑关系增加额外存储空间 随机存取：可以快速存取表中任一位置的元素 缺点： 插入和删除需要移动大量元素 对存储空间要求高，会产生存储空间的碎片 链式存储 线性表的链式存储是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立起数据元素之间的线性关系，每个链表结点，除了存放元素自身的信息之外，还需要存放一个指向其后继的指针。 1234typedef struct LNode&#123; ElemType data;//数据域 struct LNode *next;//指针域&#125;LNode,*LinkList; 通常用“头指针”来标识一个单链表，例如LinkList L，那么头指针L代表一个单链表 单链表第一个结点之前附加一个结点，称为头结点，头结点的数据域可以不设任何信息，也可以记录表长等相关信息。头结点的指针域指向线性表的第一个元素结点。 单链表操作头插法建立单链表建立新的结点分配内存空间，将新结点插入当前链表的表头 12345678910111213141516//默认有空的头结点LinkList CreatList1(LinkList &amp;L)&#123; LNode *s; int x;//存储插入结点的数据的值 L=(LinkList)malloc(sizeof(LNode));//创建头结点 L-&gt;next=NULL;//初始化为空链表 scanf("%d",&amp;x);//输入结点的值 while(x!=9999)&#123;//输入9999表示结束 s=(LNode*)malloc(sizeif(LNode));//创建新结点 s-&gt;data=x;//对新结点的数据域赋值 s-&gt;next=L-&gt;next;//新结点的后继指向第一个结点 L-&gt;next=s;//头结点的后继指向新结点 sanf("%d",&amp;x); &#125; return L;&#125; 尾插法建立单链表建立新的结点分配内存空间，将新的结点插入到当前链表的表尾 123456789101112131415LinkList CreatList2(LinkList &amp;L)&#123; int x;//存储插入结点的数据的值 L=(LinkList)malloc(sizeof(LNode));//创建头结点 LNode *s,*r=L;//r为表尾指针，指向表尾 scanf("%d",&amp;x);//输入结点的值 while(x!=9999)&#123;//输入9999表示结束 s=(LNode*)malloc(sizeif(LNode));//创建新结点 s-&gt;data=x;//对新结点的数据域赋值 r-&gt;next=s; r=s; sanf("%d",&amp;x); &#125; r-&gt;next=NULL; return L;&#125; 按序号查找结点在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL 1234567891011LNode *GEtElem(LinkList L,int i)&#123; int j=1;//计数，初始为1 LNode *p=L-&gt;next;//第一个结点指针赋给p if(i==0) return L;//若i等于0，返回头结点 if(i&lt;1) return NULL; while(p&amp;&amp;j&lt;i)&#123;//从第一个结点开始找，查找第i个结点 p=p-&gt;next; j++; &#125; return p;&#125; 按值查找结点 1234567LNode *Locate(LinkList L,ElemType e)&#123; LNode *p=L-&gt;next; while(p!=NULL&amp;&amp;p-&gt;data!=e)&#123;//从第一个结点开始找 p=p-&gt;next; &#125; return p;&#125; 插入新结点插入操作是将值为x的新结点插入到单链表的第i个位置上。先检查插入位置和合法性，然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点 算法思路： 取指向插入位置的前驱结点的指针p=GetElem(L,i-1); 取新结点s的指针域指向 p的后继结点s-&gt;next=p-&gt;next 令结点p的指针域指向新插入的结点 s p-&gt;next=s; 删除一个结点删除操作是将单链表的第i个结点删除，先检查删除位置的合法性，然后查找表中第i-1个结点，即被删除结点的前驱结点，再将其删除 算法思路： 取指向删除位置的前驱结点的指针 p=GetElem(L,i-1); 取指向删除位置的指针 q=p-&gt;next; p指向结点的后继指向被删除结点的后继 p-&gt;next=q-&gt;next 双链表123456789typedef struct LNode&#123; ElemType data; structLNode *node;&#125;LNode,*LinkList;typedef struct DNode&#123; ElemType data; struct DNode *prior,*next;//前驱和后继指针&#125;DNode,*DLinkList; 插入 s-&gt;next=p-&gt;next p-next-&gt;prior=s s-&gt;prior=p p-&gt;next=s 删除 p-&gt;next=q-&gt;next q-&gt;next-&gt;prior=p free(q) 循环链表&amp;静态链表循环单链表：循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环 循环单链表的判空条件不是头结点的后继指针是否为空，而是它是否等于头指针 循环双链表 静态链表 使用数组来描述线性表的链式存储结构 123456#define MaxSize 50//静态链表的最大长度typedef int ElemType//静态链表的数据类型假定为inttypedef struct&#123; ElemType data;//数据域，存储数据元素 int next;//指针域，下一个元素的数组下标&#125;SLinkList[MaxSize]; 数组第一个元素不存储数据，它的指针域存储第一个元素所在的数组下标。 链表最后一个元素的指针域值为-1]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法复杂度]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F1%20%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%2F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[算法复杂度算法是对问题求解步骤的描述，通过有限序列的指令来实现 五大特征 有穷性：有限步之后结束 确定性：不存在二义性 可行性 输入 输出 时间复杂度用来衡量算法随着问题规模增大，算法执行时间的增大的快慢 时间复杂度是问题规模的函数：T(n) T(n)=O(f(n))，大O记法 计算方法： 算法时间增长最快的那个函数项，把它的系数改为1 空间复杂度 用来衡量算法随问题规模增大，算法所需空间的增长的快慢 是问题规模的函数：S(n)=O(g(n)) 常见的时间复杂度大小关系 O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n2)&lt;O(n3)&lt;O(2n)]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库之索引]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E7%B4%A2%E5%BC%95%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[数据库之索引创建索引在创建表的时候添加索引 12345CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) ); 在创建表以后添加索引 123ALTER TABLE my_table ADD [UNIQUE] INDEX index_name(column_name);或者CREATE INDEX index_name ON my_table(column_name); 注意： 1、索引需要占用磁盘空间，因此在创建索引时要考虑到磁盘空间是否足够 2、创建索引时需要对表加锁，因此实际操作中需要在业务空闲期间进行 根据索引进行查询1234567891011121314151617181920212223具体查询：SELECT * FROM table_name WHERE column_1=column_2;(为column_1建立了索引)或者模糊查询SELECT * FROM table_name WHERE column_1 LIKE '%三'SELECT * FROM table_name WHERE column_1 LIKE '三%'SELECT * FROM table_name WHERE column_1 LIKE '%三%' SELECT * FROM table_name WHERE column_1 LIKE '_好_' 如果要表示在字符串中既有A又有B，那么查询语句为：SELECT * FROM table_name WHERE column_1 LIKE '%A%' AND column_1 LIKE '%B%'; SELECT * FROM table_name WHERE column_1 LIKE '[张李王]三'; //表示column_1中有匹配张三、李三、王三的都可以SELECT * FROM table_name WHERE column_1 LIKE '[^张李王]三'; //表示column_1中有匹配除了张三、李三、王三的其他三都可以//在模糊查询中，%表示任意0个或多个字符；_表示任意单个字符（有且仅有），通常用来限制字符串长度;[]表示其中的某一个字符；[^]表示除了其中的字符的所有字符 或者在全文索引中模糊查询SELECT * FROM table_name WHERE MATCH(content) AGAINST('word1','word2',...); 删除索引 123DROP INDEX my_index ON tablename；或者ALTER TABLE table_name DROP INDEX index_name; 查看表中的索引 1SHOW INDEX FROM tablename 查看查询语句查询索引的情况 12//explain 加查询语句explain SELECT * FROM table_name WHERE column_1='123'; 索引的优缺点优点： 可以快速检索，加快检索速度 根据索引分组和排序，可以加快分组和排序 缺点： 索引本身也是表，会占据存储空间 索引表的创建和维护需要时间，随数据量增大而增大 降低数据表的修改操作（删除、添加、修改）的效率，因为在修改数据表的同时也要修改索引表 索引的分类常见的索引类型有：主键索引、唯一索引、普通索引、全文索引、组合索引 1、主键索引：即主索引，根据主键pk_clolum（length）建立索引，不允许重复，不允许空值； 1ALTER TABLE 'table_name' ADD PRIMARY KEY pk_index('col')； 2、唯一索引：用来建立索引的列的值必须是唯一的，允许空值 1ALTER TABLE 'table_name' ADD UNIQUE index_name('col')； 3、普通索引：用表中的普通列构建的索引，没有任何限制 1ALTER TABLE 'table_name' ADD INDEX index_name('col')； 4、全文索引：用大文本对象的列构建的索引 1ALTER TABLE 'table_name' ADD FULLTEXT INDEX ft_index('col')； 5、组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值 1ALTER TABLE 'table_name' ADD INDEX index_name('col1','col2','col3')； 遵循“最左前缀”原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引相当于建立了col1,col1col2,col1col2col3三个索引，而col2或者col3是不能使用索引的。 在使用组合索引的时候可能因为列名长度过长而导致索引的key太大，导致效率降低，在允许的情况下，可以只取col1和col2的前几个字符作为索引 1ALTER TABLE 'table_name' ADD INDEX index_name(col1(4),col2（3))； 表示使用col1的前4个字符和col2的前3个字符作为索引。 索引的选取类型1、越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快 2、简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂 3、尽量避免NULL：应该指定列为NOT nuLL,在MySQL中， 含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂 什么场景不适合创建索引1、很少使用查询或者只是作为参考的列，因为这些列很少用到，添加索引只会增加开销和维护成本 2、很少数据集的列也不应该加索引，例如班级的同学的性别，只有男或女，利用索引相当于全表搜索，没意义 3、当修改性能远远大于检索性能时，因为修改性能和检索性能互相矛盾 4、不会出现在where条件中的字段不该建立索引 什么的字段适合索引1、表的主键和外键必须有索引，外键唯一，且经常查询 2、数据量比较多的超过300需要索引 3、经常需要和其他表进行连接查询的字段应该建立索引 4、经常出现在where子句中的字段，加快判断速度 5、经常用到排序的列上，因为索引已经排序 6、经常用在范围内搜索的列上创建索引，因为索引已经排序，指定范围是连续（B+树） MySQL索引的底层原理索引是帮助MySQL高效获取数据的数据结构 上图展示的是一种可能的索引方式 左边是数据表，一共有两列14条记录，最左边是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上并不一定物理相邻），但实际数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现 目前大部分数据库系统及文件系统都采用B Tree或其变种B+Tree作为索引结构，MySQL普遍使用B+树实现索引 在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的 MyISAM和InnoDB对索引和数据的存储在磁盘上是如何体现的 role表使用的存储引擎是MyISAM，而user使用的是InnoDB： role表有三个文件，对应如下： role.frm：表结构文件 role.MYD：数据文件（MyISAM Data） role.MYI：索引文件（MyISAM Index） user表有两个文件，对应如下： user.frm：表结构文件 user.ibd：索引和数据文件（InnoDB Data） 由于两种引擎对索引和数据的存储方式的不同，我们也称MyISAM的索引为非聚集索引，InnoDB的索引为聚集索引。 MyISAM索引实现 MyISAM引擎使用B+Tree作为索引结构，叶节点data域存放数据记录的地址 设Col1为主键，上图是一个MyISAM表的主索引（Primary key）示例。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅索引的key可以重复（为什么没有区别，是因为SQL语句中where子句可以使用的是其他字段来作为条件，如clo2&gt;…之类的语句，所以主索引和辅助索引在MyISAM没有区别）如果我们在Col2上建立一个辅索引，则此索引的结构如下图所示： MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分 InnoDB索引实现 MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址 而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引 与MyISAM的区别两点： 一、因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有） 如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键 如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形 二、InnoDB的辅索引data域存储相应记录主键的值而不是地址。 InnoDB的所有辅助索引都引用主键作为data域 索引存在但未使用情况（索引失效、索引优化）1CREATE INDEX idx_test_a1234 ON test(a1,a2,a3,a4);//创建联合索引来说明索引失效的一下情况 1.字符串为使用引号，导致索引失效（不能在索引列上干任何操作(计算,函数,类型转换) ） 123select * from test where a1 = a1;//可以查到数据，数据库自动转换类型，但索引失效select * from test where a1 = 'a1'; 2、索引最左原则使用不当，导致索引失效（where子句后面的顺序无关，只要用到就可以） 12345678910111213141516171819select * from test where a1 = 'a1' and a2 = 'a2' and a3 = 'a3' and a4 = 'a4';select * from test where a4= 'a4' and a3 = 'a3' and a2 = 'a2' and a1= 'a1';以上两个查询中，where条件中的索引位置是相反的，但是执行结果是一致的，这个是由mysql优化器来处理的，因为两个查询中都出现了联合索引a1,a2，a3,a4，MySQL优化器底层会进行优化处理。select * from test where a1 = 'a1' and a3 = 'a3' and a4 = 'a4';select * from test where a4= 'a4' and a3 = 'a3' and a1= 'a1';以上两个查询只用到一个索引a1select * from test where a1 = 'a1' and a2 = 'a2' and a4 = 'a4';select * from test where a4= 'a4' and a2 = 'a2' and a1= 'a1';以上两个查询用到两个索引select * from test where a2 = 'a2' and a3 = 'a3' and a4 = 'a4';select * from test where a4= 'a4' and a3 = 'a3' and a2 = 'a2'以上两个查询未使用索引 3、范围查找导致索引失效（存储引擎不能使用索引中范围条件右边的列） 123456select * from test where a1 = &apos;a1&apos; and a2 = &apos;a2&apos; and a3 &gt;&apos;a3&apos; and a4 = &apos;a4&apos;;以上用到a1、a2、a3，3个索引，因为a3右边是a4，导致a4的索引不可用select * from test where a1 = &apos;a1&apos; and a2 = &apos;a2&apos; and a4 &gt;&apos;a4&apos; and a3= &apos;a3&apos;;以上用到a1、a2、a3、a4，4个索引，因为a4后面已经没有索引了，不影响 4、order by使用不当，导致索引失效 12345select * from test where a1 = 'a1' and a2 = 'a2' and a4 = 'a4' order by a3explain语句显示两个索引，严格来说以上用到两个索引查询，三个索引排序因为查找的where条件中跳过了a3,违背了索引的最左原则，导致索引a4失效严格意义上来说，以上查询使用了3个索引，a3并未用于查找，但是在排序中使用到了，只是为统计到explain中，即满足索引的两大功能：查找和排序 以下排序中，索引使用不当，导致产生了文件内排序，影响性能 a2之后a3断开，导致a4索引失效，mysql 为了将结果展现出来，进行了内部排序 1select * from test where a1 ='a1' and a2 = 'a2' order by a4; 123456789101112select * from test where a1 ='a1' and a5 = 'a5' order by a2,a3;使用到a1一个索引select * from test where a1 ='a1' and a5= 'a5' order by a3,a2;使用到a1索引，并且产生文件内排序select * from test where a1 ='a1' and a2 = 'a2' order by a2,a3;使用到a1、a2两个索引，没有产生文件内排序原文：https://blog.csdn.net/weixin_39539399/article/details/80842750 5、group by使用不当导致索引失效 123select * from test where a1 ='a1'and a4 = 'a4' group by a2，a3;select * from test where a1 ='a1'and a4 = 'a4' group by a3，a2; 分组之前必排序，group by 表面上是分组，但是对索引的使用和order by 的使用大致相同，所以group by后面如果索引错乱，会产生临时表，导致mysql内部进行排序 6、通配符like的使用不当导致索引失效（like以通配符开头(“%abc…”) ） 1234567891011select * from test where a1 like '%a';索引失效select * from test where a1 like 'a%';索引不失效select a1 from test where a1 like '%a';覆盖索引，解决最左匹配不当的索引失效问题select * from test where a1 like 'c%';索引失效select * from test where a1 like '%c';索引失效select * from test where a1 like 'abc%';索引不失效 6、MYSQL 中!=,&lt;&gt;导致索引失效（is null, is not null 也无法使用索引） 尽量使用覆盖索引(只访问索引的查询),减少select *，可以解决索引失效的以上问题 7、少用or,用它来连接时索引会失效 关于or导致的索引失效，是有存在这种情况的，即or的左右边的查询条件，有一个列没有加索引，那么另一个列的索引会失效。要想使得索引生效，需要保证or两边的列都有索引，且一个列是主键。 小总结 索引的底层原理其实没有我总结那么简单，水平有限，B+B-树随缘再总结]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树与二叉树]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F4%20%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%2F%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[树与二叉树一对多的树形结构 树的性质 树中的结点等于所有结点的度数加1 度为m的树中第i层上至多有mi-1个结点（i&gt;=1） 高度为h的m叉树至多有（mh-1)/(m-1)个结点 具有n个结点的m叉树的最小高度为取上整[logm(n(m-1)+1)] 解上一个方程的h即可 树的存储结构顺序存储结构双亲表示法：用一组连续的存储空间存储树的结点，同时在每个结点中，用一个变量存储该结点的双亲结点在数组中的位置 1234567891011typedef char ElemType;typedef struct TNode&#123; ElemType data;//结点数据 int parent;//该结点双亲在数组的下标&#125;TNode;//结点的数据类型#define MaxSize 100typedef struct&#123; TNode nodes[MaxSize];//结点数组 int n;//结点的数量&#125;Tree;//结点双亲表示结构 双亲表示法可以根据parent找到该结点的双亲结点，时间复杂度为O(1)。但如果找到某节点的孩子结点就需要遍历 链式存储结构孩子表示法：把每个结点的孩子结点排列起来存储成一个单链表。所以n个结点就有n个链表；如果时叶子结点，那这个结点的孩子单链表就是空的；然后n个单链表的头指针又存储在一个顺序表（数组）中。 需要设计两种结合结构类型： 孩子链表的结点 每个孩子链表的表头结点（存在数组中） 12345678910typedef char ElemType;typedef struct CNode&#123; int child;//该孩子在表头数组的下标 struct CNode *next;//指向该结点的下一个孩子结点&#125;CNode,*Child;//孩子结点数据结构typedef struct&#123; Elemtype data;//结点数据域 Child firstchild;//指向该结点的第一个孩子结点&#125;TNode//孩子结点的数据类型 12345#define MaxSize 100typedef struct&#123; TNode nodes[MaxSize];//结点数据域 int n;//树中结点个数&#125;Tree;//树的孩子表示结构 孩子兄弟表示法：要存储孩子结点和兄弟结点，就是设置两个指针，分别指向该结点的第一个孩子结点和该结点的兄弟结点。 12345typedef char ElemType;typedef struct CSNode&#123; ElemType data;//该结点的数据域 struct CSNode *firstchild,*rightsib//指向该结点的第一个孩子结点和该结点的右兄弟结点&#125;CSNode;//孩子兄弟结点数据类型 二叉树每个结点最多有两颗子树 左右子树有顺序 五种基本形态 特殊二叉树 二叉树性质 非空二叉树上叶子结点等于度为2的结点数加1 非空二叉树上第K层上至多有2k-1个结点（k&gt;=1） 高度为H的二叉树至多有2H-1个结点（H&gt;=1） 具有N个(N&gt;0)结点的完全二叉树的高度为上取整[log2(N+1)]或下取整[log2N]+1 二叉树的存储结构顺序存储结构二叉树的顺序存储结构就是用一组地址连续的存储单元依次自上而下，自左而右存储完全二叉树上的结点元素 链式存储结构二叉树每个结点最多两个孩子，所以设计二叉树的结点结构时考虑两个指针指向该结点的两个孩子 1234typedef struct BiTNode&#123; ElemType data;//数据域 struct BiTNode *lchild,*rchild;//指向该结点的左右孩子指针&#125;BiTNode,*BiTNode;//二叉树结点结构 二叉树遍历(递归)二叉树的遍历是指按某种次序依次访问树中的每个结点，使得每个结点均被访问一次，而且仅被访问一次 递归先序遍历操作过程： 访问根结点 先序遍历左子树 先序遍历右子树 1234567void PreOrder(BiTree T)&#123; if(T!=NULL)&#123; printf("%c",T-&gt;data)//根节点 PreOrder(T-&gt;lchild);//左子树 PreOrder(T-&gt;rchild);//右子树 &#125;&#125; 递归中序遍历操作过程： 中序遍历左子树 访问根节点 中序遍历右子树 1234567void InOrder(BiTree T)&#123; if(T!=NULL)&#123; InOrder(T-&gt;lchild); printf("%c",T-&gt;data); InOrder(T-&gt;rchild); &#125;&#125; 递归后序遍历操作过程： 后序遍历左子树 后序遍历右子树 访问根节点 1234567void PostOrder(BiTree T)&#123; if(T!=NULL)&#123; PostOrder(T-&gt;lchild); PostOrder(T-&gt;rchild); printf("%c",T-&gt;data); &#125;&#125; 二叉树遍历(非递归)非递归先序遍历123456789101112131415void PreOrderTraverse(BiTree b)&#123; InitStack(S); BitTree p=b;//工作指针p while(p || !IsEmpty(S))&#123; while(p)&#123; printf("%c",p-&gt;data);//先序先遍历结点 Push(S,p);//进栈保存 p=p-&gt;lchild; &#125; if(!IsEmpty(S))&#123; p=Pop(S); p=p-rchild; &#125; &#125;&#125; 非递归中序遍历12345678910111213void InOrderTraverse(BiTree b)&#123; InitStack(S); BitTree p=b;//工作指针p while(p || !IsEmpty(S))&#123; while(p)&#123; Push(S,p);//进栈保存 p=p-&gt;lchild; &#125; p=Pop(S); printf("%c",p-&gt;data); p=p-rchild; &#125;&#125; 非递归后序遍历 层序遍历操作过程： 若树为空，则什么都不做直接返回； 否则从树的第一层开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问 出队-&gt;访问-&gt;左右孩子入队 12345678910111213void LevelOrder(BiTree b)&#123; InitQueue(Q); BiTree p; EnQueue(Q,b);//根节点入队 while(!IsEmpty(Q))&#123; DeQueue(Q,p);//队头元素出队 printf("%c",p-&gt;data); if(p-&gt;lchild!=NULL) EnQueue(Q,p-&gt;lchild); if(p-&gt;rchild!=NULL) EnQueue(Q,p-&gt;rchild); &#125;&#125; 线索二叉树二叉链表表示的二叉树存在大量空指针 N个结点的二叉树，每个结点都有指向左右孩子的结点指针，所以一共有2N个指针，而N个结点的二叉树一共有N-1个分支，也就是说存在2N-(N-1)=N+1个空指针。 指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树 对二叉树以某种次序遍历使其变为线索二叉树的过程叫做线索化。 如何区分指针是指向左孩子还是前驱，右孩子还是后继？ 在二叉链表结点的结构基础上增加两个标志位ltag和rtag 12345typedef struct ThreadNode&#123; ElemType data; struct ThreadNode *lchild,*rchild; int ltag,rtag;&#125;ThreadNode,*ThreadTree;//线索链表 ltag==0表示lchild指向该结点左孩子 ltag==1表示rchild指向该结点前驱 rtag==0表示rchild指向该结点右孩子 rtag==1表示指向该结点后继 构造线索二叉树 遍历线索二叉树 哈夫曼树和哈夫曼编码概念： 权：树中结点相关的数值 路径长度：从树中某个结点到另一个结点之间的分支数目（经过的边数） 带权路径长度：从树的根节点到任意结点的路径长度（经过的边数）与该结点上权值的乘积称为该结点的带权路径长度 哈夫曼树：含有N个带权叶子结点的二叉树中，带有带权路径长度（WPL）最小的二叉树，也成为最优二叉树。 设计哈夫曼树 将这N个结点分别作为N颗仅含一个结点的二叉树，构成森林F 构造一个新结点，并从F中选取两颗根节点权值最小的树作为新结点的左右子树，并且将新结点的权值置为左右子树上根节点的权值之和 从F中删除刚才选出的两棵树，同时将新得到的树加入F中 重复步骤2和3，直至F中只剩下一棵树为止 哈夫曼编码左子树为0，右子树为1 哈夫曼编码性质 哈夫曼编码是前缀编码 哈夫曼编码是最优前缀编码 二叉树、树和森林树转化成二叉树用到一个孩子兄弟表示法（回归本章树的链式存储） 二叉树转树 森林转二叉树 二叉树转森林 树和森林的遍历树的先序遍历 树的后序遍历 森林遍历]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈和队列]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F3%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[栈和队列栈只允许在一端进行插入或删除操作的线性表 栈顶：栈中允许进行插入和删除的哪一端 栈底：固定的，不允许进行插入和删除的另一端 12345#define MaxSize 50typedef struct&#123; Elemtype data[MaxSize];//存放栈中的元素 int top;//栈顶指针&#125;SqStack; top值不能超过MaxSize 空栈的判定条件通常定为top==-1，满栈的判定条件通常为top==MaxSize-1，栈中数据元素个数为top+1 顺序栈的操作判空1234bool StackEmpty(SqStack S)&#123; if(s.top==-1) return true; else return false;&#125; 进栈12345bool Push(SqStack &amp;S,ElemType x)&#123; if(S.top==MaxSize-1) return false; S.data[++S.top]=x; return true;&#125; 出栈12345bool Pop(SqStack &amp;S,ElemType &amp;x)&#123; if(S.top==-1) return false; x=S.data[S.top--]; return true;&#125; 获取栈顶元素12345bool GetTop(SqStack S,ElemType &amp;x)&#123; if(S.top==-1) return false; x=S.data[S.top]; return true;&#125; 共享栈 123456#define MaxSize 100typedef struct&#123; Elemtype data[MaxSize];//存放栈中的元素 int top1;//栈1栈顶指针 int top2;//栈2栈顶指针&#125;SqDoubleStack; 进栈1234567bool Push(SqDoubleStack &amp;S,ElemType x,int stackNum)&#123; if(S.top1+1==S.top2) return false;//栈满 if(stackNum==1) S.data[++S.top1]=x;//栈1有元素进栈 else if(stackNum==2) S.data[--S.top2]=x;//栈2有元素进栈 return true;&#125; 链式栈 123456789typedef struct SNode&#123; Elemtype data;//存放栈中的元素 struct SNode *next//栈顶指针&#125;SNode,*SLink//链栈结点 typedef struct LinkStack&#123; SLink top;//栈顶指针 int count;//链栈结点数&#125;LinkStack 链栈没有栈满的情况 链栈空为top==null 进栈12345678bool Push(LinkStack *S,ElemType x)&#123; SLink p=(SLink)malloc(sizeof(SNode));//给新元素分配空间 p-&gt;data=x;//新元素的值 p-next=S-&gt;top;//p的后继指向栈顶元素 S-&gt;top=p;//栈顶指针指向新的元素 S-&gt;count++;//栈中元素个数加1 return true;&#125; 出栈123456789bool Pop(LinkStack *S,ElemType &amp;x)&#123; if(S-&gt;top==NULL) return false; x=S-&gt;top-&gt;data;//栈顶元素值 SLink p=S-&gt;top;//辅助指针 S-&gt;top=S-&gt;top-&gt;next;//栈顶指针后移 free(p);//释放被删除数据的存储空间 S-&gt;count--;//栈中元素个数减一 return true;&#125; 栈的应用括号配对假设有两种括号，一种圆的()，一种方的[]，嵌套的顺序是任意的 算法思路： 若是左括号，入栈；若是右括号，出栈一个左括号判断是否与之匹配；检验到字符串尾，还要检查栈是否为空。只有栈空整个字符串才是括号匹配 12345678910111213141516171819202122bool Check(char *str)&#123; stack s; InitStack(s); int len = strlen(str);//字符串长度 for(int i=0;i&lt;len;i++)&#123; char a=str[i]; switch(a)&#123; case '('; case '['; Push(s,a); break; case ')'; if(Pop(s)!='(') return false;//出栈顶，如果不匹配直接返回不合法 break; case ']'; if(Pop(s)!=']')return false; break; &#125; &#125; if(Empty(s)) return true;//匹配完所有括号最后要求栈中为空 else return false;&#125; 表达式求值从左到右，先乘除后加减，右括号先算括号 后缀表达式做法： 规则：从左到右扫描表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈然后跟这个符号进行运算，最后将结果进栈，直到最终获得结果 如何将中缀表达式转换成后缀表达式（计算机也是用到栈取转换，下面是手动方法） 递归递归最重要的是递归式和递归边界 使用递归求解n的阶乘 1234int F(int n)&#123; if(n==0) return 1;//递归边界 else return n*F(n-1);//递归式&#125; 求斐波拉契数列的第n项 12345int Fib(int n)&#123; if(n==0) return 0; else if(n==1) return 1; else return Fib(n-1)+Fib(n-2);&#125; 队列队列是只允许在一端进行插入，而在另一端进行删除的线性表 队头（Front）：允许删除的一端，队首 队尾（Rear）：允许插入的一端 顺序队列用数组实现队列，可以将队首放在数组下标为0的位置 12345#define MaxSize 50typedef struct&#123; ElemType data[MaxSize];//存放队列的元素 int front,rear;//队头指针和队尾指针&#125; 循环队列入队：rear=(rear+1)%MaxSize 出队：front=(front+1)%MaxSize 判断队列是空是满 设置标志位flag，当flag=0且rear等于front时为队列空，当flag=1且rear等于front时为队列满（入队时flag等于1，出队时flag等于0） 把front==rear仅作为队空的判定条件。当队列满的时候，令数组中仍然保留一个空余单元。认为这种情况就是队列满了 队满关系 (rear+1)%MaxSize==front 队列中元素个数 (rear-front+MaxSize)%MaxSize 入队123456bool EnQueue(SqQueue &amp;Q,ElemType x)&#123; if((Q.rear+1)%MaxSize==Q.front) return flase;//队满 Q.data[Q.rear]=x; Q.rear=(Q.rear+1)%MaxSize; return true;&#125; 出队123456bool DeQueue(SqQueue &amp;Q,ElemType &amp;x)&#123; if(Q.rear==Q.front) return false;//队空，报错 x=Q.data[Q.front]; Q.front=(Q.front+1)%MaxSize; return true;&#125; 链式队列队列的链式存储结构，其实就是线性表的单链表，只不过需要加点限制，只能表尾插入元素，表头删除元素 分别设置队头指针和队尾指针，队头指针指向头结点，队尾指针指向队尾结点 12345678typedef struct&#123;//链式队列结点 ElemType data; struct LinkNode *next;&#125;LinkNode;typedef struct&#123;//链式队列 LinkNode *front,*rear;//队头和队尾指针&#125;LinkQueue; 入队1234567void EnQueue(LinkQueue &amp;Q,ElemType x)&#123; s=(LinkNode*)malloc(sizeof(LinkNode)); s-&gt;data=x; s-&gt;next=NULL; Q.rear-&gt;next=s; Q.rear=s;&#125; 出队出队就是头结点的后继结点出队，然后将头结点的后继改为它后面的结点 123456789bool DeQueue(LinkQueue &amp;Q,ElemType &amp;x)&#123; if(Q.front==Q.rear) return false;//空队 p=Q.front-&gt;next; x=p-&gt;data; Q.front-&gt;next=p-&gt;next; if(Q.rear==p) Q.rear=Q.front;//若原队列中只有一个结点，删除后变空 free(p); return true;&#125; 双端队列双端队列是指允许两端都可以进行入队和出队操作的队列 矩阵对于二维数组，两种映射方法：按行优先和按列优先 行优先 列优先 矩阵的压缩存储对称矩阵 三角矩阵 三对角矩阵 稀疏矩阵]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F6%20%E6%9F%A5%E6%89%BE%2F%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[查找查找：在数据集合中寻找满足某种条件的数据元素的过程 关键字：数据元素中某个可以唯一标识该元素的数据项 平均查找长度 顺序查找 折半查找 分块查找分块查找又称为索引顺序查找 二叉排序树 二叉排序树查找递归代码 二叉排序树查找非递归代码 二叉排序树插入关键字代码 时间复杂度 有n个结点就需要插入n个结点操作，插入一个的时间复杂度为O(log2n)，构造复杂度为O(nlog2n) 二叉排序树构造代码 二叉排序树删除结点 删除叶子结点 删除只有左子树或者右子树的结点 删除左右子树都有的结点 找到该结点的前驱和后继(即中序遍历的前驱和后继) 前驱替代结点 后继替代结点 二叉排序树分析 平衡二叉树(AVL树) 最小不平衡子树 不平衡二叉树类型 构建平衡二叉树过程 LL调整 RR调整 RL调整 平衡二叉树结点规律 B树和B+树2-3树： 2-3是一种多路查找树：2和3的意思就是2-3树包含两种结点 2-3-4树： B树 磁盘管理系统中的目录管理，以及数据库系统中的索引组织多数都采用B树数据结构 B树查找操作 B树插入操作 B树删除操作 删除的关键字在终端结点上(最底层非叶子结点) 第一种情况 第二种情况 第三中情况 删除关键字不在终端结点上(最底层非叶子结点) 第一种情况 第二种情况 B+树 B+树是B树的变形树，适合用于文件索引系统 散列表散列表基本概念 散列函数和冲突处理方法 常用Hash函数的构造方法 常用Hash函数的冲突处理方法 开放地址法 拉链法(链地址法) 散列表的查找过程和性能 散列表实例 ASL计算方式：查找成功ASL看关键字，查找失败ASL看地址个数 开放地址法(线性探测再散列法)计算ASL：https://blog.csdn.net/wangran51/article/details/8826633/ KMP算法KMP算法是用于解决字符串模式匹配的问题，字符串的模式匹配，是求一个字符串（模式串）在另一个字符串（主串）中的位置 BF(Brute-Force)算法 BF算法效率O(n*m) KMP算法 KMP算法next数组 next例子情况 当P[k] == P[j]时， 有next[j+1] == next[j] + 1 当P[k] != P[j] 像上边的例子，我们已经不可能找到[ A，B，A，B ]这个最长的后缀串了，但我们还是可能找到[ A，B ]、[ B ]这样的前缀串的。所以这个过程像不像在定位[ A，B，A，C ]这个串，当C和主串不一样了（也就是k位置不一样了），那当然是把指针移动到next[k]啦。 KMP算法代码 KMP算法效率 手动求解next数组的值]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F5%20%E5%9B%BE%2F%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[图基本概念图G由顶点集V和边集E组成，记为G=(V,E) 简单图和多重图简单图 不存在顶点到自身的边 同一条边不重复出现 多重图 若图G中某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联 完全图无向完全图：如果任意两个顶点之间都存在边 有向完全图：如果任意两个顶点之间都存在方向相反的两条弧 子图 连通图 强连通 连通图的生成树 度 权和网 基本概念总结 图的存储结构 邻接矩阵(顺序存储) 邻接表(链式存储) 十字链表(有向图) 邻接多重表(无向图) 邻接矩阵顶点：用一维数组来存储 边或弧：用二维数组来存储 二维数组就是一维数组的扩展，相当于一维数组中每个元素也是一维数组，二维数组也叫做邻接矩阵 无向图的邻接矩阵 有向图的邻接矩阵 邻接表对于稀疏图(E远小于V)，顺序存储结构存在预先分配内存可能浪费的问题 无向图邻接表 有向图邻接表 十字链表十字链表是针对有向图的存储方式，对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点 十字链表数据结构 邻接多重表 边表结构 图的遍历图的遍历：从图中某一个顶点出发遍历图中其余的顶点，且使每一个顶点仅访问一次，这个过程叫做图的遍历 图中顶点没有特殊性，可能存在沿着某条路径搜索后回到原起点，而有些顶点没有访问到。 解决办法：设置一个访问数组，记录遍历过程中访问过的顶点。 广度优先遍历(BFS) BFS算法实例 BFS空间复杂度 BFS需要借助一个队列，n个顶点均需要入队一次，所以最坏情况下n个顶点在队列，那么则需要O(|V|)的空间复杂度 BFS时间复杂度 邻接表：每个顶点入队一次，时间复杂度为O(|V|)，对于每个顶点，搜索它的邻接点，就需要访问这个顶点的所有边，所以时间复杂度为O(|E|)。所以总的时间复杂度为O(|V|+|E|)。 邻接矩阵：每个顶点入队一次，时间复杂度为O(|V|)，对于每个顶点，搜索它的邻接点，需要遍历一遍矩阵，所以时间复杂度为O(|V|)，所以总的时间复杂度为O(|V|2)。 BFS应用 BFS解决单源非带权图最短路径问题：按照距离由近到远来遍历图中每个顶点 广度优先生成树 深度优先遍历(DFS)深度优先遍历（DFS：Depth-First-Serch）：深度优先遍历类似于树的先序遍历算法 遍历过程：首先访问图中某一起始顶点v，然后由v出发，访问与v邻接且未被访问的任一顶点w1，再访问与w1邻接且未被访问的任一顶点w2，。。。。重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直到图中所有顶点均被访问过为止。 深度优先复杂度 空间复杂度： 由于DFS是一个递归算法，递归是一个需要工作栈来辅助工作，最多需要图中所有顶点进栈，所以空间复杂度为O(|V|) 时间复杂度： 邻接表：遍历过程的主要操作是对顶点遍历它的邻接点，由于通过访问边表来查找邻接点，所以时间复杂度为O(|E|)，访问访问顶点时间为O(|V|)，所以总的时间复杂度为O(|V|+|E|)。 邻接矩阵：查找每个顶点的邻接点时间复杂度为O(|V|)，对每个顶点都进行查找，所以总的时间复杂度O(|V|2)。 深度优先生成树 图的应用最小生成树(Prim、Kruskal)连通图的生成树，是一个极小的连通子图。包含图中全部的顶点，但只有足以构成一棵树的n-1条边 普里姆(Prim)算法 克鲁斯卡尔(Kruskal)算法 普里姆算法 初始化 i=1 i=2 i=3 i=4 i=5 i=6 Prim算法时间复杂度 克鲁斯卡尔算法(Kruskal) 并查集 算法思路 初始化，将边权值进行排序 第一次 第二次 第三次 第四次 第五次 第六次 第七次 4-6之后的边循环都不进行操作了，已经形成六条边(n-1)，形成最小生成树 克鲁斯卡尔算法复杂度 最短路径(Dijkstra、floyd) 迪杰斯特拉算法：一个源点到其余顶点的最短路径 弗洛伊德算法：所有顶点到所有顶点的最短路径 迪杰斯特拉算法思路： 迪杰斯特拉算法实例 第一次 第二次 第三次 第四次 第五次 迪杰斯特拉算法代码 迪杰斯特拉复杂度 弗洛伊德算法 弗洛伊德算法是求图中任意一对顶点间的最短路径的算法 算法思想： 佛洛依德算法实例 初始化 第一次 第二次 第三次 第四次 弗洛伊德算法代码和复杂度 拓扑排序AOV网 拓扑排序算法思路 第一轮： 第二轮： 第三轮： 第四轮： 第五轮： 第六轮： 第七轮： 拓扑排序算法代码 拓扑排序算法复杂度 拓扑排序规律 关键路径AOE网 关键路径 寻找关键路径步骤]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F7%20%E6%8E%92%E5%BA%8F%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序排序就是将原本无序的序列重新排列成有序的序列 排序的稳定性 内部排序：指的是待排序记录全部存放在计算机内存中进行排序的过程 外部排序：指的是待排序的记录的数量很大，以致内存一次不能容纳全部记录，在排序过程中尚需要对外存进行访问的排序过程 内部排序分类 插入类：将无序子序列中的一个或几个记录插入到有序序列中，从而增加记录的有序子序列的长度，包括直接插入排序、折半插入排序、希尔排序 交换类：通过交换无序序列中的记录从而得到其中关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度，包括冒泡排序和快速排序 选择类：从记录的无序子序列中选择关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加有序子序列的长度，包括简单选择排序、树形选择排序、堆排序 归并类：通过归并两个或两个以上的记录有序子序列，逐步增加记录有序序列的长度，包括2路归并排序 分配类：是唯一一类不需要关键字之间的比较的排序方法，排序时主要利用分配和收集两种基本操作完成。基数排序是主要的分配类排序 插入排序直接插入排序 空间时间复杂度 时间复杂度最好O(n)，最坏O(n2) 直接插入排序是稳定的 折半查找排序 折半排序代码 时间复杂度 时间复杂度O(n2) 折半插入排序是稳定的 希尔排序 希尔排序过程 第一趟：10个元素取增量10/2=5 第二趟：5/2向下取整=2 第三趟：最后增量为1 希尔排序的时间复杂度 时间复杂度最好O(n1.3)，最坏O(n2). 希尔排序不稳定 交换排序交换类排序：根据序列中两个元素关键字的比较结果来交换它两在序列中的位置 冒泡排序 冒泡排序代码 冒泡排序时间复杂度最好O(n)，最坏O(n2). 冒泡排序稳定. 快速排序快速排序是一种基于分治法的排序方法 快速排序代码 快速排序时间复杂度最好O(nlogn)，最坏O(n2). 序列越乱序，效率越高；序列越有序，效率越低 空间复杂度最好O(logn)，最坏O(n). 快速排序不稳定. 选择排序 简单选择排序 简单选择排序时间复杂度O(n2) 不稳定，交换会打破顺序 堆排序堆的定义 大顶堆过程 堆排序算法 堆排序时间复杂度O(nlog2n)，空间复杂度O(1)。 堆排序不稳定. 归并排序 归并排序代码 时间复杂度O(nlogn),空间复杂度O(n) 归并排序稳定 非比较排序基数排序(桶排序) MSD]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
