<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HashMap遍历与删除]]></title>
    <url>%2F2019%2F10%2F22%2Fjava%E9%9B%86%E5%90%88%E7%B1%BB%2FHashMap%E9%81%8D%E5%8E%86%E4%B8%8E%E5%88%A0%E9%99%A4%2F</url>
    <content type="text"><![CDATA[HashMap遍历123456789101112Map&lt;String,String&gt; map=new HashMap&lt;String,String&gt;(); map.put("1", "value1"); map.put("2", "value2"); map.put("3", "value3"); map.put("4", "value4"); //第一种：普通使用，二次取值 System.out.println("\n通过Map.keySet遍历key和value："); for(String key:map.keySet()) &#123; System.out.println("Key: "+key+" Value: "+map.get(key)); &#125; 12345678//第二种 System.out.println("\n通过Map.entrySet使用iterator遍历key和value: "); Iterator map1ist=map.entrySet().iterator(); while(map1ist.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry=(Entry&lt;String, String&gt;) map1ist.next(); System.out.println("Key: "+entry.getKey()+" Value: "+entry.getValue()); &#125; 123456//第三种：推荐，尤其是容量大时 System.out.println("\n通过Map.entrySet遍历key和value"); for(Map.Entry&lt;String, String&gt; entry: map.entrySet())&#123; System.out.println("Key: "+ entry.getKey()+ " Value: "+entry.getValue());&#125; 123456//第四种 System.out.println("\n通过Map.values()遍历所有的value，但不能遍历key"); for(String v:map.values())&#123; System.out.println("The value is "+v);&#125; HashMap遍历删除1、第一种遍历删除： 12345678for(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123; Integer key = entry.getKey(); if(key % 2 == 0)&#123; System.out.println("To delete key " + key); map.remove(key); System.out.println("The key " + + key + " was deleted"); &#125;&#125; 这种遍历删除依旧会报ConcurrentModificationException异常 2、第二种遍历删除： 123456789Set&lt;Integer&gt; keySet = map.keySet();for(Integer key : keySet)&#123; if(key % 2 == 0)&#123; System.out.println("To delete key " + key); keySet.remove(key); System.out.println("The key " + + key + " was deleted"); &#125; &#125;&#125; 这种遍历删除依旧会报ConcurrentModificationException异常 3、第三种遍历删除： 1234567891011 Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = map.entrySet().iterator(); while(it.hasNext())&#123; Map.Entry&lt;Integer, String&gt; entry = it.next(); Integer key = entry.getKey(); if(key % 2 == 0)&#123; System.out.println("To delete key " + key); it.remove(); System.out.println("The key " + + key + " was deleted"); &#125; &#125;&#125; 这种遍历是OK的 分析上述原因，如果大家理解了List的遍历删除，HashMap的遍历删除有类似之处。下面就分析一下原因： 如果查询源代码以上的三种的删除方式都是通过调用HashMap.removeEntryForKey方法来实现删除key的操作。在removeEntryForKey方法内执行一次 modCount就会执行一次自增操作，此时modCount就与expectedModCount不一致了，上面三种remove实现中，只有第三种iterator的remove方法在调用完removeEntryForKey方法后同步了expectedModCount值与modCount相同，所以iterator方式不会抛出异常。]]></content>
      <categories>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F10%2F21%2F%E7%AE%97%E6%B3%95%2F%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Linux基础命令]]></title>
    <url>%2F2019%2F10%2F21%2FLinux%2FLinux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[wget wget是一个下载文件的工具，它用在命令行下。 wget支持HTTP，HTTPS和FTP协议，可以使用HTTP代理。所谓的自动下载是指，wget可以在用户退出系统的之后在后台执行。这意味这你可以登录系统，启动一个wget下载任务，然后退出系统，wget将在后台执行直到任务完成 wget 可以跟踪HTML页面上的链接依次下载来创建远程服务器的本地版本，完全重建原始站点的目录结构。这又常被称作”递归下载”。 1234567891011登入并输入文件: -o, --output-file=FILE 将信息写入 FILE。 -a, --append-output=FILE 将信息添加至 FILE。 -d, --debug 打印大量调试信息。 -q, --quiet 安静模式(无信息输出)。 -v, --verbose 详尽的输出(此为默认值)。 -nv, --no-verbose 关闭详尽输出，但不进入安静模式。 -i, --input-file=FILE 下载本地或外部 FILE 中的 URLs。 -F, --force-html 把输入文件当成 HTML 文件。 -B, --base=URL 解析与 URL 相关的 HTML 输入文件（由 -i -F 选项指定）。 使用wget -O下载并以不同的文件名保存(-O：下载文件到对应目录，并且修改文件名称) 1wget -O wordpress.zip http://www.minjieren.com/download.aspx?id=1080 使用wget -b后台下载 123wget -b &lt;a href=&quot;http://www.minjieren.com/wordpress-3.1-zh_CN.zip&quot;&gt;http://www.minjieren.com/wordpress-3.1-zh_CN.zip&lt;/a&gt;备注： 你可以使用以下命令来察看下载进度：tail -f wget-log 利用-spider: 模拟下载，不会下载，只是会检查是否网站是否好着 1[root@localhost ~]# wget --spider www.baidu.com #不下载任何文件 tar-c: 建立压缩档案-x：解压-t：查看内容-r：向压缩归档文件末尾追加文件-u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。 -z：有gzip属性的-j：有bz2属性的-Z：有compress属性的-v：显示所有过程-O：将文件解开到标准输出 下面的参数-f是必须的 -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 # tar -cf all.tar *.jpg这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。 # tar -rf all.tar *.gif这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。 # tar -uf all.tar logo.gif这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。 # tar -tf all.tar这条命令是列出all.tar包中所有文件，-t是列出文件的意思 # tar -xf all.tar这条命令是解出all.tar包中所有文件，-t是解开的意思 压缩 tar -cvf jpg.tar *.jpg //将目录里所有jpg文件打包成jpg.tar tar -czf jpg.tar.gz *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz tar -cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2 tar -cZf jpg.tar.Z *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux 解压 tar -xvf file.tar //解压 tar包 tar -xzvf file.tar.gz //解压tar.gz tar -xjvf file.tar.bz2 //解压 tar.bz2 tar -xZvf file.tar.Z //解压tar.Z unrar e file.rar //解压rar unzip file.zip //解压zip 总结 1、*.tar 用 tar -xvf 解压 2、*.gz 用 gzip -d或者gunzip 解压 3、.tar.gz和.tgz 用 tar -xzf 解压 4、*.bz2 用 bzip2 -d或者用bunzip2 解压 5、*.tar.bz2用tar -xjf 解压 6、*.Z 用 uncompress 解压 7、*.tar.Z 用tar -xZf 解压 8、*.rar 用 unrar e解压 9、*.zip 用 unzip 解压]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring IOC和AOP]]></title>
    <url>%2F2019%2F10%2F21%2F%E6%A1%86%E6%9E%B6%2FSpring%20IOC%E5%92%8CAOP%2F</url>
    <content type="text"><![CDATA[Spring IOCIoC 全称为 Inversion of Control，翻译为 “控制反转”，它还有一个别名为 DI（Dependency Injection）,即依赖注入。 ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下： ●谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 ●为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。 DI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下： ●谁依赖于谁：当然是应用程序依赖于IoC容器； ●为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源； ●谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象； ●注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。 Spring AOPAOP是Spring框架面向切面的编程思想，AOP采用一种称为“横切”的技术，将涉及多业务流程的通用功能抽取并单独封装，形成独立的切面，在合适的时机将这些切面横向切入到业务流程指定的位置中。 例如，在一个业务系统中，用户登录是基础功能，凡是涉及到用户的业务流程都要求用户进行系统登录。如果把用户登录功能代码写入到每个业务流程中，会造成代码冗余，维护也非常麻烦，当需要修改用户登录功能时，就需要修改每个业务流程的用户登录代码，这种处理方式显然是不可取的。比较好的做法是把用户登录功能抽取出来，形成独立的模块，当业务流程需要用户登录时，系统自动把登录功能切入到业务流程中。下图是用户登录功能切入到业务流程示意图。 ● Aspect 表示切面。切入业务流程的一个独立模块。 ● Join point 表示连接点。也就是业务流程在运行过程中需要插入切面的具体位置。 ● Advice 表示通知。是切面的具体实现方法。可分为前置通知（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）和环绕通知（Around）五种。实现方法具体属于哪类通知，是在配置文件和注解中指定的。 ● Pointcut 表示切入点。用于定义通知应该切入到哪些连接点上，不同的通知通常需要切入到不同的连接点上。 ● Target 表示目标对象。被一个或者多个切面所通知的对象。 ● Proxy 表示代理对象。将通知应用到目标对象之后被动态创建的对象。可以简单地理解为，代理对象为目标对象的业务逻辑功能加上被切入的切面所形成的对象。 ● Weaving 表示切入，也称为织入。将切面应用到目标对象从而创建一个新的代理对象的过程。这个过程可以发生在编译期、类装载期及运行期。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bean的生命周期]]></title>
    <url>%2F2019%2F10%2F21%2F%E6%A1%86%E6%9E%B6%2Fbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[可以简述为以下九步 实例化bean对象(通过构造方法或者工厂方法) 设置对象属性(setter等)（依赖注入） 如果Bean实现了BeanNameAware接口，工厂调用Bean的setBeanName()方法传递Bean的ID。（和下面的一条均属于检查Aware接口） 如果Bean实现了BeanFactoryAware接口，工厂调用setBeanFactory()方法传入工厂自身 将Bean实例传递给Bean的前置处理器的postProcessBeforeInitialization(Object bean, String beanname)方法 调用Bean的初始化方法 将Bean实例传递给Bean的后置处理器的postProcessAfterInitialization(Object bean, String beanname)方法 使用Bean 容器关闭之前，调用Bean的销毁方法]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap按键排序和按值排序]]></title>
    <url>%2F2019%2F10%2F20%2Fjava%E9%9B%86%E5%90%88%E7%B1%BB%2FHashMap%E6%8C%89%E9%94%AE%E6%8E%92%E5%BA%8F%E5%92%8C%E6%8C%89%E5%80%BC%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[HashMap按键排序和按值排序HashMap：我们最常用的Map，它根据key的HashCode 值来存储数据,根据key可以直接获取它的Value，同时它具有很快的访问速度。HashMap最多只允许一条记录的key值为Null(多条会覆盖);允许多条记录的Value为 Null。非同步的。 TreeMap: 能够把它保存的记录根据key排序,默认是按升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。TreeMap不允许key的值为null。非同步的。 Hashtable: 与 HashMap类似,不同的是:key和value的值均不允许为null;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了Hashtale在写入时会比较慢。 LinkedHashMap: 保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.在遍历的时候会比HashMap慢。key和value均允许为空，非同步的。 TreeMapTreeMap默认是升序的，如果我们需要改变排序方式，则需要使用比较器：Comparator。 Comparator可以对集合对象或者数组进行排序的比较器接口，实现该接口的public compare(T o1,To2)方法即可实现排序，该方法主要是根据第一个参数o1,小于、等于或者大于o2分别返回负整数、0或者正整数。如下： 12345678910111213141516171819202122public class TreeMapTest &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new TreeMap&lt;String, String&gt;( new Comparator&lt;String&gt;() &#123; public int compare(String obj1, String obj2) &#123; // 降序排序 return obj2.compareTo(obj1); &#125; &#125;); map.put("c", "ccccc"); map.put("a", "aaaaa"); map.put("b", "bbbbb"); map.put("d", "ddddd"); Set&lt;String&gt; keySet = map.keySet(); Iterator&lt;String&gt; iter = keySet.iterator(); while (iter.hasNext()) &#123; String key = iter.next(); System.out.println(key + ":" + map.get(key)); &#125; &#125;&#125; 上面例子是对根据TreeMap的key值来进行排序的，但是有时我们需要根据TreeMap的value来进行排序。对value排序我们就需要借助于Collections的sort(List list, Comparator&lt;? super T&gt; c)方法，该方法根据指定比较器产生的顺序对指定列表进行排序。但是有一个前提条件，那就是所有的元素都必须能够根据所提供的比较器来进行比较。如下： 123456789101112131415161718192021222324public class TreeMapTest &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new TreeMap&lt;String, String&gt;(); map.put("d", "ddddd"); map.put("b", "bbbbb"); map.put("a", "aaaaa"); map.put("c", "ccccc"); //这里将map.entrySet()转换成list List&lt;Map.Entry&lt;String,String&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;String,String&gt;&gt;(map.entrySet()); //然后通过比较器来实现排序 Collections.sort(list,new Comparator&lt;Map.Entry&lt;String,String&gt;&gt;() &#123; //升序排序 public int compare(Entry&lt;String, String&gt; o1, Entry&lt;String, String&gt; o2) &#123; return o1.getValue().compareTo(o2.getValue()); &#125; &#125;); for(Map.Entry&lt;String,String&gt; mapping:list)&#123; System.out.println(mapping.getKey()+":"+mapping.getValue()); &#125; &#125;&#125; HashMap我们都是HashMap的值是没有顺序的，他是按照key的HashCode来实现的。对于这个无序的HashMap我们要怎么来实现排序呢？参照TreeMap的value排序，我们一样的也可以实现HashMap的排序。 1234567891011121314151617181920212223public class HashMapTest &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put("c", "ccccc"); map.put("a", "aaaaa"); map.put("b", "bbbbb"); map.put("d", "ddddd"); List&lt;Map.Entry&lt;String,String&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;String,String&gt;&gt;(map.entrySet()); Collections.sort(list,new Comparator&lt;Map.Entry&lt;String,String&gt;&gt;() &#123; //升序排序 public int compare(Entry&lt;String, String&gt; o1, Entry&lt;String, String&gt; o2) &#123; return o1.getValue().compareTo(o2.getValue()); &#125; &#125;); for(Map.Entry&lt;String,String&gt; mapping:list)&#123; System.out.println(mapping.getKey()+":"+mapping.getValue()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis为什么可以承担高并发]]></title>
    <url>%2F2019%2F10%2F20%2F%E9%9B%B6%E6%95%A3%E8%AE%B0%2Fredis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E6%89%BF%E6%8B%85%E9%AB%98%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[绝大部分请求是纯粹的内存操作（非常快速） 采用单线程,避免了不必要的上下文切换和竞争条件 非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间 epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。那epoll都是怎么解决的呢？在此之前，我们先看一下epoll和select和poll的调用接口上的不同，select和poll都只提供了一个函数——select或者poll函数。而epoll提供了三个函数，epoll_create,epoll_ctl和epoll_wait，epoll_create是创建一个epoll句柄；epoll_ctl是注册要监听的事件类型；epoll_wait则是等待事件的产生。 对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。 对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。 对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。]]></content>
      <categories>
        <category>零散记</category>
      </categories>
      <tags>
        <tag>零散记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GET和POST的区别]]></title>
    <url>%2F2019%2F10%2F19%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FGET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[数据传输方式不同：GET请求通过URL传输数据，而POST的数据通过请求体传输。 安全性不同：POST的数据因为在请求主体内，所以有一定的安全性保证，而GET的数据在URL中，通过历史记录，缓存很容易查到数据信息。 数据类型不同：GET只允许 ASCII 字符，而POST无限制 后退页面的反应：get请求页面后退时，不产生影响；post请求页面后退时，会重新提交请求 特性不同：GET是安全（这里的安全是指只读特性，就是使用这个方法不会引起服务器状态变化）且幂等（幂等的概念是指同一个请求方法执行多次和仅执行一次的效果完全相同），而POST是非安全非幂等 缓存性：get请求是可以缓存的，post请求不可以缓存 传输数据的大小： get一般传输数据大小不超过2k-4k（根据浏览器不同，限制不一样，但相差不大）；post请求传输数据的大小根据php.ini 配置文件设定，也可以无限大。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP]]></title>
    <url>%2F2019%2F10%2F15%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FHTTP%2F</url>
    <content type="text"><![CDATA[http请求信息格式请求行、请求头、空行、请求数据 请求行描述客户端的请求方式、请求资源的名称、http协议的版本号。 例如： GET/BOOK/JAVA.HTML HTTP/1.1 请求头客户机请求的服务器主机名，客户机的环境信息等 Accept：用于告诉服务器，客户机支持的数据类型 （例如：Accept:text/html,image/*）Accept-Charset：用于告诉服务器，客户机采用的编码格式Accept-Encoding：用于告诉服务器，客户机支持的数据压缩格式Accept-Language：客户机语言环境Host:客户机通过这个服务器，想访问的主机名If-Modified-Since：客户机通过这个头告诉服务器，资源的缓存时间Referer：客户机通过这个头告诉服务器，它（客户端）是从哪个资源来访问服务器的（防盗链）User-Agent：客户机通过这个头告诉服务器，客户机的软件环境（操作系统，浏览器版本等）Cookie：客户机通过这个头，将Coockie信息带给服务器Connection：告诉服务器，请求完成后，是否保持连接Date：告诉服务器，当前请求的时间 空行请求数据就是指浏览器端通过http协议发送给服务器的实体数据。例如：name=dylan&amp;id=110（get请求时，通过url传给服务器的值。post请求时，通过表单发送给服务器的值） http响应信息格式状态行、消息报头、空行、响应正文 状态行例如： HTTP/1.1 200 OK （协议的版本号是1.1 响应状态码为200 响应结果为 OK） 消息报头Location：这个头配合302状态吗，用于告诉客户端找谁Server：服务器通过这个头，告诉浏览器服务器的类型Content-Encoding：告诉浏览器，服务器的数据压缩格式Content-Length：告诉浏览器，回送数据的长度Content-Type：告诉浏览器，回送数据的类型Last-Modified：告诉浏览器当前资源缓存时间Refresh：告诉浏览器，隔多长时间刷新Content-Disposition：告诉浏览器以下载的方式打开数据。例如： context.Response.AddHeader(“Content-Disposition”,”attachment:filename=aa.jpg”); context.Response.WriteFile(“aa.jpg”);Transfer-Encoding：告诉浏览器，传送数据的编码格式ETag：缓存相关的头（可以做到实时更新）Expries：告诉浏览器回送的资源缓存多长时间。如果是-1或者0，表示不缓存Cache-Control：控制浏览器不要缓存数据 no-cachePragma：控制浏览器不要缓存数据 no-cache Connection：响应完成后，是否断开连接。 close/Keep-AliveDate：告诉浏览器，服务器响应时间 响应正文响应包含浏览器能够解析的静态内容，例如：html，纯文本，图片等等信息 http状态码 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 1** 100 Continue 继续。客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 2** 200* OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204* No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206* Partial Content 部分内容。服务器成功处理了部分GET请求 3** 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301* Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302* Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303* See Other 查看其它地址。与301类似。使用GET和POST请求查看 304* Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307* Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 4** 400* Bad Request 客户端请求的语法错误，服务器无法理解 401* Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403* Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404* Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 409 Conflict 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 5** 500* Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503* Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理 http请求方法HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。 GET 请求指定的页面信息，并返回实体主体。 HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 PATCH 是对 PUT 方法的补充，用来对已知资源进行局部更新 。 HTTP的keep-alive是干什么的？在早期的HTTP/1.0中，每次http请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在后来的HTTP/1.0中以及HTTP/1.1中，引入了重用连接的机制，就是在http请求头中加入Connection: keep-alive来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上Connection: keep-alive。 keep-alive的优点： 较少的CPU和内存的使用（由于同时打开的连接的减少了） 允许请求和应答的HTTP管线化 降低拥塞控制 （TCP连接减少了） 减少了后续请求的延迟（无需再进行握手） 报告错误无需关闭TCP连接 什么是长连接、短连接？在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。 而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：Connection:keep-alive 在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。 HTTP2相对于HTTP1.x有什么优势和特点？二进制分帧帧：HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。 流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。 头部压缩HTTP/1.x会在请求和响应中中重复地携带不常改变的、冗长的头部数据，给网络带来额外的负担。 HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新; 每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。 你可以理解为只发送差异数据，而不是全部发送，从而减少头部的信息量 服务器推送服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。 服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。 多路复用HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。 HTTP2中： 同域名下所有通信都在单个连接上完成。 单个连接可以承载任意数量的双向数据流。 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装 HTTP的缓存的过程是怎样的？通常情况下的步骤是: 客户端向服务器发出请求，请求资源 服务器返回资源，并通过响应头决定缓存策略 客户端根据响应头的策略决定是否缓存资源（这里假设是），并将响应头与资源缓存下来 在客户端再次请求且命中资源的时候，此时客户端去检查上次缓存的缓存策略，根据策略的不同、是否过期等判断是直接读取本地缓存还是与服务器协商缓存]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS和HTTP的区别]]></title>
    <url>%2F2019%2F10%2F15%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FHTTPS%E5%92%8CHTTP%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[HTTPS和HTTP的区别 HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。 HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。 HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 HTTP的连接很简单，是无状态的。Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 (无状态的意思是其数据包的发送、传输和接收都是相互独立的。 无连接的意思是指通信双方都不长久的维持对方的任何信息。) HTTPS的优点：1、使用Https协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。 2、Https协议是由SSL+Http协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。 3、Https是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 HTTPS的缺点：1、Https协议握手阶段比较费时，会使页面的加载时间延长近。 2、Https连接缓存不如Http高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响； 3、SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。 4、Https协议的加密范围也比较有限。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。 HTTPS连接过程 ①客户端的浏览器向服务器发送请求，并传送客户端SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。 ②服务器向客户端传送SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。 ③客户端利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。 ④用户端随机产生一个用于通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。 ⑤如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。 ⑥如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。 ⑦服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL 协议的安全数据通讯的加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。 ⑧客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。 ⑨服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。 ⑩SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。 对称加密和非对称加密的区别对称加密只有一把公钥，加密解密都是这个密钥进行 非对称加密有公钥和私钥，用公钥加密，用私钥解密 HTTPS是对称加密和非对称加密两者结合的，在传输对称加密的公钥的时候用到非对称加密进行加密传输]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面经]]></title>
    <url>%2F2019%2F10%2F10%2F%E9%9D%A2%E7%BB%8F%2F%E9%9D%A2%E7%BB%8F%2F</url>
    <content type="text"><![CDATA[远光oracle和mysql的区别默认隔离级别不同：mysql默认可重复读，oracle默认读已提交 隔离级别种类不同：oracle只有读已提交和串行化，只读 对事务的提交：mysql自动提交，oracle默认手动提交 并发性：mysql有索引行级锁，没索引表级锁，oracle使用行级锁对资源锁定的粒度小得很，只是锁定sql需要得资源，不依赖索引 分页查询：MySQL用到limit，oracle用到伪列ROWNUM和嵌套查询 逻辑备份：mysql逻辑备份数据需要锁定数据，oracle不需要 Exception和Error有什么区别，使用异常需要注意什么Error（错误）是系统中的错误，程序员是不能改变的和处理的，是在程序编译时出现的错误，只能通过修改程序才能修正。一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。 Exception（异常）表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。 Exception又分为两类 CheckedException：（编译时异常） 需要用try——catch显示的捕获，对于可恢复的异常使用CheckedException。 UnCheckedException（RuntimeException）：（运行时异常）不需要捕获，对于程序错误（不可恢复）的异常使用RuntimeException。 常见的RuntimeException异常： illegalArgumentException：此异常表明向方法传递了一个不合法或不正确的参数。 illegalStateException：在不合理或不正确时间内唤醒一方法时出现的异常信息。换句话说，即 Java 环境或 Java 应用不满足请求操作。 NullpointerException：空指针异常（我目前遇见的最多的） IndexOutOfBoundsException：索引超出边界异常 常见的CheckedException异常 我们在编写程序过程中try——catch捕获到的一场都是CheckedException。 io包中的IOExecption及其子类，都是CheckedException。 使用异常注意事项： 子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。 如果父类抛出了多个异常,子类重写父类时,只能抛出相同的异常或者是他的子集,子类不能抛出父类没有的异常 如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能try,不能throws 尽量不要捕获类似Exception这样的通用异常，而应捕获特定异常。例如进行文件流操作时应捕获IOException，而不能笼统地捕获Exception。 4.捕获多个异常时必须先捕获小的异常再捕获大的异常。 java优化代码https://www.cnblogs.com/qlqwjy/p/7717735.html 重构的定义https://blog.csdn.net/tiantiandjava/article/details/39637453 可以说一下设计模式 土巴兔一面 Java数据类型(char啊) hashmap底层原理 如果是put对象怎么办 string stringbuffer stringbuilder区别 string 中文字符占几个字节 java的反射机制 二面 项目加入mq怎么做，加在哪里 mq放在下订单不行，会阻塞 mq几个特性：限流削峰，异步调用，怎么把这些功能加进项目里 注册怎么注册，手机登录，过程可以怎么做 邮件注册登录怎么实现 md5加密是对称加密还是非对称加密 金证bean的生命周期，过程 https和http的区别 servlet创建销毁过程 mybatis连接MySQL Spring AOP和Spring IOC 多线程创建方式 对业务的了解 纷享一面： ==和equals的区别（Integer i=1;int j=1;i==j,i.equals(j)） http和https的区别 @resource和@autowired的区别 ArrayList手写遍历，手写删除的几种方式 list1和list2相等，list1包含list2，怎么判断 HashMap是存key还是value，HashMap扩容机制 写一道Group By的SQL 联合索引的最左匹配原则 双亲委派模型，同一个类用不同的加载器加载，jvm会认为是同一个类吗？ 二面: Spring的底层原理，IOC和AOP底层原理 为什么使用Redis Redis为什么可以承担高并发，为什么可以这么快 zookeeper分布式锁用来干嘛的，为什么用它来解决双写数据不一致的问题 可以用java的锁去解决这个问题吗]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java数组怎么输出]]></title>
    <url>%2F2019%2F10%2F02%2FJava%E5%9F%BA%E7%A1%80%2FJava%E6%95%B0%E7%BB%84%E6%80%8E%E4%B9%88%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[Java数组怎么输出错误示范：System.out.println(array); 这样输出的是数组的首地址，而不能打印出数组数据。 12345int[] array= &#123;1,2,3,4,5,6&#125;;//方式一：for循环for(int i=0;i&lt;array.length;i++)&#123; System.out.println(array[i]);&#125; 1234//方式二：for eachfor(int a:array) System.out.println(a); 1234//方式三：Arrays类中的toString方法（注意，是Arrays不是Array，Arrays类位于java.util包下）int[] array= &#123;1,2,3,4,5,6&#125;;System.out.println(Arrays.toString(array));]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java对日期操作的类]]></title>
    <url>%2F2019%2F10%2F02%2FJava%E5%9F%BA%E7%A1%80%2FJava%E5%AF%B9%E6%97%A5%E6%9C%9F%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Date表示特定的瞬间，精确到毫秒（因为闰秒的原因，所以其实结果并不是特别的准确，但是如果要求不是特别严格，影响并没有很大。 构造方法：Date()、Date(Long date) 常用方法： void setTime(Long time)：根据毫秒数设置该日期对象，默认构造函数设置该日期对象为当前日期。 Long getTime()：获取日期对象毫秒数。毫秒数都是以1970年1月1日0点0分0秒开始计算。 （下面几个方法，在源代码中，实际比较的还是两个日期的毫秒数） int compareTo(Date date)：比较俩个日期顺序，比参数date小，返回负数，相等返回0，大则返回正数。 boolean before(Date date)：判断是否在参数date之前，是则返回true。 boolean after(Date date)：同上，判断在是否在参数之后。 boolean equals(Object date)：当且仅当date不为空，是Date对象，而且毫秒数与调用方法的日期对象相等才为true。 SimpleDateFormat继承DateFormat类，主要用来进行格式转换。 构造函数：SimpleDateFormat(String pattern)，最常用的构造方法。根据指定格式来转换字符串与日期。 常用的2个格式转换方法： 字符串转换成Date类：Date parse(String date) Date类转换成字符串类型：String format(Date date)，都是继承DateFormat类的方法。 其中，parse方法会抛出一个转换异常： 12345678public Date parse(String source) throws ParseException&#123; ParsePosition pos = new ParsePosition(0); Date result = parse(source, pos); if (pos.index == 0) throw new ParseException("Unparseable date: \"" + source + "\"" , pos.errorIndex); return result; &#125; 下面是一个转换的例子： 1234567891011121314public static void main(String[] args) throws ParseException &#123; //对字符串格式类似为2018-09这种进行转换，年月之间用‘-’分隔 SimpleDateFormat simpleDateFormat=new SimpleDateFormat("yyyy-MM"); Date date=(Date)simpleDateFormat.parse("2018-09"); System.out.println(date); String dateStr=simpleDateFormat.format(date); System.out.println(dateStr); //将转换格式应用为201809这种，年月之间没有分隔符号的，只要年月相同，结果就与上面相同 simpleDateFormat.applyPattern("yyyyMM");//applyPattern方法用来切换需要转换的字符串格式。 Date date2=(Date)simpleDateFormat.parse("201809"); System.out.println(date2); String dateStr2=simpleDateFormat.format(date2); System.out.println(dateStr2);&#125; Calendar一个抽象类，为特定瞬间和一组日历字段之间的转换以及操作日历字段提供了方法。 使用Calendar.getInstance获取该对象：Calendar nowTime=Calendar.getInstance(); 部分常用方法： void setTime(Date date)：通过该类方法指定Calendar对象表示的日期。 Date getTime()：获取一个Date对象。 void setTimeInMillis(Long time)：同上。 void add(int field,int amount)：给当前对象的指定字段增加指定数值。Calender类为日历中的各种字段都设置了int类型的数值，比如， 123public final static int YEAR = 1;public final static int MONTH = 2;public final static int WEEK_OF_YEAR = 3; 字段‘年’所对应的int值为1，如果你想将当前日历类对象的年份加1年，那么只需这样做： 12345678Calendar nowTime=Calendar.getInstance();System.out.println(nowTime.get(Calendar.YEAR));nowTime.add(YEAR,1);System.out.println(nowTime.get(Calendar.YEAR)); 结果：20182019 int compareTo(Calendar calendar)：最终还是使用毫秒数来比较的。 boolean before(Object obj)、boolean after(Object obj)：内部都是调用上面的compareTo方法实现。 三个日期类的使用例子（1）一天的毫秒数：Long oneDay=Long.parseLong((24*60*60*1000)+””); （2）接收的字符串格式的时间，转化为Date类型，并且获取对应的毫秒数： 123456789101112public static void main(String[] args) throws ParseException &#123; SimpleDateFormat simpleDateFormat=new SimpleDateFormat("yyyy-MM"); Date date=(Date)simpleDateFormat.parse("2018-09"); //距离1970年1月1日的毫秒数 Long timeMilli=date.getTime(); System.out.println(date); System.out.println(timeMilli); &#125; 结果： Sat Sep 01 00:00:00 CST 2018 1535731200000 获取指定年月份中指定月的天数，比如2018年9月有30天，返回结果就应该为30，8月就应该返回31 例子中，是通过传入字符串日期来进行计算的，如果能直接接收日期对象就少一个转换的过程 123456789101112131415161718192021public static void main(String[] args) throws ParseException &#123; SimpleDateFormat simpleDateFormat=new SimpleDateFormat("yyyy-MM-dd"); //将日期字符串转换为Date对象 Date date=(Date)simpleDateFormat.parse("2018-08-05"); //通过Date对象，创建一个日历对象 Calendar calendar=Calendar.getInstance(); calendar.setTime(date); //通过日历中的字段，获取一个月的天数 Integer daysNumber=calendar.getActualMaximum(Calendar.DAY_OF_MONTH); System.out.println(daysNumber); Date date2=(Date)simpleDateFormat.parse("2018-09-05"); //通过Date对象，创建一个日历对象 calendar.setTime(date2); //通过日历中的字段，获取一个月的天数 daysNumber=calendar.getActualMaximum(Calendar.DAY_OF_MONTH); System.out.println(daysNumber);&#125; 结果： 31 30 获取对应日期的星期数 比如2018-08-19是星期天，就输出星期天，20号星期一就输出星期一 1234567891011121314151617181920212223242526272829303132333435363738public static void main(String[] args) throws ParseException &#123; SimpleDateFormat simpleDateFormat=new SimpleDateFormat("yyyy-MM-dd"); //将日期字符串转换为Date对象 Date date=(Date)simpleDateFormat.parse("2018-08-19"); //通过Date对象，创建一个日历对象 Calendar calendar=Calendar.getInstance(); calendar.setTime(date); //获取当天对应的星期数，星期天为1，星期六为7，详见Calendar类的常量 Integer dayOfWeek=calendar.get(Calendar.DAY_OF_WEEK); String dayOfWeekStr=null; switch(dayOfWeek) &#123; case 1: dayOfWeekStr="星期天"; break; case 2: dayOfWeekStr="星期一"; break; case 3: dayOfWeekStr="星期二"; break; case 4: dayOfWeekStr="星期三"; break; case 5: dayOfWeekStr="星期四"; break; case 6: dayOfWeekStr="星期五"; break; case 7: dayOfWeekStr="星期六"; break; &#125; System.out.println(dayOfWeekStr);&#125; 结果： 星期天 总结： SimpleDateFormat类用于转换格式，String←→Date； Date类用于获取毫秒数，或者作为设置Calendar对象日期的参数，date.getTime()、calendar.setTime(date) Calendar类用于具体操作，比如获取指定年、月的天数，日期对应的星期数，对应的月份数等。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符流和字节流]]></title>
    <url>%2F2019%2F10%2F02%2FJava%E5%9F%BA%E7%A1%80%2F%E5%AD%97%E7%AC%A6%E6%B5%81%E5%92%8C%E5%AD%97%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[什么是流 流是个抽象的概念,是对输入输出设备的抽象，输入流可以看作一个输入通道，输出流可以看作一个输出通道。 输入流是相对程序而言的，外部传入数据给程序需要借助输入流。 输出流是相对程序而言的，程序把数据传输到外部需要借助输出流。 字节流字节流–传输过程中，传输数据的最基本单位是字节的流。 字符流字符流–传输过程中，传输数据的最基本单位是字符的流。 字符编码方式不同，有时候一个字符使用的字节数也不一样，比如ASCLL方式编码的字符，占一个字节；而UTF-8方式编码的字符，一个英文字符需要一个字节，一个中文需要三个字节。 字节数据是二进制形式的，要转成我们能识别的正常字符，需要选择正确的编码方式。我们生活中遇到的乱码问题就是字节数据没有选择正确的编码方式来显示成字符。 从本质上来讲，写数据（即输出）的时候，字节也好，字符也好，本质上都是没有标识符的，需要去指定编码方式。 file字节流输入输出例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;public class IOTest &#123; public static void main(String[] args) &#123; OutputStream fos = null; InputStream fis = null; try &#123; /********* 输出流写文件 ***********/ fos=new FileOutputStream("d:\\silly.txt"); String str="最好的我们隔了一整个青春"; byte[] words=str.getBytes(); //把字符串编码成字节序列 //写入操作 fos.write(words, 0, words.length); System.out.println("写入成功！"); /********* 输入流读文件 ***********/ fis = new FileInputStream("d:\\silly.txt"); StringBuilder sb = new StringBuilder(); byte[] buf = new byte[1024]; //字节数组缓存数据 int n = 0; //记录读取的字节长度 //循环读取数据 while((n = fis.read(buf)) != -1)&#123; //这里使用三个参数的构造方法，因为最后一次读取的长度可能达不到buf数组的长度 //所以根据实际读取的长度n去构造对象更合理 sb.append(new String(buf, 0, n)); buf = new byte[1024]; //重新初始化，避免数据重复 &#125; System.out.println(sb.toString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally&#123; try &#123; //释放资源 if(fos != null) fos.close(); if(fis != null) fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; file字符流输入输出例子 1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class IOTest2 &#123; /* * FileWriter:用来写入字符文件的便捷类。 * 父类：OutputStreamWriter * FileWriter 用于写入字符流。要写入原始字节流，请考虑使用 FileOutputStream。 * */ public static void main(String[] args) throws IOException &#123; /** * 输入流 //1：创建字符输出便捷流 FileWriter fw = new FileWriter("d:\\a.txt"); //2:写数据 fw.write("你好吗"); //3:关闭流 fw.close(); */ //输出流 //1:创建字符输入便捷流 FileReader fr = new FileReader("d:\\a.txt"); //2:读数据 //2.1 一次读取一个字符 /*int num = 0; while((num = fr.read())!=-1)&#123; System.out.print((char)num); &#125;*/ //2.2 一次读取一个字符数组 char[] ch = new char[1024*1024]; int num = 0; while((num = fr.read(ch))!=-1)&#123; System.out.print(new String(ch,0,num)); &#125; //3:关闭流 fr.close(); &#125;&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类和接口的区别]]></title>
    <url>%2F2019%2F10%2F02%2FJava%E5%9F%BA%E7%A1%80%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[抽象类总结 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 接口和抽象类的区别 本质：从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范 区别：1.接口的方法默认是public，所有方法在接口中不能有实现，抽象类可以有非抽象的方法 2.接口中的实例变量默认是static final类型的，而抽象类中则不一定 3.一个类可以实现多个接口，但最多只能实现一个抽象类 4.一个类实现接口的话要实现接口的所有方法，而抽象类不一定（子类可以实现部分方法，所以子类也是抽象类） 5.接口不能用new实例化，但可以声明，但是必须引用一个实现该接口的对象 接口变量、方法修饰符（static 、final、public、private、protected、default） 1.接口中的所有属性默认为：public static final ； 2.接口中的所有方法默认为：public abstract ； 接口中变量只能public ，不可以protected、private，缺省不写默认public 接口中方法只能public，不可以protected、private，缺省不写默认public 接口如果abstract，不可以加方法体，如果是static或default可以加方法体（jdk1.8特性） 抽象类变量、方法修饰符（static 、final、public、private、protected、default） 抽象类中变量修饰符都可以用 抽象类中抽象方法（没有方法体）只能public和protected 抽象类中非抽象方法（有方法体）修饰符都可以用]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList遍历与删除]]></title>
    <url>%2F2019%2F10%2F01%2Fjava%E9%9B%86%E5%90%88%E7%B1%BB%2FArrayList%E9%81%8D%E5%8E%86%E4%B8%8E%E5%88%A0%E9%99%A4%2F</url>
    <content type="text"><![CDATA[ArrayList遍历三种方式12345672 public void arrayListTraversal(List&lt;Integer&gt; lists)&#123;3 /* 第一种遍历方式 */4 System.out.print("for循环的遍历方式：");5 for (int i = 0; i &lt; lists.size(); i++) &#123;6 System.out.print(lists.get(i));7 &#125;8 System.out.println(); 12345610 /* 第二种遍历方式 */11 System.out.print("for each的遍历方式：");12 for (Integer list : lists) &#123;13 System.out.print(list);14 &#125;15 System.out.println(); 1234517 /* 第三种遍历方式 */18 System.out.print("Iterator的遍历方式：");19 for (Iterator&lt;Integer&gt; list = lists.iterator(); list.hasNext();) &#123;20 System.out.print(list.next());21 &#125; ArrayList遍历删除的坑1234567891011121314151617181920212223import java.util.ArrayList;public class ArrayListRemove&#123; public static void main(String[]args) &#123; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); list.add("a"); list.add("b"); list.add("b"); list.add("c"); list.add("c"); list.add("c"); remove(list); for(Strings:list) &#123; System.out.println("element : "+s); &#125; &#125; public static void remove(ArrayList&lt;String&gt; list) &#123; // TODO: &#125;&#125; 错误的例子11234567891011public static void remove(ArrayList&lt;String&gt; list)&#123; for(inti=0;i&lt;list.size();i++) &#123; String s=list.get(i); if(s.equals("b")) &#123; list.remove(s); &#125; &#125;&#125; 错误的原因：这种最普通的循环写法执行后会发现第二个“b”的字符串没有删掉。 实例一的错误原因。翻开JDK的ArrayList源码，先看下ArrayList中的remove方法（注意ArrayList中的remove有两个同名方法，只是入参不同，这里看的是入参为Object的remove方法）是怎么实现的： 12345678910111213141516public boolean remove(Object o)&#123; if(o==null)&#123; for(int index=0;index&lt;size;index++) if(elementData[index]==null)&#123; fastRemove(index); return true; &#125; &#125;else&#123; for(intindex=0;index&lt;size;index++) if(o.equals(elementData[index]))&#123; fastRemove(index); return true; &#125; &#125; return false;&#125; 一般情况下程序的执行路径会走到else路径下最终调用faseRemove()方法： 1234567private void fastRemove(int index)&#123; modCount++; int numMoved=size-index-1; if(numMoved&gt;0) System.arraycopy(elementData,index+1,elementData,index,numMoved); elementData[--size]=null;// Let gc do its work&#125; 可以看到会执行System.arraycopy方法，导致删除元素时涉及到数组元素的移动。针对错误写法一，在遍历第一个字符串b时因为符合删除条件，所以将该元素从数组中删除，并且将后一个元素移动（也就是第二个字符串b）至当前位置，导致下一次循环遍历时后一个字符串b并没有遍历到，所以无法删除。 针对这种情况可以倒序删除的方式来避免或者在删除的时候下标减1 倒序删除的方式 1234567891011public static void remove(ArrayList&lt;String&gt; list)&#123; for(inti=list.size()-1;i&gt;=0;i--) &#123; String s=list.get(i); if(s.equals("b")) &#123; list.remove(s); &#125; &#125;&#125; 正序遍历时在删除时下标减一 12345678/*基本原理是，每次list删除元素后，后面的元素都要往前移动一位，就相当于i多加了1，remove后继续遍历就会错过一个元素，所以就需要代码中的i--，抵消remove后，后面元素前移一位的影响*/for(int i=0; i&lt;list.size(); i++)&#123; System.out.println(i); if(list.get(i).equals("C"))&#123; list.remove(list.get(i)); i--; &#125;&#125; 错误的例子212345678910public static void remove(ArrayList&lt;String&gt; list)&#123; for(Strings:list) &#123; if(s.equals("b")) &#123; list.remove(s); &#125; &#125;&#125; 误的原因：这种for-each写法会报出著名的并发修改异常：java.util.ConcurrentModificationException。 错误二产生的原因却是foreach写法是对实际的Iterable、hasNext、next方法的简写，问题同样处在上文的fastRemove方法中，可以看到第一行把modCount变量的值加一，但在ArrayList返回的迭代器（该代码在其父类AbstractList中）： 123public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; 这里返回的是AbstractList类内部的迭代器实现private class Itr implements Iterator，看这个类的next方法： 1234567891011public E next() &#123; checkForComodification(); try &#123; E next = get(cursor); lastRet = cursor++; return next; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125;&#125; 第一行checkForComodification方法： 1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; 这里会做迭代器内部修改次数检查，因为上面的remove(Object)方法修改了modCount的值，所以才会报出并发修改异常。要避免这种情况的出现则在使用迭代器迭代时（显示或for-each的隐式）不要使用ArrayList的remove，改为用Iterator的remove即可。 123456789101112public static void remove(ArrayList&lt;String&gt; list) &#123; Iterator&lt;String&gt; it = list.iterator(); while (it.hasNext()) &#123; String s = it.next(); if (s.equals("b")) &#123; it.remove(); &#125; &#125;&#125; 使用foreach或者迭代器都是会用到迭代器，所以必须使用迭代器来删除，不然会报异常 12345678910 Integer[] arr = &#123;0, 1, 2, 3, 4&#125;; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.addAll(Arrays.asList(arr)); for (Iterator&lt;Integer&gt; iter = list.iterator(); iter.hasNext(); ) &#123; Integer tar = iter.next(); if (tar == 2) list.remove(tar); //iter.remove(tar); &#125;//这里相当于脱裤子放屁，用了迭代器，却用list删除，报异常， 再多一个例子12345678Integer[] arr = &#123;0, 1, 2, 3, 4&#125;;List&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.addAll(Arrays.asList(arr));for (Integer tar : list) &#123; if (tar == 2)&#123; list.remove(tar); &#125;&#125; 答案：报错ConcurrentModificationException位置在下面代码的倒数第三行，下面是 ArrayList中的迭代器。当我们使用foreach时，就是使用这个迭代器工作的，cursor是游标，指示当前已取出元素的下一个元素，lastRet指示当前已取出元素，expectedModCount是期待的修改次数,modCount是实际修改次数，每次循环都会先调用hasNext()，当游标不等于(即小于)list.size()时说明还有下一个元素，再调用next取出下一个值，next()方法的第一个方法就是checkForComodification()，检查期待的修改次数是否与实际相等，不相等就抛异常，expectedModCount变量范围是这个迭代器，使用list.remove(Object obj)只会使modCount++,expectedModCount的值不变自然就出错了。所以采用Iterator遍历是个明智的选择，它的remove()方法里面ArrayList.this.remove(lastRet)会 让modCount++，但随后又把modCount的值赋给了expectedModCount，继续循环不会出问题。 123456789101112131415161718192021222324252627282930313233343536373839404142 private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; 小提问：把上面的遍历tar == 2改成tar == 3还会错吗？如果你把上面的解释仔细看了的话，想必已经知道答案了，不会。解答：当tar == 3时，当前游标cursor是4,size是5,但当删除了tar，size就变成了4,和cursor相等了，到下一次循环，hasNext()判断时为false，所以结束了循环，不给它抛异常的机会。]]></content>
      <categories>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SimpleDateFormat线程安全问题和解决方案]]></title>
    <url>%2F2019%2F09%2F26%2F%E5%B9%B6%E5%8F%91%2FSimpleDateFormat%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程(一)]]></title>
    <url>%2F2019%2F05%2F26%2F%E5%B9%B6%E5%8F%91%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B1%2F</url>
    <content type="text"><![CDATA[多线程(一)进程和线程的基本概念进程：系统中能独立运行并作为资源分配的基本单位 进程的特征： 1.动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的。2.并发性：任何进程都可以同其他进程一起并发执行。3.独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位。4.异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。 线程：是进程中的一个实体，作为系统调度和分派的基本单位。 线程的性质： 1.线程是进程内的一个相对独立的可执行的单元。若把进程称为任务的话，那么线程则是应用中的一个子任务的执行。2.由于线程是被调度的基本单元，而进程不是调度单元。所以，每个进程在创建时，至少需要同时为该进程创建一个线程。即进程中至少要有一个或一个以上的线程，否则该进程无法被调度执行。3.进程是被分给并拥有资源的基本单元。同一进程内的多个线程共享该进程的资源，但线程并不拥有资源，只是使用他们。4.线程是操作系统中基本调度单元，因此线程中应包含有调度所需要的必要信息，且在生命周期中有状态的变化。5.由于共享资源【包括数据和文件】，所以线程间需要通信和同步机制，且需要时线程可以创建其他线程，但线程间不存在父子关系。 进程与线程的区别： 1、调度：在传统的操作系统中，CPU调度和分派的基本单位是进程。在引入线程的操作系统中，则把线程作为CPU调度和分派的基本单位，进程则作为资源拥有的基本单位，将线程作为cpu调度和分派，进程则作为资源拥有的基本单位，显著提高系统的并发性（同一进程中的线程切换不会引起进程切换，不同进程中的线程切换才会引起进程切换） 2、并发性：进程之间可以并发执行，同一个进程之间的线程也可以并发执行，提高系统资源和系统吞吐量 （例如，在一个为引入线程的单CPU操作系统中，若仅设置一个文件服务进程，当它由于某种原因被封锁时，便没有其他的文件服务进程来提供服务。在引入线程的操作系统中，可以在一个文件服务进程设置多个服务线程。当第一个线程等待时，文件服务进程中的第二个线程可以继续运行；当第二个线程封锁时，第三个线程可以继续执行，从而显著地提高了文件服务的质量以及系统的吞吐量。） 3、拥有资源：进程拥系统资源的独立单位，线程不能拥有自己的资源，但可以访问隶属进程的资源（代码段、数据段以及系统资源，可供同一个进程的其他线程共享） 4、独立性：在同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多，这是因为为了防止进程之间彼此干扰和破坏，每个进程都拥有一个独立的地址空间和其它资源，除了共享全局变量外，不允许其它进程的访问。 5、系统开销：由于在创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等。因此，操作系统为此所付出的开销将显著地大于在创建或撤消线程时的开销。 6、支持多处理机系统： 在多处理机系统中，对于传统的进程，即单线程进程，不管有多少处理机，该进程只能运行在一个处理机上。但对于多线程进程，就可以将一个进程中的多个线程分配到多个处理机上，使它们并行执行，这无疑将加速进程的完成。 创建和启动线程1、继承Thread类创建线程类 步骤： 定义一个继承Thread类的子类，并重写该类的run()方法 创建子类的实例，即创建线程对象 调用该线程对象的start()方法启动线程 1234567891011class SomeThead extends Thraad &#123; public void run() &#123; //do something here &#125; &#125; public static void main(String[] args)&#123; SomeThread oneThread = new SomeThread(); //启动线程： oneThread.start(); &#125; 2、实现Runnable接口创建线程类 步骤： 定义Runnable接口的实现类，并重写该接口的的run()方法 创建该实现类的实例 以此实例作为创建Thread对象的参数，该Thread对象即是线程对象 12345678class SomeRunnable implements Runnable &#123; public void run() &#123; //do something here &#125; &#125; Runnable oneRunnable = new SomeRunnable(); Thread oneThread = new Thread(oneRunnable); oneThread.start(); 3、通过Callable和Future创建对象 步骤： 创建Callable接口的实现类，并实现call()方法，该call()方法作为线程执行体，并且有返回值 创建Callable实现类的实例 使用FutureTask类来包装Callable对象，该FutureTask对象封装Callable对象的call()方法的返回值 使用FutureTask对象作为Thread对象的target创建并启动新线程 调用FutureTask对象的get()方法获取子线程执行结束后的返回值 12345678910111213public interface Callable &#123; V call() throws Exception; &#125; 步骤1：创建实现Callable接口的类SomeCallable(略); 步骤2：创建一个类对象： Callable oneCallable = new SomeCallable(); 步骤3：由Callable创建一个FutureTask对象： FutureTask oneTask = new FutureTask(oneCallable); 注释： FutureTask是一个包装器，它通过接受Callable来创建，它同时实现了 Future和Runnable接口。 步骤4：由FutureTask创建一个Thread对象： Thread oneThread = new Thread(oneTask); 步骤5：启动线程： oneThread.start(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ThreadTest &#123; public static void main(String[] args) &#123; Callable&lt;Integer&gt; myCallable = new MyCallable(); // 创建MyCallable对象 FutureTask&lt;Integer&gt; ft = new FutureTask&lt;Integer&gt;(myCallable); //使用FutureTask来包装MyCallable对象 for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + " " + i); if (i == 30) &#123; Thread thread = new Thread(ft); //FutureTask对象作为Thread对象的target创建新的线程 thread.start(); //线程进入到就绪状态 &#125; &#125; System.out.println("主线程for循环执行完毕.."); try &#123; int sum = ft.get(); //取得新创建的新线程中的call()方法返回的结果 System.out.println("sum = " + sum); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class MyCallable implements Callable&lt;Integer&gt; &#123; private int i = 0; // 与run()方法不同的是，call()方法具有返回值 @Override public Integer call() &#123; int sum = 0; for (; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + " " + i); sum += i; &#125; return sum; &#125;&#125; 线程的生命周期 1、新建状态 用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态（runnable）。 2、就绪状态 处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为cpu的调度不一定是按照先进先出的顺序来调度的），等待系统为其分配CPU。等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“cpu调度”。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。 提示：如果希望子线程调用start()方法后立即执行，可以使用Thread.sleep()方式使主线程睡眠一伙儿，转去执行子线程。 3、运行状态 处于就绪状态的线程，如果获得了cpu的调度，就会从就绪状态变为运行状态，执行run()方法中的任务。 运行状态-&gt;就绪状态：1.失去cpu资源 2.调用yield()方法 运行状态-&gt;阻塞状态： 1.调用sleep()方法主动放弃cpu资源 2.线程调用一个阻塞式IO方法，在该方法返回之前，线程被阻塞 3.线程试图获取一个同步监视器（锁），但该同步监视器正被其他线程所持有 4.线程在等待某个通知（notify） 5.程序调用线程的suspend方法被线程挂起（容易导致死锁） 4、阻塞状态 只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的I/O设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行。 5、死亡状态 当线程的run()方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。 线程管理1、线程睡眠sleep 让当前正在执行的线程暂停一段时间，并进入阻塞状态，且当前线程不会失去锁 sleep是静态方法，最好不要用Thread的实例对象调用它，因为它睡眠的始终是当前正在运行的线程，而不是调用它的线程对象，它只对正在运行状态的线程对象有效 123456789101112public class Test1 &#123; public static void main(String[] args) throws InterruptedException &#123; System.out.println(Thread.currentThread().getName()); MyThread myThread=new MyThread(); myThread.start(); myThread.sleep(1000);//这里sleep的就是main线程，而非myThread线程 Thread.sleep(10); for(int i=0;i&lt;100;i++)&#123; System.out.println("main"+i); &#125; &#125; &#125; 使用sleep方法之后，线程是进入阻塞状态的，只有当睡眠的时间结束，才会重新进入到就绪状态，而就绪状态进入到运行状态，是由系统控制的，我们不可能精准的去干涉它，所以如果调用Thread.sleep(1000)使得线程睡眠1秒，可能结果会大于1秒。 2、线程让步yield() yield()方法和sleep()方法有点相似，它也是Thread类提供的一个静态的方法，它也可以让当前正在执行的线程暂停，让出cpu资源给其他的线程。但是和sleep()方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。 3、线程合并join() 线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，应用场景是当一个线程必须等待另一个线程执行完毕才能执行时，Thread类提供了join方法来完成这个功能，它不是静态方法。从上面的方法的列表可以看到，它有3个重载的方法： 123456void join() 当前线程等该加入该线程后面，等待该线程终止。 void join(long millis) 当前线程等待该线程终止的时间最长为 millis 毫秒。 如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度 void join(long millis,int nanos) 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度 4、设置线程优先级 每个线程默认的优先级都与创建它的父线程具有相同的优先级，在默认情况下，main线程具有普通优先级。 12345MAX_PRIORITY =10MIN_PRIORITY =1NORM_PRIORITY =5 注：虽然Java提供了10个优先级别，但这些优先级别需要操作系统的支持。不同的操作系统的优先级并不相同，而且也不能很好的和Java的10个优先级别对应。所以我们应该使用MAX_PRIORITY、MIN_PRIORITY和NORM_PRIORITY三个静态常量来设定优先级，这样才能保证程序最好的可移植性。 5、后台(守护)线程 JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。 守护线程的用途为： ​ • 守护线程通常用于执行一些后台作业，例如在应用程序运行时播放背景音乐，在文字编辑器里做自动语法检查、自动保存等功能。 ​ • Java的垃圾回收也是一个守护线程。守护线的好处就是你不需要关心它的结束问题。例如你在你的应用程序运行的时候希望播放背景音乐，如果将这个播放背景音乐的线程设定为非守护线程，那么在用户请求退出的时候，不仅要退出主线程，还要通知播放背景音乐的线程退出；如果设定为守护线程则不需要了。 123456789public final void setDaemon(boolean on) 将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。 该方法必须在启动线程前调用。 该方法首先调用该线程的 checkAccess 方法，且不带任何参数。这可能抛出 SecurityException（在当前线程中）。 参数： on - 如果为 true，则将该线程标记为守护线程。 抛出： IllegalThreadStateException - 如果该线程处于活动状态。 SecurityException - 如果当前线程无法修改该线程。 6、正确结束线程 Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！想要安全有效的结束一个线程，可以使用下面的方法： ​ • 正常执行完run方法，然后结束掉； ​ • 控制循环条件和判断条件的标识符来结束掉线程。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM之内存区域]]></title>
    <url>%2F2019%2F05%2F26%2Fjvm%2FJVM%E4%B9%8B%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[JVM之内存区域 了解如何通过参数来控制各区域的内存大小 控制参数： -Xms：设置堆的最小空间大小。 -Xmx：设置堆的最大空间大小。 -XX:NewSize：设置新生代最小空间大小。 -XX:MaxNewSize：设置新生代最大空间大小。 -XX:PermSize：设置永久代最小空间大小。 -XX:MaxPermSize：设置永久代最大空间大小。 -Xss：设置每个线程的堆栈大小。 没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。 老年代空间大小=堆空间大小-年轻代大空间大小 程序计数器(program counter register)程序计数器的作用： 当前线程所执行的字节码的行号指示器，字节码的解析工作就是通过改变这个计数器的值来选取下一个需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。（线程私有的） 程序计数器的记录内容： 如果线程正在执行一个java方法，则程序计数器里面记录着正在执行的虚拟机字节码指令的地址； 如果正在执行的是native方法，则程序计数器里面为null。 特殊例子： 此内存区域是唯一一个在java虚拟机规范中没有OutOfMemoryError情况的区域。 java虚拟机栈(JVM Stacks)生命周期：与线程相同，线程私有。 虚拟机栈描述的是java方法执行的内存模型。 JVM栈的作用：每个方法被执行的时候，都会同时创建一个栈帧(stack frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法被调用至执行完成的过程，其实就是一个栈帧从入栈到出栈的过程。 局部变量表存放了的内容： 存放着编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。 理解性内容： 其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 该区域的异常状况： 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常； 如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。 本地方法栈(native method stacks)本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。 java堆(java heap)对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。（线程共享） Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。 作用：此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。 如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细分年轻代的有Eden空间、From Survivor空间、To Survivor空间等。(默认比例8:1:1)（详情在GC算法和回收中提到） 理解性： 根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。 异常状况： 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 方法区(method area)方法区和Java堆一样，是各个线程共享的内存区域 作用：它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。 这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载 异常状况： 根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。 运行时常量池(runtime constant pool)运行时的常量池属于方法区的一部分。 作用：用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。编译器和运行期(String 的 intern() )都可以将常量放入池中。 异常状况 当常量池无法再申请到内存时会抛出OutOfMemoryError 异常。 直接内存(direct memory)直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现。 本机直接内存的分配不会受到Java 堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括RAM 及SWAP 区或者分页文件）的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。 对象访问Object obj = new Object(); 最简单的访问，却涉及Java 栈、Java 堆、方法区这三个最重要内存区 假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java 栈的本地变量表中，作为一个reference 类型数据出现。 “new Object()”这部分的语义将会反映到Java 堆中，形成一块存储了Object 类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。 在Java 堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。 由于reference 类型在Java 虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java 堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。 如果使用句柄访问方式，Java 堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息 如果使用直接指针访问方式，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference 中直接存储的就是对象地址 使用句柄访问方式的最大好处就是reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference 本身不需要被修改。 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。 就主要虚拟机Sun HotSpot 而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。 OutOfMemoryError分析(OOM)java堆溢出 1java.lang.OutOfMemoryError：Java heap space java栈溢出 1java.lang.StackOverflowError 运行时常量池溢出 1java.lang.OutOfMemoryError：PermGen space 方法区溢出 1java.lang.OutOfMemoryError：PermGen space 本机直接内存溢出 1java.lang.OutOfMemoryError]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM之垃圾收集器与内存分配]]></title>
    <url>%2F2019%2F05%2F26%2Fjvm%2FJVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[JVM之垃圾收集器与内存分配垃圾回收区域： 程序计数器、虚拟机栈、本地方法栈 3 个区域随线程生灭(因为是线程私有)，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。 而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期才知道那些对象会创建，这部分内存的分配和回收都是动态的，垃圾回收期所关注的就是java堆和方法区。 判断对象死活引用计数法： 给对象添加一个引用计数器。但是难以解决循环引用问题。 对象objA和objB都有字段instance，赋值令objA.instance = objB及objB.instance = objA，除此以外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0,如果不下小心直接把 Obj1-reference 和 Obj2-reference 置 null。则在 Java 堆当中的两块内存依然保持着互相引用无法回收。 可达性分析(根搜索算法)： 通过一系列的 ‘GC Roots’ 的对象作为起始点，从这些节点出发所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连的时候说明对象不可用。 可作为 GC Roots 的对象： 虚拟机栈(栈帧中的本地变量表)中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中 JNI(即一般说的 Native 方法) 引用的对象 引用的类别： 强引用：类似于 Object obj = new Object(); 创建的，只要强引用在就不回收。 软引用：SoftReference 类实现软引用。在系统要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。 弱引用：WeakReference 类实现弱引用。对象只能生存到下一次垃圾收集之前。在垃圾收集器工作时，无论内存是否足够都会回收掉只被弱引用关联的对象。 虚引用：PhantomReference 类实现虚引用。无法通过虚引用获取一个对象的实例，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 回收方法区在堆中，尤其是在新生代中，一次垃圾回收一般可以回收 70% ~ 95% 的空间，而永久代的垃圾收集效率远低于此。 永久代垃圾回收主要两部分内容：废弃的常量和无用的类。 判断废弃常量：一般是判断没有该常量的引用。 判断无用的类：要以下三个条件都满足 该类所有的实例都已经回收，也就是 Java 堆中不存在该类的任何实例 加载该类的 ClassLoader 已经被回收 该类对应的 java.lang.Class 对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法 垃圾回收算法标记-清除算法： 标记所有需要回收的对象，标记完成后统一进行回收被标记的对象 缺点： 效率不高 空间产生大量碎片 复制算法： 思路：把空间分成两块，每次只对其中一块进行 GC。当这块内存使用完时，就将还存活的对象复制到另一块上面。 解决前一种方法的不足，但是会造成空间利用率低下。因为大多数新生代对象都不会熬过第一次 GC。所以没必要 1 : 1 划分空间。可以分一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另一块 Survivor 上，最后清理 Eden 和 Survivor 空间。大小比例一般是 8 : 1 : 1，每次浪费 10% 的 Survivor 空间。 但是这里有一个问题就是如果存活的大于 10% 怎么办？这里采用一种分配担保策略：多出来的对象直接进入老年代。 标记-整理算法： 与标记-清除算法不同的一点是，会把存活对象移动一端，解决空间产生大量碎片的缺点。 分代收集算法： 当前商业虚拟机的垃圾收集都采用分代收集算法。 把java堆分成新生代和老年代，根据各个年代的特点采用最合适的收集算法。 在新生代中，每次垃圾回收时都发现大批对象死去，只有少量存活，选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。 在老年代中，对象存活率高，没有额外空间对他进行分配担保，就使用标记清除或者标记整理算法回收。 垃圾收集器 说明：如果两个收集器之间存在连线说明他们之间可以搭配使用。 serial收集器 这是一个单线程收集器。意味着它只会使用一个 CPU 或一条收集线程去完成收集工作，并且在进行垃圾回收时必须暂停其它所有的工作线程直到收集结束。 ParNew收集器 Serial 收集器的多线程版本，许多运行在server模式下的虚拟机中首选的新生代收集器，原因是处理Serial收集器，只有它能与CMS收集器配合工作(真正意义上的并发收集器，实现让垃圾收集线程和用户线程同时工作) Parallel Scavenge收集器 并行和并发区别： 并行(Parallel)：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态 并发(Concurrent)：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户线程继续运行，而垃圾收集程序运行于另一个CPU上。 这是一个新生代收集器，也是使用复制算法实现，同时也是并行的多线程收集器。 CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程所停顿的时间，而 Parallel Scavenge 收集器的目的是达到一个可控制的吞吐量(Throughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间) )。 Parallel Scavenge收集器提供两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数和直接设置吞吐量大小的-XX:GCTimeRatio参数。 -XX:MaxGCPauseMillis：允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过设定值。GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的(并不是把参数设置越小越好) -XX:GCTimeRatio：是一个大于0小于100的整数，是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。 -XX:+UserAdaptiveSIzePolicy：作为一个吞吐量优先的收集器，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整停顿时间。这就是 GC 的自适应调整策略(GC Ergonomics)。 Serial Old收集器 收集器的老年代版本，单线程，使用 标记 —— 整理。 Parallel Old收集器 Parallel Old 是 Parallel Scavenge 收集器的老年代版本。多线程，使用 标记 —— 整理 CMS收集器 CMS (Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器。基于 标记 —— 清除 算法实现。 运作步骤： 初始标记(CMS initial mark)：标记 GC Roots 能直接关联到的对象 并发标记(CMS concurrent mark)：进行 GC Roots Tracing(根搜索算法) 重新标记(CMS remark)：修正并发标记期间的变动部分 并发清除(CMS concurrent sweep) 其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）。 优点: 并发收集、低停顿缺点: 对 CPU 资源敏感、无法收集浮动垃圾、标记 —— 清除 算法带来的空间碎片 G1收集器 G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点： 空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。 可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。 上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（物理可以不连续、逻辑连续的一段内存）Region的集合。 G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。 收集步骤： 1、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark) 2、Root Region Scanning根区域扫描，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。 3、Concurrent Marking并发标记，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。 4、Remark, 最终标记，会有短暂停顿(STW:stop the world)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。 5、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。 6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。 内存分配与回收策略对象的内存分配，往大方向上讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地在栈上分配），对象主要分配在新生代的Eden区上，如果启动本地线程分配缓冲(TLAB)，将线程上优先在TLAB上分配少数情况下也可能会直接分配在老年代中，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数配置。 对象优先在Eden分配 对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲区，将线程优先在 (TLAB) 上分配。少数情况会直接分配在老年代中。 新生代和老年代： 新生代GC(minor GC)：发生在新生代的垃圾回收动作，频繁，速度快。 老年代GC(Major GC / Full GC)：发生在老年代的垃圾回收动作，出现了 Major GC 经常会伴随至少一次 Minor GC(非绝对)。Major GC 的速度一般会比 Minor GC 慢十倍以上。 大对象直接进入老年代 大对象指的是需要大量连续内存空间的java对象，最典型的大对象是那种很长字符串及数组(byte[]数组就是典型大对象) 虚拟机提供一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代中分配。目的是避免在Eden区及两个Survivor区之间发生大量的内存拷贝。 长期存活的对象直接进入老年代 虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。 动态对象年龄判断 如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。 空间分配担保 每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM之类的加载机制]]></title>
    <url>%2F2019%2F05%2F26%2Fjvm%2FJVM%E4%B9%8B%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[JVM之类的加载机制什么是类的加载类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的 Class对象。 Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。 类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。 加载.class文件的方式 从本地系统中直接加载 通过网络下载.class文件 从zip，jar等归档文件中加载.class文件 从专有数据库中提取.class文件 将Java源文件动态编译为.class文件 类的生命周期 其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。 加载在加载阶段，虚拟机需要完成以下三件事情： 通过一个类的全限定名来获取其定义的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在Java堆中生成一个代表这个类的 java.lang.Class对象，作为对方法区中这些数据的访问入口。 连接验证：确保被加载的类的正确性 验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作： 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以 0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object之外。 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 准备：为类的静态变量分配内存，并将其初始化为默认值 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意： 1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。 2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。 假设一个类变量的定义为： public static int value=3； 那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的 public static指令是在程序编译后，存放于类构造器 &lt;clinit&gt;（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。 1234567891011这里还需要注意如下几点：1、对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。2、对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。3、对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。4、如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。一句话总结以上几点，类变量、引用数据类型赋予默认值，常量、局部变量必须在声明或者初始化之前显示赋值，不然不通过编译 3、如果类字段的字段属性表中存在 ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。 假设上面的类变量value被定义为： public static final int value=3； 编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据 ConstantValue的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中 解析：把类中的符号引用转换为直接引用 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 初始化初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式： ①声明类变量是指定初始值 ②使用静态代码块为类变量指定初始值 JVM初始化步骤： 1、假如这个类还没有被加载和连接，则程序先加载并连接该类 2、假如该类的直接父类还没有被初始化，则先初始化其直接父类 3、假如类中有初始化语句，则系统依次执行这些初始化语句 类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种： 创建类的实例，也就是new的方式 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（如 Class.forName(“com.shengsiyuan.Test”)） 初始化某个类的子类，则其父类也会被初始化 Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类 结束生命周期在如下几种情况下，Java虚拟机将结束生命周期 执行了 System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止 类加载器 站在Java开发人员的角度来看，类加载器可以大致划分为以下三类： 启动类加载器： BootstrapClassLoader，负责加载存放在 JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被 -Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被 BootstrapClassLoader加载）。启动类加载器是无法被Java程序直接引用的。扩展类加载器： ExtensionClassLoader，该加载器由 sun.misc.Launcher$ExtClassLoader实现，它负责加载 JDK\jre\lib\ext目录中，或者由 java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。应用程序类加载器： ApplicationClassLoader，该类加载器由 sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点： 1、在执行非置信代码之前，自动验证数字签名。 2、动态地创建符合用户特定需要的定制化构建类。 3、从特定的场所取得java class，例如数据库中和网络中。 JVM加载机制 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效 类的加载三种方式： 1、命令行启动应用时候由JVM初始化加载 2、通过Class.forName()方法动态加载 3、通过ClassLoader.loadClass()方法动态加载 Class.forName()和ClassLoader.loadClass()区别 Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块； ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。 Class.forName(name,initialize,loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。 双亲委派模型双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 双亲委派机制: 1、当 AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。 2、当 ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader`去完成。 3、如果 BootStrapClassLoader加载失败（例如在 $JAVA_HOME/jre/lib里未查找到该class），会使用 ExtClassLoader来尝试加载； 4、若ExtClassLoader也加载失败，则会使用 AppClassLoader来加载，如果 AppClassLoader也加载失败，则会报出异常 ClassNotFoundException。 ClassLoader源码分析： 双亲委派模型意义： 系统类防止内存中出现多份同样的字节码 保证Java程序安全稳定运行]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程(二)]]></title>
    <url>%2F2019%2F05%2F26%2F%E5%B9%B6%E5%8F%91%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B2%2F</url>
    <content type="text"><![CDATA[多线程(二)线程同步java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。 1、同步方法 即有synchronized关键字修饰的方法。由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。 public synchronized void save(){} 注： synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类 2、同步代码块 即有synchronized关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。 12345678910111213141516171819202122232425public class Bank &#123; private int count = 0;//账户余额 //存钱 public void addMoney(int money)&#123; synchronized (this) &#123; count +=money; &#125; System.out.println(System.currentTimeMillis()+"存进："+money); &#125; //取钱 public void subMoney(int money)&#123; synchronized (this) &#123; if(count-money &lt; 0)&#123; System.out.println("余额不足"); return; &#125; count -= money; &#125; System.out.println(+System.currentTimeMillis()+"取出："+money); &#125; //查询 public void lookMoney()&#123; System.out.println("账户余额："+count); &#125; &#125; 同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。 3、使用特殊域变量（volatile）实现线程同步 volatile关键字为域变量的访问提供了一种免锁机制 使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新 每次使用该域就要重新计算，而不是使用寄存器中的值； volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class SynchronizedThread &#123; class Bank &#123; private volatile int account = 100; public int getAccount() &#123; return account; &#125; /** * 用同步方法实现 * * @param money */ public synchronized void save(int money) &#123; account += money; &#125; /** * 用同步代码块实现 * * @param money */ public void save1(int money) &#123; synchronized (this) &#123; account += money; &#125; &#125; &#125; class NewThread implements Runnable &#123; private Bank bank; public NewThread(Bank bank) &#123; this.bank = bank; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; // bank.save1(10); bank.save(10); System.out.println(i + "账户余额为：" +bank.getAccount()); &#125; &#125; &#125; /** * 建立线程，调用内部类 */ public void useThread() &#123; Bank bank = new Bank(); NewThread new_thread = new NewThread(bank); System.out.println("线程1"); Thread thread1 = new Thread(new_thread); thread1.start(); System.out.println("线程2"); Thread thread2 = new Thread(new_thread); thread2.start(); &#125; public static void main(String[] args) &#123; SynchronizedThread st = new SynchronizedThread(); st.useThread(); &#125;&#125; 多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。用final域，有锁保护的域和volatile域可以避免非同步的问题。 4、使用重入锁(Lock)实现线程同步 在javaSE5.0中新增了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和块具有相同的基本行为和语义，并且扩展了其能力。ReenreantLock类的常用方法有： 123ReentrantLock() : 创建一个ReentrantLock实例 lock() : 获得锁 unlock() : 释放锁 ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用 123456789101112131415161718//只给出要修改的代码，其余代码与上同 class Bank &#123; private int account = 100; //需要声明这个锁 private Lock lock = new ReentrantLock(); public int getAccount() &#123; return account; &#125; //这里不再需要synchronized public void save(int money) &#123; lock.lock(); try&#123; account += money; &#125;finally&#123; lock.unlock(); &#125; &#125; ｝ 线程通信1、借助于Object类的wait()、notify()和notifyAll()实现通信 线程执行wait()后，就放弃了运行资格，处于冻结状态； ​ 线程运行时，内存中会建立一个线程池，冻结状态的线程都存在于线程池中，notify()执行时唤醒的也是线程池中的线程，线程池中有多个线程时唤醒第一个被冻结的线程。notifyAll(), 唤醒线程池中所有线程。注： （1） wait(), notify(),notifyAll()都用在同步里面，因为这3个函数是对持有锁的线程进行操作，而只有同步才有锁，所以要使用在同步中；​ （2） wait(),notify(),notifyAll(), 在使用时必须标识它们所操作的线程持有的锁，因为等待和唤醒必须是同一锁下的线程；而锁可以是任意对象，所以这3个方法都是Object类中的方法。 单个消费者生产者例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Resource&#123; //生产者和消费者都要操作的资源 private String name; private int count=1; private boolean flag=false; public synchronized void set(String name)&#123; if(flag) try&#123;wait();&#125;catch(Exception e)&#123;&#125; this.name=name+"---"+count++; System.out.println(Thread.currentThread().getName()+"...生产者..."+this.name); flag=true; this.notify(); &#125; public synchronized void out()&#123; if(!flag) try&#123;wait();&#125;catch(Exception e)&#123;&#125; System.out.println(Thread.currentThread().getName()+"...消费者..."+this.name); flag=false; this.notify(); &#125; &#125; class Producer implements Runnable&#123; private Resource res; Producer(Resource res)&#123; this.res=res; &#125; public void run()&#123; while(true)&#123; res.set("商品"); &#125; &#125; &#125; class Consumer implements Runnable&#123; private Resource res; Consumer(Resource res)&#123; this.res=res; &#125; public void run()&#123; while(true)&#123; res.out(); &#125; &#125; &#125; public class ProducerConsumerDemo&#123; public static void main(String[] args)&#123; Resource r=new Resource(); Producer pro=new Producer(r); Consumer con=new Consumer(r); Thread t1=new Thread(pro); Thread t2=new Thread(con); t1.start(); t2.start(); &#125; &#125;//运行结果正常，生产者生产一个商品，紧接着消费者消费一个商品。 ​ 但是如果有多个生产者和多个消费者，上面的代码就会有问题，比如2个生产者，2个消费者，运行结果就可能出现生产的1个商品生产了一次而被消费了2次，或者连续生产2个商品而只有1个被消费，这是因为此时共有4个线程在操作Resource对象r, 而notify()唤醒的是线程池中第1个wait()的线程，所以生产者执行notify()时，唤醒的线程有可能是另1个生产者线程，这个生产者线程从wait()中醒来后不会再判断flag，而是直接向下运行打印出一个新的商品，这样就出现了连续生产2个商品。 1234567891011121314151617181920212223242526272829303132333435class Resource&#123; private String name; private int count=1; private boolean flag=false; public synchronized void set(String name)&#123; while(flag) /*原先是if,现在改成while，这样生产者线程从冻结状态醒来时，还会再判断flag.*/ try&#123;wait();&#125;catch(Exception e)&#123;&#125; this.name=name+"---"+count++; System.out.println(Thread.currentThread().getName()+"...生产者..."+this.name); flag=true; this.notifyAll();/*原先是notity(), 现在改成notifyAll(),这样生产者线程生产完一个商品后可以将等待中的消费者线程唤醒，否则只将上面改成while后，可能出现所有生产者和消费者都在wait()的情况。*/ &#125; public synchronized void out()&#123; while(!flag) /*原先是if,现在改成while，这样消费者线程从冻结状态醒来时，还会再判断flag.*/ try&#123;wait();&#125;catch(Exception e)&#123;&#125; System.out.println(Thread.currentThread().getName()+"...消费者..."+this.name); flag=false; this.notifyAll(); /*原先是notity(), 现在改成notifyAll(),这样消费者线程消费完一个商品后可以将等待中的生产者线程唤醒，否则只将上面改成while后，可能出现所有生产者和消费者都在wait()的情况。*/ &#125; &#125; public class ProducerConsumerDemo&#123; public static void main(String[] args)&#123; Resource r=new Resource(); Producer pro=new Producer(r); Consumer con=new Consumer(r); Thread t1=new Thread(pro); Thread t2=new Thread(con); Thread t3=new Thread(pro); Thread t4=new Thread(con); t1.start(); t2.start(); t3.start(); t4.start(); &#125; &#125; 2、使用Condition控制线程通信 ​]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String和包装类的equals和==]]></title>
    <url>%2F2019%2F05%2F26%2F%E9%9B%B6%E6%95%A3%E8%AE%B0%2FString%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84equals%E5%92%8C%3D%3D%2F</url>
    <content type="text"><![CDATA[StringString对象创建两种方式： 第一种方式是在常量池中拿对象； 第二种方式是直接在堆内存空间创建一个新的对象。 String 类型的常量池比较特殊。它的主要使用方法有两种： 直接使用双引号声明出来的 String 对象会直接存储在常量池中。 如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用。 123456String s1 = new String("计算机");String s2 = s1.intern();String s3 = "计算机";System.out.println(s2);//计算机System.out.println(s1 == s2);//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，System.out.println(s3 == s2);//true，因为两个都是常量池中的 String 对象 字符串拼接 123456789String str1 = "str";String str2 = "ing";String str3 = "str" + "ing";//常量池中的对象String str4 = str1 + str2; //在堆上创建的新的对象 String str5 = "string";//常量池中的对象System.out.println(str3 == str4);//falseSystem.out.println(str3 == str5);//trueSystem.out.println(str4 == str5);//false 1234567891011121314151617181920212223public class IntegerTest &#123; public static void main(String[] args) &#123; String a = "123"; String b = new String("123"); String c = "1"+"23"; String d = "1"+new String("23"); String e = new String("1")+new String("23"); String f = "1"; String h = "23"; String i = f+h; System.out.println(a==b);//false System.out.println(a==c);//true System.out.println(a==d);//false System.out.println(a==e);//false System.out.println(b==d);//false System.out.println(b==e);//false System.out.println(d==e);//false System.out.println("------------------------------"); System.out.println(a==i);//false System.out.println(b==i);//false &#125;&#125; 只要涉及到对象引用如上f、h或者其中new一个，整体都会new一个对象，所以都是false 包装类 Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；这 5 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 为啥把缓存设置为[-128，127]区间？性能和资源之间的权衡。 两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。 123456Integer i1 = 33;Integer i2 = 33;System.out.println(i1 == i2);// 输出 trueInteger i11 = 333;Integer i22 = 333;System.out.println(i11 == i22);// 输出 false Integer 缓存源代码： 12345678/***此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。*/ public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 应用场景： Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。 Integer i1 = new Integer(40);这种情况下会创建新的对象。 123Integer i1 = 40;Integer i2 = new Integer(40);System.out.println(i1==i2);//输出 false Integer 比较更丰富的一个例子: 12345678910111213Integer i1 = 40;Integer i2 = 40;Integer i3 = 0;Integer i4 = new Integer(40);Integer i5 = new Integer(40);Integer i6 = new Integer(0);System.out.println("i1=i2 " + (i1 == i2));System.out.println("i1=i2+i3 " + (i1 == i2 + i3));System.out.println("i1=i4 " + (i1 == i4));System.out.println("i4=i5 " + (i4 == i5));System.out.println("i4=i5+i6 " + (i4 == i5 + i6)); System.out.println("40=i5+i6 " + (40 == i5 + i6)); 结果： 123456i1=i2 truei1=i2+i3 truei1=i4 falsei4=i5 falsei4=i5+i6 true40=i5+i6 true 解释： 语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。 12345678910111213141516171819202122232425262728293031public class IntegerTest &#123; public static void main(String[] args) &#123; Integer a = 40; Integer b = new Integer(40); Integer c = 10+30; Integer d = 10+new Integer(30); Integer e = new Integer(10)+new Integer(30); Integer f = 10; Integer h = 30; Integer i = f+h; int j = 40; System.out.println(a==b);//false System.out.println(a==c);//true System.out.println(a==d);//true System.out.println(a==e);//true System.out.println(b==c);//false System.out.println(b==d);//false System.out.println(b==e);//false System.out.println(d==e);//true System.out.println("------------------------------"); System.out.println(a==i);//true System.out.println(b==i);//false System.out.println(c==i);//true System.out.println(d==i);//true System.out.println(e==i);//true System.out.println(a==j);//true System.out.println(b==j);//true &#125;&#125; 包装类需要考虑自动拆箱问题，当有加减操作时候，就会自动拆箱，相当于在常量池中创建 equals方法比较内容，所以都相等]]></content>
      <categories>
        <category>零散记</category>
      </categories>
      <tags>
        <tag>零散记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[占用多少个字节数]]></title>
    <url>%2F2019%2F05%2F26%2F%E9%9B%B6%E6%95%A3%E8%AE%B0%2F%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AD%97%E8%8A%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[不同的字符需要看不同的编码，char 字符占2个字节，默认unicode 中文 英文 unicode 2（还需要额外加多2个字节） 2（还需要额外加多2个字节） GBK 2 1 utf-8 3 1 utf-16 2（还需要额外加多2个字节） 2（还需要额外加多2个字节）]]></content>
      <categories>
        <category>零散记</category>
      </categories>
      <tags>
        <tag>零散记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sizeOf]]></title>
    <url>%2F2019%2F05%2F26%2F%E9%9B%B6%E6%95%A3%E8%AE%B0%2FsizeOf%2F</url>
    <content type="text"><![CDATA[https://www.cnblogs.com/qiulinzhang/p/9570867.html]]></content>
      <categories>
        <category>零散记</category>
      </categories>
      <tags>
        <tag>零散记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm在操作系统的哪个区域]]></title>
    <url>%2F2019%2F05%2F26%2F%E9%9B%B6%E6%95%A3%E8%AE%B0%2Fjvm%E5%9C%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%93%AA%E4%B8%AA%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[操作系统的基本结构 操作系统中的jvm 为什么jvm的内存是分布在操作系统的堆中呢？？因为操作系统的栈是操作系统管理的，它随时会被回收，所以如果jvm放在栈中，那java的一个null对象就很难确定会被谁回收了，那gc的存在就一点意义都没有了，而要对栈做到自动释放也是jvm需要考虑的，所以放在堆中就最合适不过了。 操作系统+jvm的内存简单布局 jvm的设计的模型其实就是操作系统的模型，基于操作系统的角度，jvm也就是一个应用（java.exe/javaw.exe），而基于class文件来说，jvm就是个操作系统，而jvm的方法区，也就相当于操作系统的硬盘区，所以方法区也被叫做permanent区，因为这个单词是永久的意思，也就是永久区。而java栈和操作系统栈是一致的，无论是生长方向还是管理的方式，至于堆，虽然概念上一致目标也一致，分配内存的方式也一直(new,或者malloc等等)，但是由于他们的管理方式不同，jvm是gc回收，而操作系统是程序员手动释放，所以在算法上有很多的差异. 看下面的图。 将这个图和上面的图对比多了什么？没错，多了一个pc寄存器，所谓pc寄存器，无论是在虚拟机中还是在我们虚拟机所寄宿的操作系统中功能目的是一致的，计算机上的pc寄存器是计算机上的硬件，本来就是属于计算机，计算机用pc寄存器来存放“伪指令”或地址，而相对于虚拟机，pc寄存器它表现为一块内存(一个字长，虚拟机要求字长最小为32位)，虚拟机的pc寄存器的功能也是存放伪指令，更确切的说存放的是将要执行指令的地址，它甚至可以是操作系统指令的本地地址，当虚拟机正在执行的方法是一个本地方法的时候，jvm的pc寄存器存储的值是undefined，所以虚拟机的pc寄存器是用于存放下一条将要执行的指令的地址(字节码流)。 这个图是要告诉你，当一个classLoder启动的时候，classLoader的生存地点在jvm中的堆，然后它会去主机硬盘上将A.class装载到jvm的方法区，方法区中的这个字节文件会被虚拟机拿来new A字节码()，然后在堆内存生成了一个A字节码的对象，然后A字节码这个内存文件有两个引用一个指向A的class对象，一个指向加载自己的classLoader如下图。 ————————————————版权声明：本文为CSDN博主「Kevinten10」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/wsh596823919/article/details/82669460 https://blog.csdn.net/yfqnihao/article/details/8289363]]></content>
      <categories>
        <category>零散记</category>
      </categories>
      <tags>
        <tag>零散记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC知识总结]]></title>
    <url>%2F2019%2F05%2F26%2FJavaEE%2FJDBC%2FJDBC%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[JDBC知识总结JDBC的接口和类JDBC API主要位于java.sql包中，关键的接口和类包括以下几种。 类/接口 描述 Driver接口、DriverManager类 前者表示驱动器、后者表示驱动管理器 Connection接口 表示数据库的链接 Statement接口 负责执行SQL语句 PreparedStatement接口 负责执行预备的SQL语句 CallableStatement接口 负责执行SQL存储过程 ResultSet接口 表示SQL查询语句返回的结果集 JDBC步骤1、注册驱动 2、获取与数据库的链接 3、创建代表SQL语句的对象 4、执行SQL语句 5、如果是查询语句，需要遍历结果集 6、释放占用的资源 DriverManager接口和DriverManager类DriverManager类用来建立和数据库的连接及管理JDBC驱动器。DriverManager类的方法都是静态的，主要包括以下几种 类/接口 描述 registerDriver（Driver driver） 在DriverManeger中注册JDBC驱动器 getConnection(String url,String user,String password) 建立和数据的连接 setLoginTime（int seconds） 设定等待建立数据连接的超时时间 setlogWriter（PrintWriter out） 设定输出JDBC日志的PrintWriter对象 1234567891011//注册数据库的驱动Class.forName("com.MySQL.jdbc.Driver"); //创建数据库的链接信息(指定要连接那个数据库)：数据库路径、数据库的账号和密码String url = "jdbc:mysql://localhost:3306/dataBase_Name";//jdbc:数据库://ip地址:端口号;数据库名 String username = "root";String password = "123456"; //连接数据库，返回连接结果，该结果的类型是ConnectionConnection conn = DriverManager.getConnection(url,username,password);//获得连接 注意，上面代码可能出现的两种异常： 1、ClassNotFoundException：这个异常是在加载数据库驱动的时候，出现这个异常有两个可能： ​ a、检查是否导入了Mysql的jar包 ​ b、将数据库的驱动名打错，检查是否是com.MySQL.jdbc.Driver 2、SQLException：这个异常出现在连接数据库的过程，出现这个异常就是三个参数的问题。 Class.forName(“com.mysql.jdbc.Driver”)和DriverManager.registerDriver(new com.mysql.jdbc.Driver())的区别 Class.forName(“com.mysql.jdbc.Driver”)的源码 123456789static &#123; try &#123; DriverManager.registerDriver(new Driver());//静态代码块，加载即初始化 &#125; catch (SQLException E) &#123; throw new RuntimeException("Can't register driver!"); &#125; &#125; DriverManager.registerDriver(new com.mysql.jdbc.Driver()) Driver类的静态代码块会注册一次，那么此时new Driver的时候就会注册一次，然后外层又会注册一次，所以注册了两次驱动(加载一次、初始化一次) connection接口Connection接口代表Java程序和数据库的连接，主要包括以下方法。 类/接口 描述 getMetaData（） 返回表示数据库的元数据的DatabaseMetaData对象，元数据包含了描述数据库的相关信息 createStatement（） 创建并返回Statement对象 prepareStatement（） 创建并返回prepareStatement对象 Connection最为重要的方法就是获取Statement或者prepareStatement对象 1234567//Statement的用法Statement st = conn.createStatement(sql);ResultSet rs = stmt.executeQuery(); //prepareStatement的用法PreparedStatement ps = conn.prepareStatement(sql);ResultSet rs = ps.executeQuery(); Statement接口Statement接口提供了3个执行SQL语句的方法 类/接口 描述 execute（String sql） 执行各种SQL语句，该方法返回一个boolean类型的值。该方法返回的是boolean类型，表示SQL语句是否有结果集。 如果执行的是更新语句，那么还要调用int getUpdateCount()来获取insert、update、delete语句所影响的行数。 如果执行的是查询语句，那么还要调用ResultSet对象的getResultSet()来获取select语句的查询结果。 | | executeUpdate（String sql） | 执行SQL的insert、update和delet**等语句，适用于不需要返回结果的SQL语句。该方法返回一个int类型的值，表示数据库中受该SQL语句影响的记录的数目。 || executeQuery（String sql） | 执行SQL的select语句。查询操作会返回ResultSet对象，即结果集。 | PrepareStatement接口 PrepareStatement接口继承了Statement接口，用来执行准备的SQL语句。在访问数据库时，可能会遇到某条SQL语句被多次执行，但是其中的参数却不同的情况。 使用PrepareStatement，而不是Statement来执行SQL语句，这样做具有以下优点： 简化程序代码，是程序更加灵活。 123456//创建SQL语句String sql = "Select * From users Where name = ? And sex = ? And age = ?";//设置参数值ps.setString(1,"LaoYe"); //此处的1表示name中的?，而LaoYe表示name的值，下面同理ps.isBoolean(2,true);ps.setInt(3,18); 提高访问数据库的性能。PrepareStatement执行预准备的SQL语句，数据库只需对这种SQL语句编译一次，然后就可以多次执行。而每次用Statement执行SQL语句时，数据库都需要对该SQL语句进行编译。 123456789101112131415161718192021//1、创建SQL语句String sql = "Insert Into users(name,sex,age) Values(?,?,?)";//2、连接数据库，获取连接对象Connection conn = DriverManager.getConnection(url,account,password);//3、预准备SQL语句PrepareStatement ps = conn.prepareStatement(sql); //第一次插入ps.setString(1,"LaoYe"); //此处的1表示name中的?，而LaoYe表示name的值，下面同理ps.isBoolean(2,true);ps.setInt(3,18);ps.executeUpdate(); 第二次插入ps.setString(1,"LaoCheng"); //此处的1表示name中的?，而LaoYe表示name的值，下面同理ps.isBoolean(2,false);ps.setInt(3,18);ps.executeUpdate(); //结论：可以看出除了值，几乎是重复的，所以视情况可以循环插入，提高开发效率 作为 Statement 的子类，PreparedStatement 继承了 Statement 的所有功能。同时，三种方法 execute、 executeQuery 和 executeUpdate 已被更改以使之不再需要参数。 preparestatement预防SQL注入的原因： 因为sql语句是预编译的，而且语句中使用了占位符，规定了sql语句的结构。用户可以设置”?”的值，但是不能改变sql语句的结构，因此想在sql语句后面加上如“or 1=1”实现sql注入是行不通的。 ResultSet接口结果集对象。该对象包含访问查询结果的方法，ResultSet可以通过列索引或列名或得数据。 循环输出数据库信息： while(rs.next()){ System.out.println(rs.getString(1)); System.out.println(rs.getString(2)); System.out.println(rs.getString(3)); System.out.println(rs.getString(4));}]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>JavaEE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合类之List]]></title>
    <url>%2F2019%2F05%2F26%2Fjava%E9%9B%86%E5%90%88%E7%B1%BB%2F%E9%9B%86%E5%90%88%E7%B1%BB%E4%B9%8BList%2F%E9%9B%86%E5%90%88%E7%B1%BB%E4%B9%8BList%2F</url>
    <content type="text"><![CDATA[集合类之ListList接口扩展自Collection，定义一个允许重复的有序集合，从List接口中的方法来看，List接口主要是增加了面向位置的操作，允许在指定位置上操作元素，同时增加了一个能够双向遍历线性表的新列表迭代器ListIterator。List接口的两个重要的具体实现类，也是我们可能最常用的类，ArrayList和LinkedList。 1.ArrayList它是用数组存储元素的，这个数组可以动态创建，如果元素个数超过了数组的容量，那么就创建一个更大的新数组（通过移位运算符&gt;&gt;1扩大1倍再加上自己原本的容量即扩充1.5倍），并将当前数组中的所有元素都复制到新数组中。假设第一次是集合没有任何元素，下面以插入一个元素为例看看源码的实现。 123456789101112131415161718192021222324252627282930313233343536371、找到add()实现方法。 public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; 2、此方法主要是确定将要创建的数组大小。 private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);//取出两个较大的容量 &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++;//记录了结构性改变的次数。结构性改变指的是那些修改了列表大小的操作，在迭代过程中可能会造成错误的结果。 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; 3、最后是创建数组，可以明显的看到先是确定了添加元素后的大小之后将元素复制到新数组中。 private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//1.5倍扩容 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; ArrayList遍历三种方法 1、通过迭代器Iterator() 12345Iterator iter = list.iterator();while (iter.hasNext())&#123; System.out.println(iter.next());&#125; 2、随机访问，通过索引值去遍历。 12345int size = list.size();for (int i=0; i&lt;size; i++) &#123; System.out.println(list.get(i)); &#125; 3、for循环遍历 1234for(String str:list)&#123;System.out.println(str); &#125; ArrayList常见问题 1、ArrayList如何实现自动增加 当试图在arraylist中增加一个对象的时候，Java会去检查arraylist，以确保已存在的数组中有足够的容量来存储这个新的对象。如果没有足够容量的话，那么就会新建一个长度更长的数组，旧的数组就会使用Arrays.copyOf方法被复制到新的数组中去，现有的数组引用指向了新的数组。 2、当传递ArrayList到某个方法中，或者某个方法返回ArrayList，什么时候要考虑安全隐患？如何修复安全违规这个问题呢？ 当array被当做参数传递到某个方法中，如果array在没有被复制的情况下直接被分配给了成员变量，那么就可能发生这种情况，即当原始的数组被调用的方法改变的时候，传递到这个方法中的数组也会改变。 3、什么情况下你会使用ArrayList？什么时候你会选择LinkedList？ 多数情况下，当你遇到访问元素比插入或者是删除元素更加频繁的时候，你应该使用ArrayList。另外一方面，当你在某个特别的索引中，插入或者是删除元素更加频繁，或者你根本就不需要访问元素的时候，你会选择LinkedList。这里的主要原因是，在ArrayList中访问元素的最糟糕的时间复杂度是”1″，而在LinkedList中可能就是”n”了。在ArrayList中增加或者删除某个元素，通常会调用System.arraycopy方法，这是一种极为消耗资源的操作，因此，在频繁的插入或者是删除元素的情况下，LinkedList的性能会更加好一点。 System.arraycopy方法消耗资源原因： 123456789101112131415public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)代码解释: Object src : 原数组 int srcPos : 从元数据的起始位置开始 Object dest : 目标数组 int destPos : 目标数组的开始起始位置 int length : 要copy的数组的长度我们使用System.arraycopy进行转换(copy)System.arrayCopy(srcBytes,0,destBytes ,0,5)上面这段代码就是 : 创建一个一维空数组,数组的总长度为 12位,然后将srcBytes源数组中 从0位 到 第5位之间的数值 copy 到 destBytes目标数组中,在目标数组的第0位开始放置.那么这行代码的运行效果应该是 2,4,0,0,0,增加或者删除都要进行一次copy，消耗资源多。 4、如何复制某个ArrayList到另一个ArrayList中去？写出你的代码？ 下面就是把某个ArrayList复制到另一个ArrayList中去的几种技术： 使用clone()方法，比如ArrayList newArray = oldArray.clone(); 使用ArrayList构造方法，比如：ArrayList myObject = new ArrayList(myTempObject); 使用Collection的copy方法。 注意1和2是浅拷贝(shallow copy)。 浅拷贝和深拷贝区别： | 浅拷贝：只复制引用，另一处修改，你当下的对象也会修改。 | 深拷贝：引用对象的值等信息，复制一份一样的。 浅拷贝—能复制变量，如果对象内还有对象，则只能复制对象的地址（指针指向同一个内存空间） 深拷贝—能复制变量，也能复制当前对象的内部对象 利用序列化实现深拷贝 把对象写到流里的过程是序列化过程（Serialization），而把对象从流中读出来的过程则叫做反序列化过程（Deserialization）。 在Java语言里深复制一个对象，常常可以先使对象实现Serializable接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。 2.LinkedList 1、继承了AbstractSequentialList抽象类：在遍历LinkedList的时候，官方更推荐使用顺序访问，也就是使用我们的迭代器。（因为LinkedList底层是通过一个双向链表来实现的）（虽然LinkedList也提供了get（int index）方法，但是底层的实现是：每次调用get（int index）方法的时候，都需要从链表的头部或者尾部进行遍历，每一的遍历时间复杂度是O(index)，而相对比ArrayList的底层实现，每次遍历的时间复杂度都是O(1)。所以不推荐通过get（int index）遍历LinkedList。 至于上面的说从链表的头部后尾部进行遍历：官方源码对遍历进行了优化：通过判断索引index更靠近链表的头部还是尾部来选择遍历的方向）（所以这里遍历LinkedList推荐使用迭代器）。 2、实现了List接口。（提供List接口中所有方法的实现）实现了Cloneable接口，它支持克隆（浅克隆），底层实现：LinkedList节点并没有被克隆，只是通过Object的clone（）方法得到的Object对象强制转化为了LinkedList,然后把它内部的实例域都置空，然后把被拷贝的LinkedList节点中的每一个值都拷贝到clone中。 3、实现了Deque接口。实现了Deque所有的可选的操作。 4、实现了Serializable接口。表明它支持序列化。（和ArrayList一样，底层都提供了两个方法：readObject（ObjectInputStream o）、writeObject（ObjectOutputStream o），用于实现序列化，底层只序列化节点的个数和节点的值） 底层重要方法分析： addAll(int index, Collection） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 首先调用一下空的构造器。//然后调用addAll(c)方法。 public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125;//通过调用addAll(int index, Collection&lt;? extends E&gt; c) 完成集合的添加。 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125;//几乎所有的涉及到在指定位置添加或者删除或修改操作都需要判断传进来的参数是否合法。// checkPositionIndex(index)方法就起这个作用。 public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; checkPositionIndex(index);//先把集合转化为数组，然后为该数组添加一个新的引用（Objext[] a）。 Object[] a = c.toArray();//新建一个变量存储数组的长度。 int numNew = a.length;//如果待添加的集合为空，直接返回，无需进行后面的步骤。后面都是用来把集合中的元素添加到//LinkedList中。 if (numNew == 0) return false;//Node&lt;E&gt; succ：指代待添加节点的位置。//Node&lt;E&gt; pred：指代待添加节点的前一个节点。//下面的代码是依据新添加的元素的位置分为两个分支：//①新添加的元素的位置位于LinkedList最后一个元素的后面。//新添加的元素的位置位于LinkedList中。//如果index==size;说明此时需要添加LinkedList中的集合中的每一个元素都是在LinkedList//最后面。所以把succ设置为空，pred指向尾节点。//否则的话succ指向插入待插入位置的节点。这里用到了node（int index）方法，这个方法//后面会详细分析，这里只需要知道该方法返回对应索引位置上的Node（节点）。pred指向succ节点的前一个节点。 Node&lt;E&gt; pred, succ; if (index == size) &#123; succ = null; pred = last; &#125; else &#123; succ = node(index); pred = succ.prev; &#125;//接着遍历数组中的每个元素。在每次遍历的时候，都新建一个节点，该节点的值存储数组a中遍历//的值，该节点的prev用来存储pred节点，next设置为空。接着判断一下该节点的前一个节点是否为//空，如果为空的话，则把当前节点设置为头节点。否则的话就把当前节点的前一个节点的next值//设置为当前节点。最后把pred指向当前节点，以便后续新节点的添加。 for (Object o : a) &#123; @SuppressWarnings("unchecked") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125;//这里仍然和上面一样，分两种情况对待：//①当succ==null（也就是新添加的节点位于LinkedList集合的最后一个元素的后面），//通过遍历上面的a的所有元素，此时pred指向的是LinkedList中的最后一个元素，所以把//last指向pred指向的节点。//当不为空的时候，表明在LinkedList集合中添加的元素，需要把pred的next指向succ上，//succ的prev指向pred。//最后把集合的大小设置为新的大小。//modCount（修改的次数）自增。 if (succ == null) &#123; last = pred; &#125; else &#123; pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true; &#125; 虽然是增加一个集合的元素，但是modCount只增加了一次 将LinkedList写入到流中。（也就是把LinkedList状态保存到流中）（序列化） 123456789101112private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out any hidden serialization magic s.defaultWriteObject(); // Write out size s.writeInt(size); // Write out all elements in the proper order. for (Node&lt;E&gt; x = first; x != null; x = x.next) s.writeObject(x.item);&#125; 从流中把LinkedList读取出来（读取流，拼装成LinkedList）（反序列化） 12345678910111213@SuppressWarnings("unchecked")private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden serialization magic s.defaultReadObject(); // Read in size int size = s.readInt(); // Read in all elements in the proper order. for (int i = 0; i &lt; size; i++) linkLast((E)s.readObject());&#125; LinkedList提供了两种迭代器，一种是返回Iterator，另一种返回ListIterator。 ①返回ListIterator迭代器： 1234public ListIterator&lt;E&gt; listIterator(int index) &#123; checkPositionIndex(index); return new ListItr(index);&#125; ②返回Iterator迭代器： 123public Iterator&lt;E&gt; descendingIterator() &#123; return new DescendingIterator();&#125;]]></content>
      <categories>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合类之SET]]></title>
    <url>%2F2019%2F05%2F26%2Fjava%E9%9B%86%E5%90%88%E7%B1%BB%2F%E9%9B%86%E5%90%88%E7%B1%BB%E4%B9%8BSET%2F%E9%9B%86%E5%90%88%E7%B1%BB%E4%B9%8BSET%2F</url>
    <content type="text"><![CDATA[集合类之SETset集合可以存储多个对象，但并不会记住元素的存储顺序，也不允许集合中有重复元素(不同的set集合有不同的判断方法)。 1.HashSetHashSet按照Hash算法存储集合中的元素，具有很好的存取和查找性能。当向HashSet中添加一些元素时，HashSet会根据该对象的HashCode()方法来得到该对象的HashCode值，然后根据这些HashCode的值来决定元素的位置。(HashSet的底层原理是HashMap) HashSet的特点：1.存储顺序和添加的顺序不同 2.HashSet不是同步的，如果多个线程同时访问一个HashSet，假设有两个或更多的线程修改了 集合中的值，则必须通过代码使线程同步。 3.HastSet允许集合中的元素为null。 ​ 4.非线程安全 在Hashset集合中，判断两个元素相同的标准是：两个对象通过equals()方法相等，且HashCode()方法的返回值也相等。如果有两个元素通过equals()方法比较相等，而HashCode()的返回值不同，HashSet会将这两个对象保存在不同的地方。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; static final long serialVersionUID = -5024744406713321676L; // 底层使用HashMap来保存HashSet中所有元素。 private transient HashMap&lt;E,Object&gt; map; // 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。 private static final Object PRESENT = new Object(); /** * 默认的无参构造器，构造一个空的HashSet。 * * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 */ public HashSet() &#123; map = new HashMap&lt;E,Object&gt;(); &#125; /** * 构造一个包含指定collection中的元素的新set。 * * 实际底层使用默认的加载因子0.75和足以包含指定 * collection中所有元素的初始容量来创建一个HashMap。 * @param c 其中的元素将存放在此set中的collection。 */ public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;E,Object&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); &#125; /** * 以指定的initialCapacity和loadFactor构造一个空的HashSet。 * * 实际底层以相应的参数构造一个空的HashMap。 * @param initialCapacity 初始容量。 * @param loadFactor 加载因子。 */ public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;E,Object&gt;(initialCapacity, loadFactor); &#125; /** * 以指定的initialCapacity构造一个空的HashSet。 * * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。 * @param initialCapacity 初始容量。 */ public HashSet(int initialCapacity) &#123; map = new HashMap&lt;E,Object&gt;(initialCapacity); &#125; /** * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 * * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 * @param initialCapacity 初始容量。 * @param loadFactor 加载因子。 * @param dummy 标记。 */ HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor); &#125; /** * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。 * * 底层实际调用底层HashMap的keySet来返回所有的key。 * 可见HashSet中的元素，只是存放在了底层HashMap的key上， * value使用一个static final的Object对象标识。 * @return 对此set中元素进行迭代的Iterator。 */ public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator(); &#125; /** * 返回此set中的元素的数量（set的容量）。 * * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。 * @return 此set中的元素的数量（set的容量）。 */ public int size() &#123; return map.size(); &#125; /** * 如果此set不包含任何元素，则返回true。 * * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。 * @return 如果此set不包含任何元素，则返回true。 */ public boolean isEmpty() &#123; return map.isEmpty(); &#125; /** * 如果此set包含指定元素，则返回true。 * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e)) * 的e元素时，返回true。 * * 底层实际调用HashMap的containsKey判断是否包含指定key。 * @param o 在此set中的存在已得到测试的元素。 * @return 如果此set包含指定元素，则返回true。 */ public boolean contains(Object o) &#123; return map.containsKey(o); &#125; /** * 如果此set中尚未包含指定元素，则添加指定元素。 * 更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2)) * 的元素e2，则向此set 添加指定的元素e。 * 如果此set已包含该元素，则该调用不更改set并返回false。 * * 底层实际将将该元素作为key放入HashMap。 * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）， * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 * @param e 将添加到此set中的元素。 * @return 如果此set尚未包含指定元素，则返回true。 */ public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125; /** * 如果指定元素存在于此set中，则将其移除。 * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e， * 则将其移除。如果此set已包含该元素，则返回true * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。 * * 底层实际调用HashMap的remove方法删除指定Entry。 * @param o 如果存在于此set中则需要将其移除的对象。 * @return 如果set包含指定元素，则返回true。 */ public boolean remove(Object o) &#123; return map.remove(o)==PRESENT; &#125; /** * 从此set中移除所有元素。此调用返回后，该set将为空。 * * 底层实际调用HashMap的clear方法清空Entry中所有元素。 */ public void clear() &#123; map.clear(); &#125; /** * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 * * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。 */ public Object clone() &#123; try &#123; HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone(); newSet.map = (HashMap&lt;E, Object&gt;) map.clone(); return newSet; &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; &#125; &#125; HashSet所有方法都直接在HashMap上运用，了解HashMap自然可以了解HashSet。 其中需要了解一下HashSet的加载因子和容量： 在HashSet中我们new对象的时候会创建一个初始默认容量是16的HashSet集合；其中默认的一个值loadFactor： 加载因子：0.75 加载因子是数组的长度的百分比；16*0.75 = 12； 意思就是数组中的桶数达到12个时数组就要扩容；（复制），扩容到原来的2倍； 0.75是一个折中的数据；是增删改查的最优速度； new的时候可以直接初始化数组长度和loadFactor（加载因子）来改变加载因子； 注意： 对于HashSet中保存的对象，主要要正确重写equals方法和hashCode方法，以保证放入Set对象的唯一性 虽说是Set是对于重复的元素不放入，倒不如直接说是底层的Map直接把原值替代了 HashSet没有提供get()方法，愿意是同HashMap一样，Set内部是无序的，只能通过迭代的方式获得 2.LinkedHashSetLinkedHashSet是继承自HashSet，底层实现是LinkedHashMap。并且其初始化时直接super(......) 查看了LinkedHashMap的构造方法后，发现其因为继承自HashMap，所以其底层实现也是HashMap!!!，然后发现了LinkedHashMap调用父类构造方法初始化时，还顺便设置了变量accessOrder = false，看上面得源码可以知道，这是给了迭代器一个参数，false代表迭代时使用插入得顺序 3.TreeSet1、TreeSet(树集)是一个有序集合，可以按照任何顺序将元素插入该集合，当对该集合进行迭代时，各个值将自动以排序后的顺序出现。TreeSet中的元素按照升序排列，缺省是按照自然顺序进行排序，意味着TreeSet中的元素要实现Comparable接口，或者有一个自定义的比较器Comparator。 2、TreeSet底层使用的是TreeMap，TreeMap的底层实现是红黑树 1234public TreeSet()&#123; this(new TreeMap&lt;E,Object&gt;());&#125; 注意： 1、TreeSet的排列顺序必须是全局顺序，也就是说任何两个元素都是必须可比的，同时只有当他们比较相同时才返回0。 2、如果树集包含了n个元素，那么平均需要进行log2n次比较，才能找到新元素的正确位置。]]></content>
      <categories>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合类之MAP]]></title>
    <url>%2F2019%2F05%2F26%2Fjava%E9%9B%86%E5%90%88%E7%B1%BB%2F%E9%9B%86%E5%90%88%E7%B1%BB%E4%B9%8BMAP%2F%E9%9B%86%E5%90%88%E7%B1%BB%E4%B9%8BMAP%2F</url>
    <content type="text"><![CDATA[集合类之MAPmap架构 如上图：(1) Map 是映射接口，Map中存储的内容是键值对*(key-value)*。(2) AbstractMap 是继承于Map的抽象类，它实现了Map中的大部分API。其它Map的实现类可以通过继承AbstractMap来减少重复编码。(3) SortedMap 是继承于Map的接口。SortedMap中的内容是排序的键值对，排序的方法是通过比较器(Comparator)。(4) NavigableMap 是继承于SortedMap的接口。相比于SortedMap，NavigableMap有一系列的导航方法；如”获取大于/等于某对象的键值对”、“获取小于/等于某对象的键值对”等等。(5) TreeMap 继承于AbstractMap，且实现了NavigableMap接口；因此，TreeMap中的内容是“有序的键值对”！(6) HashMap 继承于AbstractMap，但没实现NavigableMap接口；因此，HashMap的内容是“键值对，但不保证次序”！(7) Hashtable 虽然不是继承于AbstractMap，但它继承于Dictionary(Dictionary也是键值对的接口)，而且也实现Map接口；因此，Hashtable的内容也是“键值对，也不保证次序”。但和HashMap相比，Hashtable是线程安全的，而且它支持通过Enumeration去遍历。(8) WeakHashMap 继承于AbstractMap。它和HashMap的键类型不同，WeakHashMap的键是“弱键”。 HashMap1、HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。 2、HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。 3、HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。 4、HashMap中的映射不是有序的。 HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。 从图中可以看出：(01) HashMap继承于AbstractMap类，实现了Map接口。Map是”key-value键值对”接口，AbstractMap实现了”键值对”的通用函数接口。(02) HashMap是通过”拉链法”实现的哈希表。它包括几个重要的成员变量：table, size, threshold, loadFactor, modCount。 table是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。 size是HashMap的大小，它是HashMap保存的键值对的数量。 threshold是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值=”容量*加载因子”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 loadFactor就是加载因子。 modCount是用来实现fail-fast机制的。 1、存储结构 hashmap底层是以数组方式进行存储。将key-value对作为数组中的一个元素进行存储。 key-value都是Map.Entry中的属性。其中将key的值进行hash之后进行存储，即每一个key都是计算hash值，然后再存储。每一个Hash值对应一个数组下标，数组下标是根据hash值和数组长度计算得来。 由于不同的key有可能hash值相同，即该位置的数组中的元素出现两个，对于这种情况，hashmap采用链表形式进行存储。 下图描述了hashmap的存储结构图 Entry结构分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key;// map中key值，可以为null。 V value; // map中的value值，可以为null。 Entry&lt;K,V&gt; next;// 链表引用，防止key值不同，hash值相同。 int hash; // 每个key的hash值 // 构造函数 Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; // 同一个key时，新值替换旧值，返回旧值 public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // key值重写equals方法 public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; // 重写hashCode值 public final int hashCode() &#123; return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue()); &#125; public final String toString() &#123; return getKey() + "=" + getValue(); &#125; // 其他方法省略 &#125; HashMap属性分析 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable&#123; /** *默认情况下，hashmap大小为16.即1&lt;&lt;4就是1乘以2的4次幂=16 */ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 /** * hashMap的最大值 */ static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /** * 默认加载加载因子，即使用空间达到总空间的0.75时，需要扩容。 */ static final float DEFAULT_LOAD_FACTOR = 0.75f; /** * 声明hashmap一个空数组。 */ static final Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;; /** * 最开始时，hashmap是一个空数组。 */ transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE; /** * map的元素的个数 */ transient int size; /* * hashmap的实际存储空间大小。这个空间是总空间*加载因子得出的大小。 * 比如默认是16，加载因子是0.74。则threshold就是12。 */ int threshold; /** * 加载因子，即使用空间达到总空间的0.75时，需要扩容。 */ final float loadFactor; /** * */ transient int modCount; /** * threshold这个值的最大值就是Integer.MAX_VALUE */ static final int ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE; put方法 put（key,value）方法是hashmap中最重要的方法，使用hashmap最主要的就是使用put,get两个方法。可以从put方法的源码进行分析 1234567891011121314151617181920212223242526272829303132public V put(K key, V value) &#123; // 首次存储元素，初始化存储空间 if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; // 如果key为null，则将null放入元素的第一个位置 if (key == null) return putForNullKey(value); // 计算key的hash值 int hash = hash(key); // 根据key的hash值，数组长度计算该Entry&lt;key,value&gt;的数组下标 int i = indexFor(hash, table.length); /** **如果当前key的已经存在于map中，则将新值替换成旧值。 **/ for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 判断同一个key，既要判断hash值相同，还要判断key是同一个key，因为 // 相同的key有可能hash值也相同。双重判断保证是同一个key。 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 如果是新的key需要存储，则增加操作次数modCount++ modCount++; // 将新增key-value键值对添加中map中。 addEntry(hash, key, value, i); return null; &#125; addEntry方法 addEntry方法是将新增的key-value键值对存入到map中。该方法主要完成两个功能：1.1. 添加新元素前， 判断是否需要对map的数组进行扩容，如果需要扩容，则扩容空间大小是原来的两倍1.2. 对于新增key-value键值对，如果key的hash值相同，则构造单向列表。 从源码分析结果如下： 123456789101112131415/**** hash:key的hash值** key:存储的键** value：存储的value对象值*** bucketIndex：数组下标位置，即key-value在数组中的位置。**/void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length);//扩容两倍 hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; // 往数组中添加新的key-value键值对 createEntry(hash, key, value, bucketIndex); &#125; createEntry方法 该方法主要完成两个功能 1、添加新的key到Entry数组中 2、对于不同key的hash值相同的情况下，在同一个数组下标处，构建单向链表进行存储。 1234567void createEntry(int hash, K key, V value, int bucketIndex) &#123; // 取出当前位置的元素，如果是新添加的key,则e为null，已经有的元素为不为空。 Entry&lt;K,V&gt; e = table[bucketIndex]; // 添加新的key-value值或构建链表 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++; &#125; 遍历HashMap的键 根据keySet()获取HashMap的“键”的Set集合。 通过Iterator迭代器遍历“第一步”得到的集合 1234567891011// 假设map是HashMap对象// map中的key是String类型，value是Integer类型String key = null;Integer integ = null;Iterator iter = map.keySet().iterator();while (iter.hasNext()) &#123; // 获取key key = (String)iter.next(); // 根据key，获取value integ = (Integer)map.get(key);&#125; 遍历HashMap的值 根据value()获取HashMap的“值”的集合。 通过Iterator迭代器遍历“第一步”得到的集合。 12345678// 假设map是HashMap对象// map中的key是String类型，value是Integer类型Integer value = null;Collection c = map.values();Iterator iter= c.iterator();while (iter.hasNext()) &#123; value = (Integer)iter.next();&#125; TreeMap TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。 TreeMap 继承于AbstractMap，所以它是一个Map，即一个key-value集合。 TreeMap 实现了NavigableMap接口，意味着它支持一系列的导航方法。比如返回有序的key集合。 TreeMap 实现了Cloneable接口，意味着它能被克隆。 TreeMap 实现了java.io.Serializable接口，意味着它支持序列化。 TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。 TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n)（jdk1.8之后加入红黑树由o(n)变为o( log(n) ) ） 。 TreeMap是非同步的。 它的iterator 方法返回的迭代器是fail-fastl的 从图中可以看出：(1) TreeMap实现继承于AbstractMap，并且实现了NavigableMap接口。(2) TreeMap的本质是R-B Tree(红黑树)，它包含几个重要的成员变量： root, size, comparator。 root 是红黑数的根节点。它是Entry类型，Entry是红黑数的节点，它包含了红黑数的6个基本组成成分：key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色)。Entry节点根据key进行排序，Entry节点包含的内容为value。 红黑数排序时，根据Entry中的key进行排序；Entry中的key比较大小是根据比较器comparator来进行判断的。size是红黑数中节点的个数。 数据结构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; K key; //键 V value; //值 Entry&lt;K,V&gt; left = null; //左孩子节点 Entry&lt;K,V&gt; right = null; //右孩子节点 Entry&lt;K,V&gt; parent; //父节点 boolean color = BLACK; //节点的颜色，在红黑树种，只有两种颜色，红色和黑色 //构造方法，用指定的key,value ,parent初始化，color默认为黑色 Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123; this.key = key; this.value = value; this.parent = parent; &#125; //返回key public K getKey() &#123; return key; &#125; //返回该节点对应的value public V getValue() &#123; return value; &#125; //替换节点的值，并返回旧值 public V setValue(V value) &#123; V oldValue = this.value; this.value = value; return oldValue; &#125; //重写equals()方法 public boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; //两个节点的key相等，value相等，这两个节点才相等 return valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue()); &#125; //重写hashCode()方法 public int hashCode() &#123; int keyHash = (key==null ? 0 : key.hashCode()); int valueHash = (value==null ? 0 : value.hashCode()); //key和vale hash值得异或运算，相同则为零，不同则为1 return keyHash ^ valueHash; &#125; //重写toString()方法 public String toString() &#123; return key + "=" + value; &#125;&#125; 构造方法 1234567891011121314151617181920212223242526//构造方法，comparator用键的顺序做比较public TreeMap() &#123; comparator = null;&#125;//构造方法，提供比较器，用指定比较器排序public TreeMap(Comparator&lt;? super K&gt; comparator) &#123; his.comparator = comparator;&#125;//将m中的元素转化daoTreeMap中，按照键的顺序做比较排序public TreeMap(Map&lt;? extends K, ? extends V&gt; m) &#123; comparator = null; putAll(m);&#125;//构造方法，指定的参数为SortedMap//采用m的比较器排序public TreeMap(SortedMap&lt;K, ? extends V&gt; m) &#123; comparator = m.comparator(); try &#123; buildFromSorted(m.size(), m.entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125;&#125; TreeMap提供了四个构造方法，实现了方法的重载。无参构造方法中比较器的值为null,采用自然排序的方法，如果指定了比较器则称之为定制排序. 自然排序：TreeMap的所有key必须实现Comparable接口，所有的key都是同一个类的对象 定制排序：创建TreeMap对象传入了一个Comparator对象，该对象负责对TreeMap中所有的key进行排序，采用定制排序不要求Map的key实现Comparable接口。 Put()方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; //红黑树的根节点 if (t == null) &#123; //红黑树是否为空 compare(key, key); // type (and possibly null) check //构造根节点，因为根节点没有父节点，传入null值。 root = new Entry&lt;&gt;(key, value, null); size = 1; //size值加1 modCount++; //改变修改的次数 return null; //返回null &#125; int cmp; Entry&lt;K,V&gt; parent; //定义节点 Comparator&lt;? super K&gt; cpr = comparator; //获取比较器 if (cpr != null) &#123; //如果定义了比较器，采用自定义比较器进行比较 do &#123; parent = t; //将红黑树根节点赋值给parent cmp = cpr.compare(key, t.key); //比较key, 与根节点的大小 if (cmp &lt; 0) //如果key &lt; t.key , 指向左子树 t = t.left; //t = t.left , t == 它的做孩子节点 else if (cmp &gt; 0) t = t.right; //如果key &gt; t.key , 指向它的右孩子节点 else return t.setValue(value); //如果它们相等，替换key的值 &#125; while (t != null); //循环遍历 &#125; else &#123; //自然排序方式，没有指定比较器 if (key == null) throw new NullPointerException(); //抛出异常 Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; //类型转换 do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) // key &lt; t.key t = t.left; //左孩子 else if (cmp &gt; 0) // key &gt; t.key t = t.right; //右孩子 else return t.setValue(value); //t == t.key , 替换value值 &#125; while (t != null); &#125; Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); //创建新节点，并制定父节点 //根据比较结果，决定新节点为父节点的左孩子或者右孩子 if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e); //新插入节点后重新调整红黑树 size++; modCount++; return null;&#125;//比较方法，如果comparator==null ,采用comparable.compartTo进行比较，否则采用指定比较器比较大小final int compare(Object k1, Object k2) &#123; return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2) : comparator.compare((K)k1, (K)k2);&#125;private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; //插入的节点默认的颜色为红色 x.color = RED; // //情形1： 新节点x 是树的根节点，没有父节点不需要任何操作 //情形2： 新节点x 的父节点颜色是黑色的，也不需要任何操作 while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; //情形3：新节点x的父节点颜色是红色的 //判断x的节点的父节点位置，是否属于左孩子 if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; //获取x节点的父节点的兄弟节点，上面语句已经判断出x节点的父节点为左孩子，所以直接取右孩子 Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); //判断是否x节点的父节点的兄弟节点为红色。 if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); // x节点的父节点设置为黑色 setColor(y, BLACK); // y节点的颜色设置为黑色 setColor(parentOf(parentOf(x)), RED); // x.parent.parent设置为红色 x = parentOf(parentOf(x)); // x == x.parent.parent ,进行遍历。 &#125; else &#123; //x的父节点的兄弟节点是黑色或者缺少的 if (x == rightOf(parentOf(x))) &#123; //判断x节点是否为父节点的右孩子 x = parentOf(x); //x == 父节点 rotateLeft(x); //左旋转操作 &#125; //x节点是其父的左孩子 setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); //上面两句将x.parent 和x.parent.parent的颜色做调换 rotateRight(parentOf(parentOf(x))); //进行右旋转 &#125; &#125; else &#123; Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); //y 是x 节点的祖父节点的左孩子 if (colorOf(y) == RED) &#123; //判断颜色 setColor(parentOf(x), BLACK); //父节点设置为黑色 setColor(y, BLACK); //父节点的兄弟节点设置为黑色 setColor(parentOf(parentOf(x)), RED); //祖父节点设置为红色 x = parentOf(parentOf(x)); //将祖父节点作为新插入的节点，遍历调整 &#125; else &#123; if (x == leftOf(parentOf(x))) &#123; //x 是其父亲的左孩子 x = parentOf(x); rotateRight(x); //以父节点为旋转点，进行右旋操作 &#125; setColor(parentOf(x), BLACK); //父节点为设置为黑色 setColor(parentOf(parentOf(x)), RED); //祖父节点设置为红色 rotateLeft(parentOf(parentOf(x))); //以父节点为旋转点，进行左旋操作 &#125; &#125; &#125; root.color = BLACK; //通过节点位置的调整，最终将红色的节点条调换到了根节点的位置，根节点重新设置为黑色&#125; 增加删除节点都运用了红黑树的原理，红黑树有五个特点： 每个节点只能是红色或者黑色 根节点永远是黑色的 所有的叶子的子节点都是空节点，并且都是黑色的 每个红色节点的两个子节点都是黑色的（不会有两个连续的红色节点） 从任一个节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点（叶子节点到根节点的黑色节点数量每条路径都相同） 红黑树插入新节点的三个关键地方：1、插入新节点总是红色节点。2、插入节点的父节点是黑色，能维持性质。3、如果插入节点的父节点是红色，破坏了性质。故插入算法就是通过重新着色或旋转，来维持性质 deleteEntry()方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private void deleteEntry(Entry&lt;K,V&gt; p) &#123; modCount++; //修改次数 +1 size--; //元素个数 -1 /* * 被删除节点的左子树和右子树都不为空，那么就用 p节点的中序后继节点代替 p 节点 * successor(P)方法为寻找P的替代节点。规则是右分支最左边，或者 左分支最右边的节点 * ---------------------（1） */ if (p.left != null &amp;&amp; p.right != null) &#123; Entry&lt;K,V&gt; s = successor(p); p.key = s.key; p.value = s.value; p = s; &#125; //replacement为替代节点，如果P的左子树存在那么就用左子树替代，否则用右子树替代 Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); /* * 删除节点，分为上面提到的三种情况 * -----------------------（2） */ //如果替代节点不为空 if (replacement != null) &#123; replacement.parent = p.parent; /* *replacement来替代P节点 */ //若P没有父节点，则跟节点直接变成replacement if (p.parent == null) root = replacement; //如果P为左节点，则用replacement来替代为左节点 else if (p == p.parent.left) p.parent.left = replacement; //如果P为右节点，则用replacement来替代为右节点 else p.parent.right = replacement; //同时将P节点从这棵树中剔除掉 p.left = p.right = p.parent = null; /* * 若P为红色直接删除，红黑树保持平衡 * 但是若P为黑色，则需要调整红黑树使其保持平衡 */ if (p.color == BLACK) fixAfterDeletion(replacement); &#125; else if (p.parent == null) &#123; //p没有父节点，表示为P根节点，直接删除即可 root = null; &#125; else &#123; //P节点不存在子节点，直接删除即可 if (p.color == BLACK) //如果P节点的颜色为黑色，对红黑树进行调整 fixAfterDeletion(p); //删除P节点 if (p.parent != null) &#123; if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; &#125; &#125; &#125; TreeMap还有很多地方没有写全，后续再来补学。 TreeMap问题集锦 1、TreeMap的键、值能否为null value是可以为null的 当未实现 Comparator 接口时，key 不可以为null，否则抛 NullPointerException 异常； 当实现 Comparator 接口时，若未对 null 情况进行判断，则可能抛 NullPointerException 异常。如果针对null情况实现了，可以存入，但是却不能正常使用get()访问，只能通过遍历去访问。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748测试Value能否为null public static void main(String[] args) &#123; TreeMap&lt;String, Integer&gt; treeMap = new TreeMap&lt;&gt;(); treeMap.put("1",1); treeMap.put("2",null); System.out.println(treeMap.get("2")); &#125; 结果：null 测试key能否为null public static void main(String[] args) &#123; TreeMap&lt;String, Integer&gt; treeMap = new TreeMap&lt;&gt;(); treeMap.put("1",1); treeMap.put(null,null); System.out.println(treeMap.get("2")); &#125; 结果：Exception in thread "main" java.lang.NullPointerException at java.util.TreeMap.put(TreeMap.java:563) at com.crazy_june.test_treemap.main(test_treemap.java:9) 测试当自己实现一个comparator接口时 public static void main(String[] args) &#123; TreeMap&lt;String, Integer&gt; treeMap = new TreeMap&lt;&gt;(new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; if(o1==null)&#123; return 1; &#125;else &#123; return o2.charAt(0)-o1.charAt(0); &#125; &#125; &#125;); treeMap.put("1",1); treeMap.put(null,12); treeMap.put("2",2); System.out.println(treeMap.get(null)); &#125; 结果：null 证明不能通过get()取出来 测试通过遍历entry可以取出来不 for(Map.Entry&lt;String,Integer&gt; entry:treeMap.entrySet())&#123; System.out.println(entry.getKey()+":"+entry.getValue()); &#125; 结果： 2:2 1:1 null:12]]></content>
      <categories>
        <category>集合框架</category>
      </categories>
      <tags>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FRedis%2FRedis%2F</url>
    <content type="text"><![CDATA[RedisNoSQLNoSQL = not only SQL 非关系型数据库 为什么需要NoSQL High Performance - 高并发读写 Huge Storage - 海量数据的高效率存储和访问 HIgh Scalability&amp;&amp;High Availability - 高可扩展性和高可用性 NoSQL数据库的四大分类 键值对(key-value)存储 列存储 文档数据库 图形数据库 NoSQL的特点： 易扩展 灵活的数据模型 大数据量 高可用 Redis支持的键值数据类型： 字符串类型 散列类型 列表类型 集合类型 有序集合类型 读每秒11万次，写每秒8万次 Redis应用场景： 缓存 任务队列 应用排行榜 网站访问统计 数据过期处理 分布式集群架构中的session分离 JedisJedis是Redis官方首选的java客户端开发包 Redis的数据结构 字符串（String） 哈希（hash） 字符串列表（list） 字符串集合（set） 有序字符串集合（sorted set） Redis持久化需要持久化的原因：Redis将数据存在内存中，容易丢失数据，需要将数据存进硬盘，称为持久化 两种持久化的方式 RDB方式 AOF方式 持久化的四种方式： RDB方式：默认支持、不需要进行配置，在指定的时间间隔内，将内存中的数据集快照写入硬盘 AOF方式：以日记的方式记录服务器处理的每一个操作，当重启时，会读取文件进行重建数据库，保证启动时数据库中的数据的完整 无持久化：通过日志禁止数据库持久化的功能 同时使用RDB方式和AOF方式]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库之事务和锁机制]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81%E6%9C%BA%E5%88%B6%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[数据库之事务和锁机制 事务四大特性事务的概念：事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元，要么全部执行，要么全部不执行。 1、原子性（Atomicity） 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，如果操作失败则不能对数据库有任何影响，任何一项操作都会导致整个事务的失败，同时其它已经被执行的操作都将被撤销并回滚，只有所有的操作全部成功，整个事务才算是成功完成。 2、一致性（Consistency） 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。 3、隔离性（lsolation） 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。 4、持久性（durability） 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。 事务并发引起的问题1、脏读（dirty read） 当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。 例如：用户A向用户B转账100元 1234update account set money=money+100 where name=’B’; (此时A通知B)update account set money=money - 100 where name=’A’;以上两条sql语句为转账事务 转账是一个事务，通知查看是一个事务。 当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读） 而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚 那么当B以后再次查看账户时就会发现钱其实并没有转。 脏读就是一个事务读取了另一个事务未提交的脏数据 2、不可重复读（unrepeatable reading） 不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。 例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。 不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。 在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就产生矛盾。 3、幻读（Phantom read） 幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。 事务的四种隔离级别 Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。 Repeatable read (可重复读)：可避免脏读、不可重复读的发生。 Read committed (读已提交)：可避免脏读的发生。 Read uncommitted (读未提交)：最低级别，任何情况都无法保证。 以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别。级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。 隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效。 对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。 ###]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库之索引]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E7%B4%A2%E5%BC%95%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[数据库之索引创建索引在创建表的时候添加索引 12345CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) ); 在创建表以后添加索引 123ALTER TABLE my_table ADD [UNIQUE] INDEX index_name(column_name);或者CREATE INDEX index_name ON my_table(column_name); 注意： 1、索引需要占用磁盘空间，因此在创建索引时要考虑到磁盘空间是否足够 2、创建索引时需要对表加锁，因此实际操作中需要在业务空闲期间进行 根据索引进行查询1234567891011121314151617181920212223具体查询：SELECT * FROM table_name WHERE column_1=column_2;(为column_1建立了索引)或者模糊查询SELECT * FROM table_name WHERE column_1 LIKE '%三'SELECT * FROM table_name WHERE column_1 LIKE '三%'SELECT * FROM table_name WHERE column_1 LIKE '%三%' SELECT * FROM table_name WHERE column_1 LIKE '_好_' 如果要表示在字符串中既有A又有B，那么查询语句为：SELECT * FROM table_name WHERE column_1 LIKE '%A%' AND column_1 LIKE '%B%'; SELECT * FROM table_name WHERE column_1 LIKE '[张李王]三'; //表示column_1中有匹配张三、李三、王三的都可以SELECT * FROM table_name WHERE column_1 LIKE '[^张李王]三'; //表示column_1中有匹配除了张三、李三、王三的其他三都可以//在模糊查询中，%表示任意0个或多个字符；_表示任意单个字符（有且仅有），通常用来限制字符串长度;[]表示其中的某一个字符；[^]表示除了其中的字符的所有字符 或者在全文索引中模糊查询SELECT * FROM table_name WHERE MATCH(content) AGAINST('word1','word2',...); 删除索引 123DROP INDEX my_index ON tablename；或者ALTER TABLE table_name DROP INDEX index_name; 查看表中的索引 1SHOW INDEX FROM tablename 查看查询语句查询索引的情况 12//explain 加查询语句explain SELECT * FROM table_name WHERE column_1='123'; 索引的优缺点优点： 可以快速检索，加快检索速度 根据索引分组和排序，可以加快分组和排序 缺点： 索引本身也是表，会占据存储空间 索引表的创建和维护需要时间，随数据量增大而增大 降低数据表的修改操作（删除、添加、修改）的效率，因为在修改数据表的同时也要修改索引表 索引的分类常见的索引类型有：主键索引、唯一索引、普通索引、全文索引、组合索引 1、主键索引：即主索引，根据主键pk_clolum（length）建立索引，不允许重复，不允许空值； 1ALTER TABLE 'table_name' ADD PRIMARY KEY pk_index('col')； 2、唯一索引：用来建立索引的列的值必须是唯一的，允许空值 1ALTER TABLE 'table_name' ADD UNIQUE index_name('col')； 3、普通索引：用表中的普通列构建的索引，没有任何限制 1ALTER TABLE 'table_name' ADD INDEX index_name('col')； 4、全文索引：用大文本对象的列构建的索引 1ALTER TABLE 'table_name' ADD FULLTEXT INDEX ft_index('col')； 5、组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值 1ALTER TABLE 'table_name' ADD INDEX index_name('col1','col2','col3')； 遵循“最左前缀”原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引相当于建立了col1,col1col2,col1col2col3三个索引，而col2或者col3是不能使用索引的。 在使用组合索引的时候可能因为列名长度过长而导致索引的key太大，导致效率降低，在允许的情况下，可以只取col1和col2的前几个字符作为索引 1ALTER TABLE 'table_name' ADD INDEX index_name(col1(4),col2（3))； 表示使用col1的前4个字符和col2的前3个字符作为索引。 索引的选取类型1、越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快 2、简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂 3、尽量避免NULL：应该指定列为NOT nuLL,在MySQL中， 含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂 什么场景不适合创建索引1、很少使用查询或者只是作为参考的列，因为这些列很少用到，添加索引只会增加开销和维护成本 2、很少数据集的列也不应该加索引，例如班级的同学的性别，只有男或女，利用索引相当于全表搜索，没意义 3、当修改性能远远大于检索性能时，因为修改性能和检索性能互相矛盾 4、不会出现在where条件中的字段不该建立索引 什么的字段适合索引1、表的主键和外键必须有索引，外键唯一，且经常查询 2、数据量比较多的超过300需要索引 3、经常需要和其他表进行连接查询的字段应该建立索引 4、经常出现在where子句中的字段，加快判断速度 5、经常用到排序的列上，因为索引已经排序 6、经常用在范围内搜索的列上创建索引，因为索引已经排序，指定范围是连续（B+树） MySQL索引的底层原理索引是帮助MySQL高效获取数据的数据结构 上图展示的是一种可能的索引方式 左边是数据表，一共有两列14条记录，最左边是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上并不一定物理相邻），但实际数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现 目前大部分数据库系统及文件系统都采用B Tree或其变种B+Tree作为索引结构，MySQL普遍使用B+树实现索引 在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的 MyISAM和InnoDB对索引和数据的存储在磁盘上是如何体现的 role表使用的存储引擎是MyISAM，而user使用的是InnoDB： role表有三个文件，对应如下： role.frm：表结构文件 role.MYD：数据文件（MyISAM Data） role.MYI：索引文件（MyISAM Index） user表有两个文件，对应如下： user.frm：表结构文件 user.ibd：索引和数据文件（InnoDB Data） 由于两种引擎对索引和数据的存储方式的不同，我们也称MyISAM的索引为非聚集索引，InnoDB的索引为聚集索引。 MyISAM索引实现 MyISAM引擎使用B+Tree作为索引结构，叶节点data域存放数据记录的地址 设Col1为主键，上图是一个MyISAM表的主索引（Primary key）示例。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅索引的key可以重复（为什么没有区别，是因为SQL语句中where子句可以使用的是其他字段来作为条件，如clo2&gt;…之类的语句，所以主索引和辅助索引在MyISAM没有区别）如果我们在Col2上建立一个辅索引，则此索引的结构如下图所示： MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分 InnoDB索引实现 MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址 而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引 与MyISAM的区别两点： 一、因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有） 如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键 如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形 二、InnoDB的辅索引data域存储相应记录主键的值而不是地址。 InnoDB的所有辅助索引都引用主键作为data域 索引存在但未使用情况（索引失效、索引优化）1CREATE INDEX idx_test_a1234 ON test(a1,a2,a3,a4);//创建联合索引来说明索引失效的一下情况 1.字符串为使用引号，导致索引失效（不能在索引列上干任何操作(计算,函数,类型转换) ） 123select * from test where a1 = a1;//可以查到数据，数据库自动转换类型，但索引失效select * from test where a1 = 'a1'; 2、索引最左原则使用不当，导致索引失效（where子句后面的顺序无关，只要用到就可以） 12345678910111213141516171819select * from test where a1 = 'a1' and a2 = 'a2' and a3 = 'a3' and a4 = 'a4';select * from test where a4= 'a4' and a3 = 'a3' and a2 = 'a2' and a1= 'a1';以上两个查询中，where条件中的索引位置是相反的，但是执行结果是一致的，这个是由mysql优化器来处理的，因为两个查询中都出现了联合索引a1,a2，a3,a4，MySQL优化器底层会进行优化处理。select * from test where a1 = 'a1' and a3 = 'a3' and a4 = 'a4';select * from test where a4= 'a4' and a3 = 'a3' and a1= 'a1';以上两个查询只用到一个索引a1select * from test where a1 = 'a1' and a2 = 'a2' and a4 = 'a4';select * from test where a4= 'a4' and a2 = 'a2' and a1= 'a1';以上两个查询用到两个索引select * from test where a2 = 'a2' and a3 = 'a3' and a4 = 'a4';select * from test where a4= 'a4' and a3 = 'a3' and a2 = 'a2'以上两个查询未使用索引 3、范围查找导致索引失效（存储引擎不能使用索引中范围条件右边的列） 123456select * from test where a1 = &apos;a1&apos; and a2 = &apos;a2&apos; and a3 &gt;&apos;a3&apos; and a4 = &apos;a4&apos;;以上用到a1、a2、a3，3个索引，因为a3右边是a4，导致a4的索引不可用select * from test where a1 = &apos;a1&apos; and a2 = &apos;a2&apos; and a4 &gt;&apos;a4&apos; and a3= &apos;a3&apos;;以上用到a1、a2、a3、a4，4个索引，因为a4后面已经没有索引了，不影响 4、order by使用不当，导致索引失效 12345select * from test where a1 = 'a1' and a2 = 'a2' and a4 = 'a4' order by a3explain语句显示两个索引，严格来说以上用到两个索引查询，三个索引排序因为查找的where条件中跳过了a3,违背了索引的最左原则，导致索引a4失效严格意义上来说，以上查询使用了3个索引，a3并未用于查找，但是在排序中使用到了，只是为统计到explain中，即满足索引的两大功能：查找和排序 以下排序中，索引使用不当，导致产生了文件内排序，影响性能 a2之后a3断开，导致a4索引失效，mysql 为了将结果展现出来，进行了内部排序 1select * from test where a1 ='a1' and a2 = 'a2' order by a4; 123456789101112select * from test where a1 ='a1' and a5 = 'a5' order by a2,a3;使用到a1一个索引select * from test where a1 ='a1' and a5= 'a5' order by a3,a2;使用到a1索引，并且产生文件内排序select * from test where a1 ='a1' and a2 = 'a2' order by a2,a3;使用到a1、a2两个索引，没有产生文件内排序原文：https://blog.csdn.net/weixin_39539399/article/details/80842750 5、group by使用不当导致索引失效 123select * from test where a1 ='a1'and a4 = 'a4' group by a2，a3;select * from test where a1 ='a1'and a4 = 'a4' group by a3，a2; 分组之前必排序，group by 表面上是分组，但是对索引的使用和order by 的使用大致相同，所以group by后面如果索引错乱，会产生临时表，导致mysql内部进行排序 6、通配符like的使用不当导致索引失效（like以通配符开头(“%abc…”) ） 1234567891011select * from test where a1 like '%a';索引失效select * from test where a1 like 'a%';索引不失效select a1 from test where a1 like '%a';覆盖索引，解决最左匹配不当的索引失效问题select * from test where a1 like 'c%';索引失效select * from test where a1 like '%c';索引失效select * from test where a1 like 'abc%';索引不失效 6、MYSQL 中!=,&lt;&gt;导致索引失效（is null, is not null 也无法使用索引） 尽量使用覆盖索引(只访问索引的查询),减少select *，可以解决索引失效的以上问题 7、少用or,用它来连接时索引会失效 关于or导致的索引失效，是有存在这种情况的，即or的左右边的查询条件，有一个列没有加索引，那么另一个列的索引会失效。要想使得索引生效，需要保证or两边的列都有索引，且一个列是主键。 小总结 索引的底层原理其实没有我总结那么简单，水平有限，B+B-树随缘再总结]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈和队列]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F3%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[栈和队列栈只允许在一端进行插入或删除操作的线性表 栈顶：栈中允许进行插入和删除的哪一端 栈底：固定的，不允许进行插入和删除的另一端 12345#define MaxSize 50typedef struct&#123; Elemtype data[MaxSize];//存放栈中的元素 int top;//栈顶指针&#125;SqStack; top值不能超过MaxSize 空栈的判定条件通常定为top==-1，满栈的判定条件通常为top==MaxSize-1，栈中数据元素个数为top+1 顺序栈的操作判空1234bool StackEmpty(SqStack S)&#123; if(s.top==-1) return true; else return false;&#125; 进栈12345bool Push(SqStack &amp;S,ElemType x)&#123; if(S.top==MaxSize-1) return false; S.data[++S.top]=x; return true;&#125; 出栈12345bool Pop(SqStack &amp;S,ElemType &amp;x)&#123; if(S.top==-1) return false; x=S.data[S.top--]; return true;&#125; 获取栈顶元素12345bool GetTop(SqStack S,ElemType &amp;x)&#123; if(S.top==-1) return false; x=S.data[S.top]; return true;&#125; 共享栈 123456#define MaxSize 100typedef struct&#123; Elemtype data[MaxSize];//存放栈中的元素 int top1;//栈1栈顶指针 int top2;//栈2栈顶指针&#125;SqDoubleStack; 进栈1234567bool Push(SqDoubleStack &amp;S,ElemType x,int stackNum)&#123; if(S.top1+1==S.top2) return false;//栈满 if(stackNum==1) S.data[++S.top1]=x;//栈1有元素进栈 else if(stackNum==2) S.data[--S.top2]=x;//栈2有元素进栈 return true;&#125; 链式栈 123456789typedef struct SNode&#123; Elemtype data;//存放栈中的元素 struct SNode *next//栈顶指针&#125;SNode,*SLink//链栈结点 typedef struct LinkStack&#123; SLink top;//栈顶指针 int count;//链栈结点数&#125;LinkStack 链栈没有栈满的情况 链栈空为top==null 进栈12345678bool Push(LinkStack *S,ElemType x)&#123; SLink p=(SLink)malloc(sizeof(SNode));//给新元素分配空间 p-&gt;data=x;//新元素的值 p-next=S-&gt;top;//p的后继指向栈顶元素 S-&gt;top=p;//栈顶指针指向新的元素 S-&gt;count++;//栈中元素个数加1 return true;&#125; 出栈123456789bool Pop(LinkStack *S,ElemType &amp;x)&#123; if(S-&gt;top==NULL) return false; x=S-&gt;top-&gt;data;//栈顶元素值 SLink p=S-&gt;top;//辅助指针 S-&gt;top=S-&gt;top-&gt;next;//栈顶指针后移 free(p);//释放被删除数据的存储空间 S-&gt;count--;//栈中元素个数减一 return true;&#125; 栈的应用括号配对假设有两种括号，一种圆的()，一种方的[]，嵌套的顺序是任意的 算法思路： 若是左括号，入栈；若是右括号，出栈一个左括号判断是否与之匹配；检验到字符串尾，还要检查栈是否为空。只有栈空整个字符串才是括号匹配 12345678910111213141516171819202122bool Check(char *str)&#123; stack s; InitStack(s); int len = strlen(str);//字符串长度 for(int i=0;i&lt;len;i++)&#123; char a=str[i]; switch(a)&#123; case '('; case '['; Push(s,a); break; case ')'; if(Pop(s)!='(') return false;//出栈顶，如果不匹配直接返回不合法 break; case ']'; if(Pop(s)!=']')return false; break; &#125; &#125; if(Empty(s)) return true;//匹配完所有括号最后要求栈中为空 else return false;&#125; 表达式求值从左到右，先乘除后加减，右括号先算括号 后缀表达式做法： 规则：从左到右扫描表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈然后跟这个符号进行运算，最后将结果进栈，直到最终获得结果 如何将中缀表达式转换成后缀表达式（计算机也是用到栈取转换，下面是手动方法） 递归递归最重要的是递归式和递归边界 使用递归求解n的阶乘 1234int F(int n)&#123; if(n==0) return 1;//递归边界 else return n*F(n-1);//递归式&#125; 求斐波拉契数列的第n项 12345int Fib(int n)&#123; if(n==0) return 0; else if(n==1) return 1; else return Fib(n-1)+Fib(n-2);&#125; 队列队列是只允许在一端进行插入，而在另一端进行删除的线性表 队头（Front）：允许删除的一端，队首 队尾（Rear）：允许插入的一端 顺序队列用数组实现队列，可以将队首放在数组下标为0的位置 12345#define MaxSize 50typedef struct&#123; ElemType data[MaxSize];//存放队列的元素 int front,rear;//队头指针和队尾指针&#125; 循环队列入队：rear=(rear+1)%MaxSize 出队：front=(front+1)%MaxSize 判断队列是空是满 设置标志位flag，当flag=0且rear等于front时为队列空，当flag=1且rear等于front时为队列满（入队时flag等于1，出队时flag等于0） 把front==rear仅作为队空的判定条件。当队列满的时候，令数组中仍然保留一个空余单元。认为这种情况就是队列满了 队满关系 (rear+1)%MaxSize==front 队列中元素个数 (rear-front+MaxSize)%MaxSize 入队123456bool EnQueue(SqQueue &amp;Q,ElemType x)&#123; if((Q.rear+1)%MaxSize==Q.front) return flase;//队满 Q.data[Q.rear]=x; Q.rear=(Q.rear+1)%MaxSize; return true;&#125; 出队123456bool DeQueue(SqQueue &amp;Q,ElemType &amp;x)&#123; if(Q.rear==Q.front) return false;//队空，报错 x=Q.data[Q.front]; Q.front=(Q.front+1)%MaxSize; return true;&#125; 链式队列队列的链式存储结构，其实就是线性表的单链表，只不过需要加点限制，只能表尾插入元素，表头删除元素 分别设置队头指针和队尾指针，队头指针指向头结点，队尾指针指向队尾结点 12345678typedef struct&#123;//链式队列结点 ElemType data; struct LinkNode *next;&#125;LinkNode;typedef struct&#123;//链式队列 LinkNode *front,*rear;//队头和队尾指针&#125;LinkQueue; 入队1234567void EnQueue(LinkQueue &amp;Q,ElemType x)&#123; s=(LinkNode*)malloc(sizeof(LinkNode)); s-&gt;data=x; s-&gt;next=NULL; Q.rear-&gt;next=s; Q.rear=s;&#125; 出队出队就是头结点的后继结点出队，然后将头结点的后继改为它后面的结点 123456789bool DeQueue(LinkQueue &amp;Q,ElemType &amp;x)&#123; if(Q.front==Q.rear) return false;//空队 p=Q.front-&gt;next; x=p-&gt;data; Q.front-&gt;next=p-&gt;next; if(Q.rear==p) Q.rear=Q.front;//若原队列中只有一个结点，删除后变空 free(p); return true;&#125; 双端队列双端队列是指允许两端都可以进行入队和出队操作的队列 矩阵对于二维数组，两种映射方法：按行优先和按列优先 行优先 列优先 矩阵的压缩存储对称矩阵 三角矩阵 三对角矩阵 稀疏矩阵]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法复杂度]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F1%20%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%2F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[算法复杂度算法是对问题求解步骤的描述，通过有限序列的指令来实现 五大特征 有穷性：有限步之后结束 确定性：不存在二义性 可行性 输入 输出 时间复杂度用来衡量算法随着问题规模增大，算法执行时间的增大的快慢 时间复杂度是问题规模的函数：T(n) T(n)=O(f(n))，大O记法 计算方法： 算法时间增长最快的那个函数项，把它的系数改为1 空间复杂度 用来衡量算法随问题规模增大，算法所需空间的增长的快慢 是问题规模的函数：S(n)=O(g(n)) 常见的时间复杂度大小关系 O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n2)&lt;O(n3)&lt;O(2n)]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库之基础知识]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[数据库之基础知识命令行操作MySQLDOS命令 盘符+冒号 切换逻辑盘 如：d:dir 显示目录和文件列表cd 目录名 进入目录cd ../ 进入上一级目录cd ./ 进入当前目录cd / 进入根目录exit 退出命令行 连接数据库 语法：mysql -h主机名 -u用户名 -p密码如：mysql -hlocalhost -uroot -proot注意：当提示符变成 mysql&gt; 说明我们已经进入mysql命令行模式，只能使用sql指令sql指令都需要以分号 ; 结束quit 退出mysql exit 退出命令行 数据库操作创建数据库 1create database 数据库名 显示数据库 12345678show database；显示服务器上的所有的数据库列表破show database like '%a%'; like 子命令，显示所有名字里带a的数据库名show databases like '___'; like 子命令，显示数据库名是三个字符的所有数据库名% 匹配0个或者多个任意字符_ 下划线，匹配任意一个字符show create database 数据库名; 查看建立数据库的语句 修改数据库 1alter database 数据库名 charset=gbk; 修改指定的数据库的字符集，只能修改数据的字符集，数据库名不能修改。 删除数据库 1drop database 数据库名; 删除指定的数据库 MySQL里面的三个数据库mysql、information_schema、performance_schema是系统默认自带的，不可删除，删了需重装MySQL 数据库操作创建数据表 1create table 表名(id int,username varchar(30),password varchar(30)); 查看表 123show tables; 查看所有的数据表show create table 表名; 查看数据表的建表语句desc 表名; 查看数据表的结构 删除表 1drop table 表名; 查看数据表的结构 修改表 123alter table 表名 engine=innodb; 可以修改默认引擎alter table 表名 charset=gbk; 可以修改字符集rename table 表名 to 另一个表名; 可以修改表名 字段操作增加新字段 12alter table student add column gender varchar(2);在student数据表中新增gender字段 修改字段的类型和属性 123456alter table student modify column gender varchar(10);修改student数据表中gender字段数据类型alter table student modify column gender varchar(10) after 另一个字段;修改student数据表中gender字段数据类型，并且在数据表中排在 “另一个字段” 后面alter table student modify column gender varchar(10) first;修改student数据表中gender字段数据类型，并且在数据表中排在第一位 修改字段的名字和定义 12alter table student change column gender sex varchar(2);把student数据表中gender字段名字改为sex，数据类型改为varchar(2); 删除字段 12alter table student drop column gender;删除student数据表中的gender字段; 记录操作新增记录 12345678insert into 表名(字段列表) values (值的列表);例子：insert into student(username) values('中文');insert into student(id,username,age) values(3,'中文',20);批量新增：insert into student(id,username,age) values (3,'张三',18),(4,'李四',20),(5,'刘五',22);值的个数与数据表中的字段个数一样时，可以省略字段列表insert into student values(4,'中文',20); 查询记录 完整语句：select [字段列表] [from子句] [inner join子句] [where子句] [group by子句] [having子句] [order by子句] [limit子句]; 一般使用： select [字段列表] [from子句] [where子句] [order by子句] [limit子句]; [where子句] 用于过滤数据，只取出满足条件的记录 1select * from student where age &gt;= 20; 查询出 age &gt;= 20的记录 [order by子句] 用于对查询出的数据进行排序 1select * from student where age &gt;= 20 order by age asc; 年龄升序排列 asc升序排列 （从小到大）、desc 降序排序 （从大到小） [limit子句] 用于限制输出数据的条数 123limit n; 提取前 n 条数据limit m,n; 从 第 m 条开始提取 n 条数据**（m 从 0 开始）**select * from student where age &gt;= 20 order by age asc limit 2; 查询出 age &gt;= 20的记录年龄，升序排列，提取前 2 条 修改记录 123update 表名 set 字段名1=新的值1,字段名2=新的值2,字段名n=新的值n where 子句;例子：update student set age=25 where id=8; 删除记录 123delete from 表名 where 子句;例子：delete from student where id=8; mysql中常用数据类型 数据类型 描述 INT(size) 4字节整数类型，-2147483648 到 2147483647 常规。0 到 4294967295 无符号*。在括号中规定最大位数，默认是11。 BIGINT(size) 8字节整数类型，-9223372036854775808 到 9223372036854775807 常规。0 到 18446744073709551615 无符号*。在括号中规定最大位数。默认是20。 FLOAT(size,d) 字节浮点数，带有浮动小数点的小数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。 CHAR(size) 保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。 VARCHAR(size) 保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。注释：如果值的长度大于 255，则被转换为 TEXT 类型。 TEXT 存放最大长度为 65,535 个字符的字符串。 DATE() 日期。格式：YYYY-MM-DD 注释：支持的范围是从 ‘1000-01-01’ 到 ‘9999-12-31’ DATETIME() *日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS 注释：支持的范围是从 ‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’ TIMESTAMP() *时间戳。TIMESTAMP 值使用 Unix 纪元(‘1970-01-01 00:00:00’ UTC) 至今的描述来存储。格式：YYYY-MM-DD HH:MM:SS 注释：支持的范围是从 ‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-09 03:14:07’ UTC]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F2%20%E7%BA%BF%E6%80%A7%E8%A1%A8%2F%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[线性表线性表是具有相同数据类型的n(n&gt;=0)个数据元素的有限序列 线性表的顺序存储是用一组地址连续的存储单元，依次存储线性表中的数据元素，顺序存储的线性表也叫顺序表 静态建表： 存储空间的起始位置 顺序表最大存储容量 顺序表当前的长度 数组是静态分配的（大小固定） 其实存储空间（数组）还可以动态分配，也就是存储数组的空间是在程序执行过程中通过动态分配语句来分配的 1234567891011typedef int Elemtype;typedef struct&#123; ElemType *data;//指示动态分配数组的指针 int MaxSize,length;//数组的最大容量和当前个数&#125;SeqList;动态分配语句#define InitSize 100SeqList L;L.data=(ElemType*)malloc(sezeof(ElemType)*InitSize); 动态分配并不是链式存储，同样还是属于顺序存储结构，只是分配的空间大小可以在运行时决定 顺序表的操作插入12345678910111213在顺序表L的第i（1&lt;=i&lt;=L.length）个位置插入新元素e。如果i的输入不合法，则返回false,表示插入失败；否则，将顺序表的第i个元素以及其后的所有元素右移一个位置，腾出一个空位置插入新元素e，顺序表长度增加1，插入成功，返回truebool ListInsert(SqlList &amp;L,int i,ElemType e)&#123; if(i&lt;1||i&gt;L.length+1)//判断i的范围是否有效 return false; if(L.length&gt;=MaxSize)//当前的存储空间已满，不能插入 return false; for(int j=L.length;j&gt;=i;j--)//将第i个元素及之后的元素后移 L.data[j]=L.data[j-1]; L.data[i-1]=e; L.lengt++; return true;&#125; 删除1234567891011删除顺序表L中第i（1&lt;=i&lt;=L.length）个位置的元素，成功则返回true，并将被删除的元素用应用变量e返回；否则返回falsebool ListDelete(SqList &amp;L,int i,ElemType &amp;e)&#123; if(i&lt;1||i&gt;L.length+1)//判断i的范围是否有效 return false; e=L.data[i-1]; for(int j=i;j&lt;L.length;j++) L.data[j-1]=L.data[j]; L.length--; return true;&#125; 优点： 存储密度大，不需要为表中元素之间的逻辑关系增加额外存储空间 随机存取：可以快速存取表中任一位置的元素 缺点： 插入和删除需要移动大量元素 对存储空间要求高，会产生存储空间的碎片 链式存储 线性表的链式存储是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立起数据元素之间的线性关系，每个链表结点，除了存放元素自身的信息之外，还需要存放一个指向其后继的指针。 1234typedef struct LNode&#123; ElemType data;//数据域 struct LNode *next;//指针域&#125;LNode,*LinkList; 通常用“头指针”来标识一个单链表，例如LinkList L，那么头指针L代表一个单链表 单链表第一个结点之前附加一个结点，称为头结点，头结点的数据域可以不设任何信息，也可以记录表长等相关信息。头结点的指针域指向线性表的第一个元素结点。 单链表操作头插法建立单链表建立新的结点分配内存空间，将新结点插入当前链表的表头 12345678910111213141516//默认有空的头结点LinkList CreatList1(LinkList &amp;L)&#123; LNode *s; int x;//存储插入结点的数据的值 L=(LinkList)malloc(sizeof(LNode));//创建头结点 L-&gt;next=NULL;//初始化为空链表 scanf("%d",&amp;x);//输入结点的值 while(x!=9999)&#123;//输入9999表示结束 s=(LNode*)malloc(sizeif(LNode));//创建新结点 s-&gt;data=x;//对新结点的数据域赋值 s-&gt;next=L-&gt;next;//新结点的后继指向第一个结点 L-&gt;next=s;//头结点的后继指向新结点 sanf("%d",&amp;x); &#125; return L;&#125; 尾插法建立单链表建立新的结点分配内存空间，将新的结点插入到当前链表的表尾 123456789101112131415LinkList CreatList2(LinkList &amp;L)&#123; int x;//存储插入结点的数据的值 L=(LinkList)malloc(sizeof(LNode));//创建头结点 LNode *s,*r=L;//r为表尾指针，指向表尾 scanf("%d",&amp;x);//输入结点的值 while(x!=9999)&#123;//输入9999表示结束 s=(LNode*)malloc(sizeif(LNode));//创建新结点 s-&gt;data=x;//对新结点的数据域赋值 r-&gt;next=s; r=s; sanf("%d",&amp;x); &#125; r-&gt;next=NULL; return L;&#125; 按序号查找结点在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL 1234567891011LNode *GEtElem(LinkList L,int i)&#123; int j=1;//计数，初始为1 LNode *p=L-&gt;next;//第一个结点指针赋给p if(i==0) return L;//若i等于0，返回头结点 if(i&lt;1) return NULL; while(p&amp;&amp;j&lt;i)&#123;//从第一个结点开始找，查找第i个结点 p=p-&gt;next; j++; &#125; return p;&#125; 按值查找结点 1234567LNode *Locate(LinkList L,ElemType e)&#123; LNode *p=L-&gt;next; while(p!=NULL&amp;&amp;p-&gt;data!=e)&#123;//从第一个结点开始找 p=p-&gt;next; &#125; return p;&#125; 插入新结点插入操作是将值为x的新结点插入到单链表的第i个位置上。先检查插入位置和合法性，然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点 算法思路： 取指向插入位置的前驱结点的指针p=GetElem(L,i-1); 取新结点s的指针域指向 p的后继结点s-&gt;next=p-&gt;next 令结点p的指针域指向新插入的结点 s p-&gt;next=s; 删除一个结点删除操作是将单链表的第i个结点删除，先检查删除位置的合法性，然后查找表中第i-1个结点，即被删除结点的前驱结点，再将其删除 算法思路： 取指向删除位置的前驱结点的指针 p=GetElem(L,i-1); 取指向删除位置的指针 q=p-&gt;next; p指向结点的后继指向被删除结点的后继 p-&gt;next=q-&gt;next 双链表123456789typedef struct LNode&#123; ElemType data; structLNode *node;&#125;LNode,*LinkList;typedef struct DNode&#123; ElemType data; struct DNode *prior,*next;//前驱和后继指针&#125;DNode,*DLinkList; 插入 s-&gt;next=p-&gt;next p-next-&gt;prior=s s-&gt;prior=p p-&gt;next=s 删除 p-&gt;next=q-&gt;next q-&gt;next-&gt;prior=p free(q) 循环链表&amp;静态链表循环单链表：循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环 循环单链表的判空条件不是头结点的后继指针是否为空，而是它是否等于头指针 循环双链表 静态链表 使用数组来描述线性表的链式存储结构 123456#define MaxSize 50//静态链表的最大长度typedef int ElemType//静态链表的数据类型假定为inttypedef struct&#123; ElemType data;//数据域，存储数据元素 int next;//指针域，下一个元素的数组下标&#125;SLinkList[MaxSize]; 数组第一个元素不存储数据，它的指针域存储第一个元素所在的数组下标。 链表最后一个元素的指针域值为-1]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F5%20%E5%9B%BE%2F%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[图基本概念图G由顶点集V和边集E组成，记为G=(V,E) 简单图和多重图简单图 不存在顶点到自身的边 同一条边不重复出现 多重图 若图G中某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联 完全图无向完全图：如果任意两个顶点之间都存在边 有向完全图：如果任意两个顶点之间都存在方向相反的两条弧 子图 连通图 强连通 连通图的生成树 度 权和网 基本概念总结 图的存储结构 邻接矩阵(顺序存储) 邻接表(链式存储) 十字链表(有向图) 邻接多重表(无向图) 邻接矩阵顶点：用一维数组来存储 边或弧：用二维数组来存储 二维数组就是一维数组的扩展，相当于一维数组中每个元素也是一维数组，二维数组也叫做邻接矩阵 无向图的邻接矩阵 有向图的邻接矩阵 邻接表对于稀疏图(E远小于V)，顺序存储结构存在预先分配内存可能浪费的问题 无向图邻接表 有向图邻接表 十字链表十字链表是针对有向图的存储方式，对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点 十字链表数据结构 邻接多重表 边表结构 图的遍历图的遍历：从图中某一个顶点出发遍历图中其余的顶点，且使每一个顶点仅访问一次，这个过程叫做图的遍历 图中顶点没有特殊性，可能存在沿着某条路径搜索后回到原起点，而有些顶点没有访问到。 解决办法：设置一个访问数组，记录遍历过程中访问过的顶点。 广度优先遍历(BFS) BFS算法实例 BFS空间复杂度 BFS需要借助一个队列，n个顶点均需要入队一次，所以最坏情况下n个顶点在队列，那么则需要O(|V|)的空间复杂度 BFS时间复杂度 邻接表：每个顶点入队一次，时间复杂度为O(|V|)，对于每个顶点，搜索它的邻接点，就需要访问这个顶点的所有边，所以时间复杂度为O(|E|)。所以总的时间复杂度为O(|V|+|E|)。 邻接矩阵：每个顶点入队一次，时间复杂度为O(|V|)，对于每个顶点，搜索它的邻接点，需要遍历一遍矩阵，所以时间复杂度为O(|V|)，所以总的时间复杂度为O(|V|2)。 BFS应用 BFS解决单源非带权图最短路径问题：按照距离由近到远来遍历图中每个顶点 广度优先生成树 深度优先遍历(DFS)深度优先遍历（DFS：Depth-First-Serch）：深度优先遍历类似于树的先序遍历算法 遍历过程：首先访问图中某一起始顶点v，然后由v出发，访问与v邻接且未被访问的任一顶点w1，再访问与w1邻接且未被访问的任一顶点w2，。。。。重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直到图中所有顶点均被访问过为止。 深度优先复杂度 空间复杂度： 由于DFS是一个递归算法，递归是一个需要工作栈来辅助工作，最多需要图中所有顶点进栈，所以空间复杂度为O(|V|) 时间复杂度： 邻接表：遍历过程的主要操作是对顶点遍历它的邻接点，由于通过访问边表来查找邻接点，所以时间复杂度为O(|E|)，访问访问顶点时间为O(|V|)，所以总的时间复杂度为O(|V|+|E|)。 邻接矩阵：查找每个顶点的邻接点时间复杂度为O(|V|)，对每个顶点都进行查找，所以总的时间复杂度O(|V|2)。 深度优先生成树 图的应用最小生成树(Prim、Kruskal)连通图的生成树，是一个极小的连通子图。包含图中全部的顶点，但只有足以构成一棵树的n-1条边 普里姆(Prim)算法 克鲁斯卡尔(Kruskal)算法 普里姆算法 初始化 i=1 i=2 i=3 i=4 i=5 i=6 Prim算法时间复杂度 克鲁斯卡尔算法(Kruskal) 并查集 算法思路 初始化，将边权值进行排序 第一次 第二次 第三次 第四次 第五次 第六次 第七次 4-6之后的边循环都不进行操作了，已经形成六条边(n-1)，形成最小生成树 克鲁斯卡尔算法复杂度 最短路径(Dijkstra、floyd) 迪杰斯特拉算法：一个源点到其余顶点的最短路径 弗洛伊德算法：所有顶点到所有顶点的最短路径 迪杰斯特拉算法思路： 迪杰斯特拉算法实例 第一次 第二次 第三次 第四次 第五次 迪杰斯特拉算法代码 迪杰斯特拉复杂度 弗洛伊德算法 弗洛伊德算法是求图中任意一对顶点间的最短路径的算法 算法思想： 佛洛依德算法实例 初始化 第一次 第二次 第三次 第四次 弗洛伊德算法代码和复杂度 拓扑排序AOV网 拓扑排序算法思路 第一轮： 第二轮： 第三轮： 第四轮： 第五轮： 第六轮： 第七轮： 拓扑排序算法代码 拓扑排序算法复杂度 拓扑排序规律 关键路径AOE网 关键路径 寻找关键路径步骤]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树与二叉树]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F4%20%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%2F%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[树与二叉树一对多的树形结构 树的性质 树中的结点等于所有结点的度数加1 度为m的树中第i层上至多有mi-1个结点（i&gt;=1） 高度为h的m叉树至多有（mh-1)/(m-1)个结点 具有n个结点的m叉树的最小高度为取上整[logm(n(m-1)+1)] 解上一个方程的h即可 树的存储结构顺序存储结构双亲表示法：用一组连续的存储空间存储树的结点，同时在每个结点中，用一个变量存储该结点的双亲结点在数组中的位置 1234567891011typedef char ElemType;typedef struct TNode&#123; ElemType data;//结点数据 int parent;//该结点双亲在数组的下标&#125;TNode;//结点的数据类型#define MaxSize 100typedef struct&#123; TNode nodes[MaxSize];//结点数组 int n;//结点的数量&#125;Tree;//结点双亲表示结构 双亲表示法可以根据parent找到该结点的双亲结点，时间复杂度为O(1)。但如果找到某节点的孩子结点就需要遍历 链式存储结构孩子表示法：把每个结点的孩子结点排列起来存储成一个单链表。所以n个结点就有n个链表；如果时叶子结点，那这个结点的孩子单链表就是空的；然后n个单链表的头指针又存储在一个顺序表（数组）中。 需要设计两种结合结构类型： 孩子链表的结点 每个孩子链表的表头结点（存在数组中） 12345678910typedef char ElemType;typedef struct CNode&#123; int child;//该孩子在表头数组的下标 struct CNode *next;//指向该结点的下一个孩子结点&#125;CNode,*Child;//孩子结点数据结构typedef struct&#123; Elemtype data;//结点数据域 Child firstchild;//指向该结点的第一个孩子结点&#125;TNode//孩子结点的数据类型 12345#define MaxSize 100typedef struct&#123; TNode nodes[MaxSize];//结点数据域 int n;//树中结点个数&#125;Tree;//树的孩子表示结构 孩子兄弟表示法：要存储孩子结点和兄弟结点，就是设置两个指针，分别指向该结点的第一个孩子结点和该结点的兄弟结点。 12345typedef char ElemType;typedef struct CSNode&#123; ElemType data;//该结点的数据域 struct CSNode *firstchild,*rightsib//指向该结点的第一个孩子结点和该结点的右兄弟结点&#125;CSNode;//孩子兄弟结点数据类型 二叉树每个结点最多有两颗子树 左右子树有顺序 五种基本形态 特殊二叉树 二叉树性质 非空二叉树上叶子结点等于度为2的结点数加1 非空二叉树上第K层上至多有2k-1个结点（k&gt;=1） 高度为H的二叉树至多有2H-1个结点（H&gt;=1） 具有N个(N&gt;0)结点的完全二叉树的高度为上取整[log2(N+1)]或下取整[log2N]+1 二叉树的存储结构顺序存储结构二叉树的顺序存储结构就是用一组地址连续的存储单元依次自上而下，自左而右存储完全二叉树上的结点元素 链式存储结构二叉树每个结点最多两个孩子，所以设计二叉树的结点结构时考虑两个指针指向该结点的两个孩子 1234typedef struct BiTNode&#123; ElemType data;//数据域 struct BiTNode *lchild,*rchild;//指向该结点的左右孩子指针&#125;BiTNode,*BiTNode;//二叉树结点结构 二叉树遍历(递归)二叉树的遍历是指按某种次序依次访问树中的每个结点，使得每个结点均被访问一次，而且仅被访问一次 递归先序遍历操作过程： 访问根结点 先序遍历左子树 先序遍历右子树 1234567void PreOrder(BiTree T)&#123; if(T!=NULL)&#123; printf("%c",T-&gt;data)//根节点 PreOrder(T-&gt;lchild);//左子树 PreOrder(T-&gt;rchild);//右子树 &#125;&#125; 递归中序遍历操作过程： 中序遍历左子树 访问根节点 中序遍历右子树 1234567void InOrder(BiTree T)&#123; if(T!=NULL)&#123; InOrder(T-&gt;lchild); printf("%c",T-&gt;data); InOrder(T-&gt;rchild); &#125;&#125; 递归后序遍历操作过程： 后序遍历左子树 后序遍历右子树 访问根节点 1234567void PostOrder(BiTree T)&#123; if(T!=NULL)&#123; PostOrder(T-&gt;lchild); PostOrder(T-&gt;rchild); printf("%c",T-&gt;data); &#125;&#125; 二叉树遍历(非递归)非递归先序遍历123456789101112131415void PreOrderTraverse(BiTree b)&#123; InitStack(S); BitTree p=b;//工作指针p while(p || !IsEmpty(S))&#123; while(p)&#123; printf("%c",p-&gt;data);//先序先遍历结点 Push(S,p);//进栈保存 p=p-&gt;lchild; &#125; if(!IsEmpty(S))&#123; p=Pop(S); p=p-rchild; &#125; &#125;&#125; 非递归中序遍历12345678910111213void InOrderTraverse(BiTree b)&#123; InitStack(S); BitTree p=b;//工作指针p while(p || !IsEmpty(S))&#123; while(p)&#123; Push(S,p);//进栈保存 p=p-&gt;lchild; &#125; p=Pop(S); printf("%c",p-&gt;data); p=p-rchild; &#125;&#125; 非递归后序遍历 层序遍历操作过程： 若树为空，则什么都不做直接返回； 否则从树的第一层开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问 出队-&gt;访问-&gt;左右孩子入队 12345678910111213void LevelOrder(BiTree b)&#123; InitQueue(Q); BiTree p; EnQueue(Q,b);//根节点入队 while(!IsEmpty(Q))&#123; DeQueue(Q,p);//队头元素出队 printf("%c",p-&gt;data); if(p-&gt;lchild!=NULL) EnQueue(Q,p-&gt;lchild); if(p-&gt;rchild!=NULL) EnQueue(Q,p-&gt;rchild); &#125;&#125; 线索二叉树二叉链表表示的二叉树存在大量空指针 N个结点的二叉树，每个结点都有指向左右孩子的结点指针，所以一共有2N个指针，而N个结点的二叉树一共有N-1个分支，也就是说存在2N-(N-1)=N+1个空指针。 指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树 对二叉树以某种次序遍历使其变为线索二叉树的过程叫做线索化。 如何区分指针是指向左孩子还是前驱，右孩子还是后继？ 在二叉链表结点的结构基础上增加两个标志位ltag和rtag 12345typedef struct ThreadNode&#123; ElemType data; struct ThreadNode *lchild,*rchild; int ltag,rtag;&#125;ThreadNode,*ThreadTree;//线索链表 ltag==0表示lchild指向该结点左孩子 ltag==1表示rchild指向该结点前驱 rtag==0表示rchild指向该结点右孩子 rtag==1表示指向该结点后继 构造线索二叉树 遍历线索二叉树 哈夫曼树和哈夫曼编码概念： 权：树中结点相关的数值 路径长度：从树中某个结点到另一个结点之间的分支数目（经过的边数） 带权路径长度：从树的根节点到任意结点的路径长度（经过的边数）与该结点上权值的乘积称为该结点的带权路径长度 哈夫曼树：含有N个带权叶子结点的二叉树中，带有带权路径长度（WPL）最小的二叉树，也成为最优二叉树。 设计哈夫曼树 将这N个结点分别作为N颗仅含一个结点的二叉树，构成森林F 构造一个新结点，并从F中选取两颗根节点权值最小的树作为新结点的左右子树，并且将新结点的权值置为左右子树上根节点的权值之和 从F中删除刚才选出的两棵树，同时将新得到的树加入F中 重复步骤2和3，直至F中只剩下一棵树为止 哈夫曼编码左子树为0，右子树为1 哈夫曼编码性质 哈夫曼编码是前缀编码 哈夫曼编码是最优前缀编码 二叉树、树和森林树转化成二叉树用到一个孩子兄弟表示法（回归本章树的链式存储） 二叉树转树 森林转二叉树 二叉树转森林 树和森林的遍历树的先序遍历 树的后序遍历 森林遍历]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F7%20%E6%8E%92%E5%BA%8F%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[排序排序就是将原本无序的序列重新排列成有序的序列 排序的稳定性 内部排序：指的是待排序记录全部存放在计算机内存中进行排序的过程 外部排序：指的是待排序的记录的数量很大，以致内存一次不能容纳全部记录，在排序过程中尚需要对外存进行访问的排序过程 内部排序分类 插入类：将无序子序列中的一个或几个记录插入到有序序列中，从而增加记录的有序子序列的长度，包括直接插入排序、折半插入排序、希尔排序 交换类：通过交换无序序列中的记录从而得到其中关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度，包括冒泡排序和快速排序 选择类：从记录的无序子序列中选择关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加有序子序列的长度，包括简单选择排序、树形选择排序、堆排序 归并类：通过归并两个或两个以上的记录有序子序列，逐步增加记录有序序列的长度，包括2路归并排序 分配类：是唯一一类不需要关键字之间的比较的排序方法，排序时主要利用分配和收集两种基本操作完成。基数排序是主要的分配类排序 插入排序直接插入排序 空间时间复杂度 时间复杂度最好O(n)，最坏O(n2) 直接插入排序是稳定的 折半查找排序 折半排序代码 时间复杂度 时间复杂度O(n2) 折半插入排序是稳定的 希尔排序 希尔排序过程 第一趟：10个元素取增量10/2=5 第二趟：5/2向下取整=2 第三趟：最后增量为1 希尔排序的时间复杂度 时间复杂度最好O(n1.3)，最坏O(n2). 希尔排序不稳定 交换排序交换类排序：根据序列中两个元素关键字的比较结果来交换它两在序列中的位置 冒泡排序 冒泡排序代码 冒泡排序时间复杂度最好O(n)，最坏O(n2). 冒泡排序稳定. 快速排序快速排序是一种基于分治法的排序方法 快速排序代码 快速排序时间复杂度最好O(nlogn)，最坏O(n2). 序列越乱序，效率越高；序列越有序，效率越低 空间复杂度最好O(logn)，最坏O(n). 快速排序不稳定. 选择排序 简单选择排序 简单选择排序时间复杂度O(n2) 不稳定，交换会打破顺序 堆排序堆的定义 大顶堆过程 堆排序算法 堆排序时间复杂度O(nlog2n)，空间复杂度O(1)。 堆排序不稳定. 归并排序 归并排序代码 时间复杂度O(nlogn),空间复杂度O(n) 归并排序稳定 非比较排序基数排序(桶排序) MSD]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找]]></title>
    <url>%2F2019%2F05%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F6%20%E6%9F%A5%E6%89%BE%2F%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[查找查找：在数据集合中寻找满足某种条件的数据元素的过程 关键字：数据元素中某个可以唯一标识该元素的数据项 平均查找长度 顺序查找 折半查找 分块查找分块查找又称为索引顺序查找 二叉排序树 二叉排序树查找递归代码 二叉排序树查找非递归代码 二叉排序树插入关键字代码 时间复杂度 有n个结点就需要插入n个结点操作，插入一个的时间复杂度为O(log2n)，构造复杂度为O(nlog2n) 二叉排序树构造代码 二叉排序树删除结点 删除叶子结点 删除只有左子树或者右子树的结点 删除左右子树都有的结点 找到该结点的前驱和后继(即中序遍历的前驱和后继) 前驱替代结点 后继替代结点 二叉排序树分析 平衡二叉树(AVL树) 最小不平衡子树 不平衡二叉树类型 构建平衡二叉树过程 LL调整 RR调整 RL调整 平衡二叉树结点规律 B树和B+树2-3树： 2-3是一种多路查找树：2和3的意思就是2-3树包含两种结点 2-3-4树： B树 磁盘管理系统中的目录管理，以及数据库系统中的索引组织多数都采用B树数据结构 B树查找操作 B树插入操作 B树删除操作 删除的关键字在终端结点上(最底层非叶子结点) 第一种情况 第二种情况 第三中情况 删除关键字不在终端结点上(最底层非叶子结点) 第一种情况 第二种情况 B+树 B+树是B树的变形树，适合用于文件索引系统 散列表散列表基本概念 散列函数和冲突处理方法 常用Hash函数的构造方法 常用Hash函数的冲突处理方法 开放地址法 拉链法(链地址法) 散列表的查找过程和性能 散列表实例 ASL计算方式：查找成功ASL看关键字，查找失败ASL看地址个数 开放地址法(线性探测再散列法)计算ASL：https://blog.csdn.net/wangran51/article/details/8826633/ KMP算法KMP算法是用于解决字符串模式匹配的问题，字符串的模式匹配，是求一个字符串（模式串）在另一个字符串（主串）中的位置 BF(Brute-Force)算法 BF算法效率O(n*m) KMP算法 KMP算法next数组 next例子情况 当P[k] == P[j]时， 有next[j+1] == next[j] + 1 当P[k] != P[j] 像上边的例子，我们已经不可能找到[ A，B，A，B ]这个最长的后缀串了，但我们还是可能找到[ A，B ]、[ B ]这样的前缀串的。所以这个过程像不像在定位[ A，B，A，C ]这个串，当C和主串不一样了（也就是k位置不一样了），那当然是把指针移动到next[k]啦。 KMP算法代码 KMP算法效率 手动求解next数组的值]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb知识总结]]></title>
    <url>%2F2019%2F01%2F26%2FJavaWeb%E7%9F%A5%E8%AF%86%2FJavaWeb%2F</url>
    <content type="text"><![CDATA[XMLXML的作用 1231.可以用来保存数据2.可以用来配置文件3.数据传输载体 定义xml 1234567文档声明 简单声明，version:解析这个xml使用什么版本的解析器解析 &lt;?xml version=&quot;1.0&quot; ?&gt; encoding:解析xml文字使用什么编码来翻译，电脑上的文件在保存时是存储文字对应的二进制，这些文字对应 的二进制使用编码解析得到 &lt;?xml version=&quot;1.0&quot; encoding=&quot;gbk(UTF-8)&quot;?&gt; standalone:no---文档会依赖关联其他文档，yes---这是一个独立的文档 &lt;?xml version=&quot;1.0&quot; encoding=&quot;gbk(UTF-8)&quot; standalone=&quot;no&quot;?&gt; 元素定义 12341.&lt;&gt;里面都是元素，成对出现，如：&lt;stu&gt;&lt;/stu&gt;2.文档声明第一个出现的元素是根元素3.空标签&lt;age/&gt;,开始也是结束，里面可以写属性4.标签可以自定义 注释 1&lt;!-- --&gt;与HTML注释一样 CDATA区 XML解析方式(常用两种DOM&amp;SAX) 1获取元素里面的字符或者属性数据 XML解析手段(DOM4J&amp;JDOM) DOM4J 基本用法 123456element.element(&quot;stu&quot;);//返回该元素下的第一个stu元素element.elements();//返回该元素下的所有子元素1.创建SAXReader对象2.指定解析的xml3.获取根元素4.根据根元素获取子元素或者下面的子孙元素 12345678910111213141516171819202122232425262728293031323334353637package com.itheima.test;import java.util.*;import java.io.File;import org.dom4j.Document;import org.dom4j.Element;import org.dom4j.io.SAXReader;public class MainTest &#123; public static void main(String[] args) &#123; try &#123; //1.创建sax读取对象 SAXReader reader = new SAXReader();//jdbc --classloader //2.指定解析的xml源 Document document = reader.read(new File(&quot;src/xml/stus.xml&quot;)); //3.得到元素 Element rootElement = document.getRootElement(); //获取根元素下面的子元素 //System.out.println(rootElement.element(&quot;stu&quot;).element(&quot;age&quot;).getText()); List&lt;Element&gt; elements = rootElement.elements(); for(Element element : elements) &#123; String name = element.element(&quot;name&quot;).getText(); String age = element.element(&quot;age&quot;).getText(); String address = element.element(&quot;address&quot;).getText(); System.out.println(&quot;name:&quot;+name+&quot;--&quot;+&quot;age:&quot;+age+&quot;--&quot;+&quot;address:&quot;+address); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; Dom4J的Xpath使用 12345&gt; dom4j里面支持Xpath的写法。xpath其实是xml的路径语言，支持我们在解析xml的时候定位到一个具体的元素。1.添加jar包依赖 jaxen-1.1-beta-6.jar2.在查找指定节点的时候，根据xpath语法规则来查找3.后续的代码与以前的解析代码一样 12345678910111213141516171819202122232425262728293031323334353637package com.itheima.test;import java.util.*;import java.io.File;import org.dom4j.Document;import org.dom4j.Element;import org.dom4j.io.SAXReader;public class XpathTest &#123; public static void main(String[] args) &#123; try &#123; //1.创建sax读取对象 SAXReader reader = new SAXReader();//jdbc --classloader //2.指定解析的xml源 Document document = reader.read(new File(&quot;src/xml/stus.xml&quot;)); //3.得到元素 Element rootElement = document.getRootElement(); // 要想使用Xpath，还得添加支持的jar 获取第一个只返回第一个 Element nameElement = (Element) rootElement.selectSingleNode(&quot;//name&quot;); System.out.println(nameElement.getText()); System.out.println(&quot;####################&quot;); //获取文档中所有的name元素 List&lt;Element&gt; list = rootElement.selectNodes(&quot;//name&quot;); for(Element element : list) &#123; System.out.println(element.getText()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 约束 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556属性ID规定唯一或者元素只能出现一次DTD： 语法可读性差 1. 引入网络上的DTD &lt;!-- 引入dtd 来约束这个xml --&gt; &lt;!-- 文档类型 根标签名字 网络上的dtd dtd的名称 dtd的路径 &lt;!DOCTYPE stus PUBLIC &quot;//UNKNOWN/&quot; &quot;unknown.dtd&quot;&gt; --&gt; 1. 引入本地的DTD &lt;!-- 引入本地的DTD ： 根标签名字 引入本地的DTD dtd的位置 --&gt; &lt;!-- &lt;!DOCTYPE stus SYSTEM &quot;stus.dtd&quot;&gt; --&gt; 2. 直接在XML里面嵌入DTD的约束规则 &lt;!-- xml文档里面直接嵌入DTD的约束法则 --&gt; &lt;!DOCTYPE stus [ &lt;!ELEMENT stus (stu)&gt; &lt;!ELEMENT stu (name,age)&gt; &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT age (#PCDATA)&gt; ]&gt; &lt;stus&gt; &lt;stu&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;/stu&gt; &lt;/stus&gt;&lt;!ELEMENT stus (stu)&gt; : stus 下面有一个元素 stu ， 但是只有一个 &lt;!ELEMENT stu (name , age)&gt; stu下面有两个元素 name ,age 顺序必须name-age &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT age (#PCDATA)&gt; &lt;!ATTLIST stu id CDATA #IMPLIED&gt; stu有一个属性 文本类型， 该属性可有可无 元素的个数： ＋ 一个或多个 * 零个或多个 ? 零个或一个 属性的类型定义 CDATA : 属性是普通文字 ID : 属性的值必须唯一 &lt;!ELEMENT stu (name , age)&gt; 按照顺序来 &lt;!ELEMENT stu (name | age)&gt; 两个中只能包含一个子元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Schema： 其实就是一个xml，使用xml的语法规则，xml解析器解析方便，是为了替代DTD 但是Scheme约束文本内容比DTD的内容还要多，所以没有真正意思上的替代DTD约束文档： &lt;!-- xmlns : xml namespace : 名称空间 / 命名空间 targetNamespace : 目标名称空间 。 下面定义的那些元素都与这个名称空间绑定上。 elementFormDefault ： 元素的格式化情况。 --&gt; &lt;schema xmlns=&quot;http://www.w3.org/2001/XMLSchema&quot; targetNamespace=&quot;http://www.itheima.com/teacher&quot; elementFormDefault=&quot;qualified&quot;&gt; &lt;element name=&quot;teachers&quot;&gt; &lt;complexType&gt; &lt;sequence maxOccurs=&quot;unbounded&quot;&gt; &lt;!-- 这是一个复杂元素 --&gt; &lt;element name=&quot;teacher&quot;&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;!-- 以下两个是简单元素 --&gt; &lt;element name=&quot;name&quot; type=&quot;string&quot;&gt;&lt;/element&gt; &lt;element name=&quot;age&quot; type=&quot;int&quot;&gt;&lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/schema&gt;实例文档： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- xmlns:xsi : 这里必须是这样的写法，也就是这个值已经固定了。 xmlns : 这里是名称空间，也固定了，写的是schema里面的顶部目标名称空间 xsi:schemaLocation : 有两段： 前半段是名称空间，也是目标空间的值 ， 后面是约束文档的路径。 --&gt; &lt;teachers xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.itheima.com/teacher&quot; xsi:schemaLocation=&quot;http://www.itheima.com/teacher teacher.xsd&quot; &gt; &lt;teacher&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;19&lt;/age&gt; &lt;/teacher&gt; &lt;teacher&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;29&lt;/age&gt; &lt;/teacher&gt; &lt;teacher&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;29&lt;/age&gt; &lt;/teacher&gt; &lt;/teachers&gt;##名称空间的作用一个xml如果想指定它的约束规则， 假设使用的是DTD ，那么这个xml只能指定一个DTD，不能指定多个DTD 。 但是如果一个xml的约束是定义在schema里面，并且是多个schema，那么是可以的。简单的说： 一个xml 可以引用多个schema约束。 但是只能引用一个DTD约束。名称空间的作用就是在 写元素的时候，可以指定该元素使用的是哪一套约束规则。 默认情况下 ，如果只有一套规则，那么都可以这么写&lt;name&gt;张三&lt;/name&gt;&lt;aa:name&gt;&lt;/aa:name&gt;&lt;bb:name&gt;&lt;/bb:name&gt; Tomcat程序架构 1234C/S（Client/Server）QQ微信优点：有一部分代码写在客户端，用户体现差缺点：服务器更新，客户端跟着更新，占用资源大 123B/S（browser/Server）优点：客户端只要有浏览器就行，占用资源少，不用更新缺点：用户体现不佳 Web服务器 1234&gt;其实服务器就是一台电脑，配置比一般的好&gt;客户端在浏览器的地址栏输入地址，然后web服务器软件，接受请求，然后响应消息&gt;处理客户端的请求，返回资源|信息web应用 需要服务器支撑 index.html Tomcat目录 123456789101112bin&gt;&gt;jar bat startup.batconf&gt;&gt;tomcat的配置，server.xml web.xmllib&gt;&gt;tomcat运行所需的jar文件temp&gt;&gt;临时文件webapps&gt;&gt;存放着发布到tomcat服务器上的项目work&gt;&gt;jsp翻译成java文件存放地 发布项目到tomcat 1234567&gt;&gt;需求：如何能让其他电脑访问这台电脑上的资源 stu.xml&gt;&gt;localhost:8080:本地地址&gt;&gt;1.拷贝文件到这个webapps/root下，在浏览器访问： localhost:8080/stu.xml&gt;&gt;2.在webapps下新建文件夹xml，然后拷贝文件到该文件夹中 http://localhost:8080/xml/stu.xml http://localhost:8080/xml：对应到webapps/xml 123456789&gt;&gt;3.使用localhost：8080/docs 打开tomcat首页，找到configuration点击进入，再进入左侧找到context（http://localhost:8080/docs/config/context.html）&gt;&gt;&gt;&gt;配置虚拟路径&gt;&gt;&gt;&gt;1.在conf/server.xml找到host元素节点 2. 加入以下内容。 &lt;!-- docBase ： 项目的路径地址 如： D:\xml02\person.xml path : 对应的虚拟路径 一定要以/打头。 对应的访问方式为： http://localhost:8080/a/person.xml --&gt; &lt;Context docBase=&quot;D:\xml02&quot; path=&quot;/a&quot;&gt;&lt;/Context&gt; 3. 在浏览器地址栏上输入： http://localhost:8080/a/person.xml 1234567&gt;&gt;4. 配置虚拟路径&gt;&gt;&gt;&gt;1. 在tomcat/conf/catalina/localhost/ 文件夹下新建一个xml文件，名字 可以自己定义。 person.xml&gt;&gt;&gt;&gt;2. 在这个文件里面写入以下内容 &lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt; &lt;Context docBase=&quot;D:\xml02&quot;&gt;&lt;/Context&gt;&gt;&gt;&gt;&gt;3. 在浏览器上面访问 http://localhost:8080/person/xml的名字即可 eclipse配置tomcat 123456789101112131. 在server里面 右键新建一个服务器， 选择到apache分类， 找到对应的tomcat版本， 接着一步一步配置即可。2. 配置完毕后， 在server 里面， 右键刚才的服务器，然后open ， 找到上面的Server Location , 选择中间的 Use Tomcat installation...3. 创建web工程， 在WebContent下定义html文件， 右键工程， run as server ##总结：xml 1. 会定义xml 2. 会解析xml dom4j 基本解析 Xpath手法tomcat 1. 会安装 ，会启动 ， 会访问。 2. 会设置虚拟路径 3. 给eclipse配置tomcat JDBCJDBC 123JAVA DataBase Connectivity：java数据库连接&gt;&gt;为什么出现JDBC&gt;&gt;&gt;&gt;sun公司规定的一种数据访问规范，由于数据库种类较多，java语言使用广泛，sun公司提供一种，让其他的数据库提供商去实现底层的访问规则。我们的Java程序只要使用sun公司提供的jdbc驱动即可 JDBC入门 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.itheima.test;import java.net.URI;import java.sql.Connection;import java.sql.Driver;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class MainTest &#123; public static void main(String[] args) &#123; try &#123; //1.注册驱动 DriverManager.registerDriver(new com.mysql.jdbc.Driver()); //2.建立连接 参数一：协议+访问的数据库， 参数二：用户名，参数三：密码 //DriverManager.getConnection(&quot;jdbc:mysql://localhost/test? user=monty&amp;password=greatsqldb); Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost/student&quot;,&quot;root&quot;,&quot;123456&quot;); //3.创建statement，跟数据库读取一定需要这个对象 Statement st = conn.createStatement(); //4.执行查询，得到结果集 String sql = &quot;select * from t_stu&quot;; ResultSet rs = st.executeQuery(sql); while(rs.next()) &#123; int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); int age = rs.getInt(&quot;age&quot;); System.out.println(&quot;id&quot;+id+&quot;----&quot;+&quot;name&quot;+name+&quot;----&quot;+age+&quot;age&quot;); &#125; rs.close(); st.close(); conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; JDBC工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162JDBCUtil.javapackage com.itheima.util;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;/**释放资源 * @author Administrator * */public class JDBCUtil &#123; public static void release(Connection conn, Statement st, ResultSet rs) &#123; closeRs(rs); closeSt(st); closeConn(conn); &#125; private static void closeRs(ResultSet rs) &#123; try &#123; if(rs != null) &#123; rs.close(); &#125; &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125;finally &#123; rs = null; &#125; &#125; private static void closeSt(Statement st) &#123; try &#123; if(st != null) &#123; st.close(); &#125; &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125;finally &#123; st = null; &#125; &#125; private static void closeConn(Connection conn) &#123; try &#123; if(conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125;finally &#123; conn = null; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354MainTest.javapackage com.itheima.test;import java.net.URI;import java.sql.Connection;import java.sql.Driver;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import com.itheima.util.JDBCUtil;public class MainTest &#123; public static void main(String[] args) &#123; Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; //1.注册驱动 DriverManager.registerDriver(new com.mysql.jdbc.Driver()); //2.建立连接 参数一：协议+访问的数据库， 参数二：用户名，参数三：密码 //DriverManager.getConnection(&quot;jdbc:mysql://localhost/test?user=monty&amp;password=greatsqldb); conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost/student&quot;,&quot;root&quot;,&quot;123456&quot;); //3.创建statement，跟数据库读取一定需要这个对象 st = conn.createStatement(); //4.执行查询，得到结果集 String sql = &quot;select * from t_stu&quot;; rs = st.executeQuery(sql); System.out.println(&quot;id&quot;+&quot;---- &quot;+&quot;name&quot;+&quot;---- &quot;+&quot;age&quot;); while(rs.next()) &#123; int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); int age = rs.getInt(&quot;age&quot;); System.out.println(+id+&quot;----&quot;+name+&quot;----&quot;+age); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtil.release(conn, st, rs); &#125; &#125;&#125; JDBC使用步骤 1234567891011121314151617181920212223242526272829303132333435363738391. 注册驱动 DriverManager.registerDriver(new com.mysql.jdbc.Driver());2. 建立连接 //DriverManager.getConnection(&quot;jdbc:mysql://localhost/test?user=monty&amp;password=greatsqldb&quot;); //2. 建立连接 参数一： 协议 + 访问的数据库 ， 参数二： 用户名 ， 参数三： 密码。 conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost/student&quot;, &quot;root&quot;, &quot;root&quot;);3. 创建statement //3. 创建statement ， 跟数据库打交道，一定需要这个对象 st = conn.createStatement();4. 执行sql ，得到ResultSet //4. 执行查询 ， 得到结果集 String sql = &quot;select * from t_stu&quot;; rs = st.executeQuery(sql);5. 遍历结果集 //5. 遍历查询每一条记录 while(rs.next())&#123; int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); int age = rs.getInt(&quot;age&quot;); System.out.println(&quot;id=&quot;+id + &quot;===name=&quot;+name+&quot;==age=&quot;+age); &#125; 6. 释放资源 if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException sqlEx) &#123; &#125; // ignore rs = null; &#125; ... JDBC工具类构建 12345678910&gt;&gt;注册驱动1. 资源释放工作的整合2. 驱动防二次注册 DriverManager.registerDriver(new com.mysql.jdbc.Driver()); Driver 这个类里面有静态代码块，一上来就执行了，所以等同于我们注册了两次驱动。 其实没这个必要的。 //静态代码块 ---&gt; 类加载了，就执行。 //java.sql.DriverManager.registerDriver(new Driver());3.最后形成以下代码即可。 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); &gt;&gt;连接对象整合 代码重整 123456789101112131415161718192021222324252627282930&gt;&gt;使用properties配置文件1. 在src底下声明一个文件 xxx.properties ，里面的内容吐下： driverClass=com.mysql.jdbc.Driver url=jdbc:mysql://localhost/student name=root password=root2. 在工具类里面，使用静态代码块，读取属性&gt;&gt;&gt;&gt;static&#123; try &#123; //1. 创建一个属性配置对象 Properties properties = new Properties(); InputStream is = new FileInputStream(&quot;jdbc.properties&quot;); //对应文件位于工程根目录 //使用类加载器，去读取src底下的资源文件。 后面在servlet //对应文件位于src目录底下 //InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); //导入输入流。 properties.load(is); //读取属性 driverClass = properties.getProperty(&quot;driverClass&quot;); url = properties.getProperty(&quot;url&quot;); name = properties.getProperty(&quot;name&quot;); password = properties.getProperty(&quot;password&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; SQL的CRUD语句 123456789&gt;&gt;insertINSERT INTO t_stu (NAME , age) VALUES (&apos;wangqiang&apos;,28)INSERT INTO t_stu VALUES (NULL,&apos;wangqiang2&apos;,28)&gt;&gt;deleteDELETE FROM t_stu WHERE id = 6&gt;&gt;querySELECT * FROM t_stu&gt;&gt;updateUPDATE t_stu SET age = 38 WHERE id = 1; 12345678910&gt;&gt;使用单元测试，测试代码1. 定义一个类， TestXXX , 里面定义方法 testXXX.2. 添加junit的支持。 右键工程 --- add Library --- Junit --- Junit43. 在方法的上面加上注解 ， 其实就是一个标记。 @Test public void testQuery() &#123; ... &#125;4. 光标选中方法名字，然后右键执行单元测试。 或者是打开outline视图， 然后选择方法右键执行。 Dao模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849新建一个dao的接口， 里面声明数据库访问规则&gt;&gt;/** * 定义操作数据库的方法 */ public interface UserDao &#123; /** * 查询所有 */ void findAll(); &#125; 新建一个dao的实现类，具体实现早前定义的规则&gt;&gt;public class UserDaoImpl implements UserDao&#123; @Override public void findAll() &#123; Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; //1. 获取连接对象 conn = JDBCUtil.getConn(); //2. 创建statement对象 st = conn.createStatement(); String sql = &quot;select * from t_user&quot;; rs = st.executeQuery(sql); while(rs.next())&#123; String userName = rs.getString(&quot;username&quot;); String password = rs.getString(&quot;password&quot;); System.out.println(userName+&quot;=&quot;+password); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtil.release(conn, st, rs); &#125; &#125;&#125;直接使用实现&gt;&gt;@Test public void testFindAll()&#123; UserDao dao = new UserDaoImpl(); dao.findAll(); &#125; Statement安全问题 12345678910Statement执行 ，其实是拼接sql语句的。 先拼接sql语句，然后在一起执行。 &gt;&gt;String sql = &quot;select * from t_user where username=&apos;&quot;+ username +&quot;&apos; and password=&apos;&quot;+ password +&quot;&apos;&quot;; UserDao dao = new UserDaoImpl(); dao.login(&quot;admin&quot;, &quot;100234khsdf88&apos; or &apos;1=1&quot;); SELECT * FROM t_user WHERE username=&apos;admin&apos; AND PASSWORD=&apos;100234khsdf88&apos; or &apos;1=1&apos; 前面先拼接sql语句， 如果变量里面带有了 数据库的关键字，那么一并认为是关键字。 不认为是普通的字符串。 rs = st.executeQuery(sql); PreparedStatement 123456789&gt;&gt;该对象就是替换前面的statement对象。&gt;&gt;相比较以前的statement， 预先处理给定的sql语句，对其执行语法检查。 在sql语句里面使用 ? 占位符来替代后续要传递进来的变量。 后面进来的变量值，将会被看成是字符串，不会产生任何的关键字。&gt;&gt;&gt;&gt;String sql = &quot;insert into t_user values(null , ? , ?)&quot;; ps = conn.prepareStatement(sql); //给占位符赋值 从左到右数过来，1 代表第一个问号， 永远你是1开始。 ps.setString(1, userName); ps.setString(2, password); HTTP&amp;ServletHttp协议 1234567什么是协议&gt;&gt;双方在交互、通讯的时候， 遵守的一种规范、规则。http协议&gt;&gt;针对网络上的客户端 与 服务器端在执行http请求的时候，遵守的一种规范。 其实就是规定了客户端在访问服务器端的时候，要带上哪些东西， 服务器端返回数据的时候，也要带上什么东西。 &gt;&gt;版本 1.0 请求数据，服务器返回后， 将会断开连接 1.1 请求数据，服务器返回后， 连接还会保持着。 除非服务器 | 客户端 关掉。 有一定的时间限制，如果都空着这个连接，那么后面会自己断掉。 演示客户端如何与服务器端通讯 123456789在地址栏中键入网络地址 回车 或者是平常注册的时候，点击了注册按钮 ， 浏览器都能显示出来一些东西。那么背地里到底浏览器和服务器是怎么通讯。 它们都传输了哪些数据。1. 安装抓包工具 HttpWatch (IE插件)2. 打开tomcat. 输入localhost:8080 打开首页3. 在首页上找到Example 字样 &gt; 6.x 和 7.x 的文档页面有所不同，但是只要找到example就能够找到例子工程1. 选择 servlet 例子 ---&gt; Request Parameter接着点击Request Parameters 的 Execute超链接执行tomcat的例子，然后查看浏览器和 tomcat服务器的对接细节 Http请求数据解释 12345678910111213141516171819202122232425262728293031323334353637请求的数据里面包含三个部分内容 ： 请求行 、 请求头 、请求体&gt;&gt;请求行POST /examples/servlets/servlet/RequestParamExample HTTP/1.1 POST ： 请求方式 ，以post去提交数据/examples/servlets/servlet/RequestParamExample请求的地址路径 ， 就是要访问哪个地方。HTTP/1.1 协议版本&gt;&gt;请求头Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, */* Referer: http://localhost:8080/examples/servlets/servlet/RequestParamExample Accept-Language: zh-CN User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E) Content-Type: application/x-www-form-urlencoded Accept-Encoding: gzip, deflate Host: localhost:8080 Content-Length: 31 Connection: Keep-Alive Cache-Control: no-cacheAccept: 客户端向服务器端表示，我能支持什么类型的数据。 Referer ： 真正请求的地址路径，全路径Accept-Language: 支持语言格式User-Agent: 用户代理 向服务器表明，当前来访的客户端信息。 Content-Type： 提交的数据类型。经过urlencoding编码的form表单的数据Accept-Encoding： gzip, deflate ： 压缩算法 。 Host ： 主机地址Content-Length： 数据长度Connection : Keep-Alive 保持连接Cache-Control ： 对缓存的操作&gt;&gt;请求体浏览器真正发送给服务器的数据 发送的数据呈现的是key=value ,如果存在多个数据，那么使用 &amp; firstname=zhang&amp;lastname=sansan Http响应数据解析 12345678910111213141516171819202122232425262728请求的数据里面包含三个部分内容 ： 响应行 、 响应头 、响应体HTTP/1.1 200 OKServer: Apache-Coyote/1.1Content-Type: text/html;charset=ISO-8859-1Content-Length: 673Date: Fri, 17 Feb 2017 02:53:02 GMT...这里还有很多数据...&gt;&gt;响应行HTTP/1.1 200 OK协议版本 状态码 咱们这次交互到底是什么样结果的一个code. 200 : 成功，正常处理，得到数据。 403 : for bidden 拒绝 404 ： Not Found 500 ： 服务器异常OK 对应前面的状态码 &gt;&gt;响应头Server: 服务器是哪一种类型。 TomcatContent-Type ： 服务器返回给客户端你的内容类型Content-Length ： 返回的数据长度Date ： 通讯的日期，响应的时间 Get和Post请求区别 123456&gt;&gt;post数据是以流的方式写过去，不会在地址栏上面显示。 现在一般提交数据到服务器使用的都是POST以流的方式写数据，所以数据没有大小限制。&gt;&gt;get会在地址栏后面拼接数据，所以有安全隐患。 一般从服务器获取数据，并且客户端也不用提交上面数据的时候，可以使用GET能够带的数据有限， 1kb大小 Web资源 12345678910在http协议当中，规定了请求和响应双方， 客户端和服务器端。与web相关的资源。 有两种分类&gt;&gt;静态资源 html 、 js、 css&gt;&gt;动态资源 servlet/jspServlet&gt;&gt;servlet是什么?&gt;&gt;&gt;&gt;其实就是一个java程序，运行在我们的web服务器上，用于接收和响应 客户端的http请求。 &gt;&gt;&gt;&gt;更多的是配合动态资源来做。 当然静态资源也需要使用到servlet，只不过是Tomcat里面已经定义好了一个 DefaultServlet Hello Servlet 12345678910111213141516171. 得写一个Web工程 ， 要有一个服务器。2. 测试运行Web工程 1. 新建一个类， 实现Servlet接口 1. 配置Servlet ， 用意： 告诉服务器，我们的应用有这么些个servlet。 在webContent/WEB-INF/web.xml里面写上以下内容。 &lt;!-- 向tomcat报告， 我这个应用里面有这个servlet， 名字叫做HelloServlet , 具体的路径是com.itheima.servlet.HelloServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itheima.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- 注册servlet的映射。 servletName : 找到上面注册的具体servlet， url-pattern: 在地址栏上的path 一定要以/打头 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/a&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 3. 在地址栏上输入 http://localhost:8080/项目名称/a Servlet执行过程 Servlet的通用写法 1234567Servlet (接口) | |GenericServlet | |HttpServlet （用于处理http的请求） 定义一个类，继承HttpServlet 复写doGet和doPost Servlet的生命周期 1234567891011121314151617生命周期&gt;&gt;从创建到销毁的一段时间生命周期方法&gt;&gt;从创建到销毁，所调用的那些方法。- init方法 在创建该servlet的实例时，就执行该方法。 一个servlet只会初始化一次， init方法只会执行一次 默认情况下是 ： 初次访问该servlet，才会创建实例。 - service方法 只要客户端来了一个请求，那么就执行这个方法了。 该方法可以被执行很多次。 一次请求，对应一次service方法的调用- destroy方法 servlet销毁的时候，就会执行该方法 1. 该项目从tomcat的里面移除。 2. 正常关闭tomcat就会执行 shutdown.bat doGet 和 doPost不算生命周期方法，所谓的生命周期方法是指，从对象的创建到销毁一定会执行的方法， 但是这两个方法，不一定会执行。 让Servlet创建实例的时机提前 123456781. 默认情况下，只有在初次访问servlet的时候，才会执行init方法。 有的时候，我们可能需要在这个方法里面执行一些初始化工作，甚至是做一些比较耗时的逻辑。 2. 那么这个时候，初次访问，可能会在init方法中逗留太久的时间。 那么有没有方法可以让这个初始化的时机提前一点。 3. 在配置的时候， 使用load-on-startup元素来指定， 给定的数字越小，启动的时机就越早。 一般不写负数， 从2开始即可。 &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet04&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itheima.servlet.HelloServlet04&lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; ServletConfig 123456789101112131415161718192021&gt;&gt;Servlet的配置，通过这个对象，可以获取servlet在配置的时候一些信息&gt;&gt;先说 ， 在写怎么用， 最后说有什么用。//1. 得到servlet配置对象 专门用于在配置servlet的信息 ServletConfig config = getServletConfig();//获取到的是配置servlet里面servlet-name 的文本内容 String servletName = config.getServletName(); System.out.println(&quot;servletName=&quot;+servletName); //2、。 可以获取具体的某一个参数。 String address = config.getInitParameter(&quot;address&quot;); System.out.println(&quot;address=&quot;+address);//3.获取所有的参数名称 Enumeration&lt;String&gt; names = config.getInitParameterNames(); //遍历取出所有的参数名称 while (names.hasMoreElements()) &#123; String key = (String) names.nextElement(); String value = config.getInitParameter(key); System.out.println(&quot;key===&quot;+key + &quot; value=&quot;+value); &#125; 为什么需要有这个ServletConfig 123456789101112131415161718192021221. 未来我们自己开发的一些应用，使用到了一些技术，或者一些代码，我们不会。 但是有人写出来了。它的代码放置在了自己的servlet类里面。 2. 刚好这个servlet 里面需要一个数字或者叫做变量值。 但是这个值不能是固定了。 所以要求使用到这个servlet的公司，在注册servlet的时候，必须要在web.xml里面，声明init-params在开发当中比较少用。##总结- Http协议 1. 使用HttpWacht 抓包看一看http请求背后的细节。 1. 基本了解 请求和响应的数据内容 请求行、 请求头 、请求体 响应行、响应头、响应体 2. Get和Post的区别- Servlet【重点】 1. 会使用简单的servlet 1.写一个类，实现接口Servlet 2. 配置Servlet 3. 会访问Setvlet 1. Servlet的生命周期 init 一次 创建对象 默认初次访问就会调用或者可以通过配置，让它提前 load-on-startup service 多次，一次请求对应一次service destory 一次 销毁的时候 从服务器移除 或者 正常关闭服务器 2. ServletConfig 获取配置的信息， params HTTPServletReauest&amp;HTTPServletResponseServlet配置方式 123456789--全路径匹配&gt; 以 / 开始 /a /aa/bb&gt; localhost:8080/项目名称/aa/bb --路径匹配 , 前半段匹配&gt; 以 / 开始 ， 但是以 * 结束 /a/* /* &gt; - 其实是一个通配符，匹配任意文字&gt; localhost:8080/项目名称/aa/bb --以扩展名匹配&gt; 写法： 没有/ 以 * 开始 *.扩展名 *.aa *.bb ServletContext 12&gt; Servlet 上下文&gt; 每个web工程都只有一个ServletContext对象。 说白了也就是不管在哪个servlet里面，获取到的这个类的对象都是同一个。 如何得到对象 12//1. 获取对象 ServletContext context = getServletContext(); 有什么作用 1231. 获取全局配置参数2. 获取web工程中的资源3. 存取数据，servlet间共享数据 域对象 可以获取全局配置参数 获取全局参数 可以获取Web应用中的资源 1234567891. 获取资源在tomcat里面的绝对路径 先得到路径，然后自己new InpuStream context.getRealPath(&quot;&quot;) //这里得到的是项目在tomcat里面的根目录。 D:\tomcat\apache-tomcat-7.0.52\apache-tomcat-7.0.52\wtpwebapps\Demo03\ String path = context.getRealPath(&quot;file/config.properties&quot;); D:\tomcat\apache-tomcat-7.0.52\apache-tomcat-7.0.52\wtpwebapps\Demo03\file\config.properties 2. getResourceAsStream 获取资源 流对象 直接给相对的路径，然后获取流对象。 通过classloader去获取web工程下的资源 使用ServletContext存取数据 1.定义一个登陆的html页面， 定义一个form表单 2.定义一个Servlet，名为LoginServlet 3.针对成功或者失败，进行判断，然后跳转到不一样的网页 ServletContext存取值分析 1234567891011&lt;!-- A路径： Servlet的路径 http://localhost:8080/Demo4/loginB路径： 当前这个html的路径： http://localhost:8080/Demo4/login.html --&gt;&lt;form action=&quot;login&quot; method=&quot;get&quot;&gt; 账号:&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br&gt; 密码:&lt;input type=&quot;text&quot; name=&quot;password&quot;/&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;&lt;/form&gt; ServletContext 何时创建， 何时销毁? 12服务器启动的时候，会为托管的每一个web应用程序，创建一个ServletContext对象从服务器移除托管，或者是关闭服务器。 HttpServletRequest 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061这个对象封装了客户端提交过来的一切数据。可以获取客户端请求头信息1.获取客户端提交过来的数据//得到一个枚举集合 Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); while (headerNames.hasMoreElements()) &#123; String name = (String) headerNames.nextElement(); String value = request.getHeader(name); System.out.println(name+&quot;=&quot;+value); &#125;2.获取客户端提交过来的数据 String name = request.getParameter(&quot;name&quot;); String address = request.getParameter(&quot;address&quot;); System.out.println(&quot;name=&quot;+name); System.out.println(&quot;address=&quot;+address); ------------------------------------------------- //name=zhangsan&amp;name=lisi&amp;name=wangwu 一个key可以对应多个值。 Map&lt;String, String[]&gt; map = request.getParameterMap(); Set&lt;String&gt; keySet = map.keySet(); Iterator&lt;String&gt; iterator = keySet.iterator(); while (iterator.hasNext()) &#123; String key = (String) iterator.next(); System.out.println(&quot;key=&quot;+key + &quot;--的值总数有：&quot;+map.get(key).length); String value = map.get(key)[0]; String value1 = map.get(key)[1]; String value2 = map.get(key)[2]; System.out.println(key+&quot; ======= &quot;+ value + &quot;=&quot; + value1 + &quot;=&quot;+ value2); &#125;3.获取中文数据客户端提交数据给服务器端，如果数据中带有中文的话，有可能会出现乱码情况，那么可以参照以下方法解决。如果是GET方式1. 代码转码 String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); &gt;&gt;System.out.println(&quot;userName=&quot;+username+&quot;==password=&quot;+password);//get请求过来的数据，在url地址栏上就已经经过编码了，所以我们取到的就是乱码，//tomcat收到了这批数据，getParameter 默认使用ISO-8859-1去解码//先让文字回到ISO-8859-1对应的字节数组 ， 然后再按utf-8组拼字符串username = new String(username.getBytes(&quot;ISO-8859-1&quot;) , &quot;UTF-8&quot;);System.out.println(&quot;userName=&quot;+username+&quot;==password=&quot;+password);直接在tomcat里面做配置，以后get请求过来的数据永远都是用UTF-8编码。 2.可以在tomcat里面做设置处理 conf/server.xml 加上URIEncoding=&quot;utf-8&quot; &lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot;/&gt; 如果是POST方式这个说的是设置请求体里面的文字编码。 get方式，用这行，有用吗？ ---&gt; 没用 request.setCharacterEncoding(&quot;UTF-8&quot;); 这行设置一定要写在getParameter之前。 HttpServletResponse 12345678负责返回数据给客户端。输出数据到页面上 //以字符流的方式写数据 //response.getWriter().write(&quot;&lt;h1&gt;hello response...&lt;/h1&gt;&quot;); //以字节流的方式写数据 response.getOutputStream().write(&quot;hello response2222...&quot;.getBytes()); 响应的数据中有中文，那么有可能出现中文乱码 1234567891011121314151617--以字符流输出&gt; response.getWriter()//1. 指定输出到客户端的时候，这些文字使用UTF-8编码 response.setCharacterEncoding(&quot;UTF-8&quot;); //2. 直接规定浏览器看这份数据的时候，使用什么编码来看。 response.setHeader(&quot;Content-Type&quot;, &quot;text/html; charset=UTF-8&quot;); response.getWriter().write(&quot;我爱黑马训练营...&quot;);--以字节流输出&gt; response.getOutputStream() //1. 指定浏览器看这份数据使用的码表 response.setHeader(&quot;Content-Type&quot;, &quot;text/html;charset=UTF-8&quot;); //2. 指定输出的中文用的码表 response.getOutputStream().write(&quot;我爱深圳黑马训练营..&quot;.getBytes(&quot;UTF-8&quot;)); 不管是字节流还是字符流，直接使用一行代码就可以了。 12response.setContentType(&quot;text/html;charset=UTF-8&quot;);然后在写数据即可。 演练下载资源 12345671.直接以超链接的方式下载，不写任何代码。 也能够下载东西下来。 让tomcat的默认servlet去提供下载：&lt;br&gt;&lt;a href=&quot;download/aa.jpg&quot;&gt;aa.jpg&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;download/bb.txt&quot;&gt;bb.txt&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;download/cc.rar&quot;&gt;cc.rar&lt;/a&gt;&lt;br&gt;原因是tomcat里面有一个默认的Servlet -- DefaultServlet 。这个DefaultServlet 专门用于处理放在tomcat服务器上的静态资源。 总结 1234567891011121314151617181. Servlet注册方式 2. ServletContext【重点】&gt;&gt;作用：1. 获取全局参数2. 获取工程里面的资源。3. 资源共享。 ServletContext 域对象&gt;&gt;有几个 一个 &gt;&gt;什么时候创建 ？ 什么时候销毁服务器启动的时候给每一个应用都创建一个ServletContext对象， 服务器关闭的时候销毁简单登录3. HttpServletRequest【重点】 1. 获取请求头 1. 获取提交过来的数据4. HttpServletResponse【重点】 负责输出数据到客户端，其实就是对之前的请求作出响应5. 中文乱码问题。【重点】6. 下载 作业： 完成注册 完成登录 V1.1 最好配合上数据库，完成注册和登录的功能。 Cookie&amp;&amp;Session 中文文件下载 1234567891011121314151617针对浏览器类型，对文件名字做编码处理 Firefox (Base64) , IE、Chrome ... 使用的是URLEncoder /* * 如果文件的名字带有中文，那么需要对这个文件名进行编码处理 * 如果是IE ，或者 Chrome （谷歌浏览器） ，使用URLEncoding 编码 * 如果是Firefox ， 使用Base64编码 */ //获取来访的客户端类型 String clientType = request.getHeader(&quot;User-Agent&quot;); if(clientType.contains(&quot;Firefox&quot;))&#123; fileName = DownLoadUtil.base64EncodeFileName(fileName); &#125;else&#123; //IE ，或者 Chrome （谷歌浏览器） ， //对中文的名字进行编码处理 fileName = URLEncoder.encode(fileName,&quot;UTF-8&quot;); &#125; 请求转发和重定向 12345678910111213141516171819202122232425262728293031323334重定向 /* 之前的写法 response.setStatus(302); response.setHeader(&quot;Location&quot;, &quot;login_success.html&quot;);*/ //重定向写法： 重新定位方向 参数即跳转的位置 response.sendRedirect(&quot;login_success.html&quot;); 1. 地址上显示的是最后的那个资源的路径地址 2. 请求次数最少有两次， 服务器在第一次请求后，会返回302 以及一个地址， 浏览器在根据这个地址，执行第二次访问。 3. 可以跳转到任意路径。 不是自己的工程也可以跳。 4. 效率稍微低一点， 执行两次请求。 5. 后续的请求，没法使用上一次的request存储的数据，或者 没法使用上一次的request对象，因为这是两次不同的请求。---------------------------------------------------------------------------------请求转发 //请求转发的写法： 参数即跳转的位置 request.getRequestDispatcher(&quot;login_success.html&quot;).forward(request, response); 1. 地址上显示的是请求servlet的地址。 返回200 ok 2. 请求次数只有一次， 因为是服务器内部帮客户端执行了后续的工作。 3. 只能跳转自己项目的资源路径 。 4. 效率上稍微高一点，因为只执行一次请求。 5. 可以使用上一次的request对象。 Cookie 1234饼干. 其实是一份小数据， 是服务器给客户端，并且存储在客户端上的一份小数据### 应用场景&gt; 自动登录、浏览记录、购物车。 为什么要有这个Cookie 1http的请求是无状态。 客户端与服务器在通讯的时候，是无状态的，其实就是客户端在第二次来访的时候，服务器根本就不知道这个客户端以前有没有来访问过。 为了更好的用户体验，更好的交互 [自动登录]，其实从公司层面讲，就是为了更好的收集用户习惯[大数据] Cookie怎么用 12345678#### 简单使用：- 添加Cookie给客户端 1. 在响应的时候，添加cookie Cookie cookie = new Cookie(&quot;aa&quot;, &quot;bb&quot;);//给响应，添加一个cookieresponse.addCookie(cookie); 2.客户端收到的信息里面，响应头中多了一个字段 Set-Cookie 3. 123456789101112131415161718192021222324252627获取客户端带过来的Cookie//获取客户端带过来的cookie Cookie[] cookies = request.getCookies(); if(cookies != null)&#123; for (Cookie c : cookies) &#123; String cookieName = c.getName(); String cookieValue = c.getValue(); System.out.println(cookieName + &quot; = &quot;+ cookieValue); &#125; &#125; 常用方法 //关闭浏览器后，cookie就没有了。 ---&gt; 针对没有设置cookie的有效期。 // expiry： 有效 以秒计算。 //正值 ： 表示 在这个数字过后，cookie将会失效。 //负值： 关闭浏览器，那么cookie就失效， 默认值是 -1 cookie.setMaxAge(60 * 60 * 24 * 7); //赋值新的值 //cookie.setValue(newValue); //用于指定只有请求了指定的域名，才会带上该cookie cookie.setDomain(&quot;.itheima.com&quot;); //只有访问该域名下的cookieDemo的这个路径地址才会带cookie cookie.setPath(&quot;/CookieDemo&quot;); 例子一 显示最近访问的时间。 12345678910111213141516171819202122232425262728293031323334351.判断账号是否正确2. 如果正确，则获取cookie。 但是得到的cookie是一个数组， 我们要从数组里面找到我们想要的对象。3. 如果找到的对象为空，表明是第一次登录。那么要添加cookie4. 如果找到的对象不为空， 表明不是第一次登录。 if(&quot;admin&quot;.equals(userName) &amp;&amp; &quot;123&quot;.equals(password))&#123; //获取cookie last-name --- &gt; Cookie [] cookies = request.getCookies(); //从数组里面找出我们想要的cookie Cookie cookie = CookieUtil.findCookie(cookies, &quot;last&quot;); //是第一次登录，没有cookie if(cookie == null)&#123; Cookie c = new Cookie(&quot;last&quot;, System.currentTimeMillis()+&quot;&quot;); c.setMaxAge(60*60); //一个小时 response.addCookie(c); response.getWriter().write(&quot;欢迎您, &quot;+userName); &#125;else&#123; //1. 去以前的cookie第二次登录，有cookie long lastVisitTime = Long.parseLong(cookie.getValue()); //2. 输出到界面， response.getWriter().write(&quot;欢迎您, &quot;+userName +&quot;,上次来访时间是：&quot;+new Date(lastVisitTime)); //3. 重置登录的时间 cookie.setValue(System.currentTimeMillis()+&quot;&quot;); response.addCookie(cookie); &#125; &#125;else&#123; response.getWriter().write(&quot;登陆失败 &quot;); &#125; 例子二： 显示商品浏览记录。 1234567891011121314151617###准备工作1. 拷贝基础课第一天的 htmll原型文件，到工程的WebContent里面。2. 在WebContent目录下新建一个jsp文件， product_list.jsp, 然后拷贝原来product_list.html的内容到jsp里面。 建好之后，jsp里面的所有ISO-8859-1 改成 UTF-8 拷贝html标签的所有内容。 替换jsp的html标签即可3. 修改product_info.htm里面的手机数码超链接地址 &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;product_list.jsp&quot;&gt;手机数码&lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;4. 修改首页(index.html)顶部的手机数码跳转的位置为 product_list.jsp &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;product_list.jsp&quot;&gt;手机数码&lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;###分析 Jsp 里面使用Java代码 123456789- jsp&gt; Java Server Pager ---&gt; 最终会翻译成一个类， 就是一个Servlet- 定义全局变量 &lt;%! int a = 99; %&gt;- 定义局部变量 &lt;% int b = 999; %&gt;- 在jsp页面上，显示 a 和 b的值， &lt;%=a %&gt; &lt;%=b %&gt; jsp显示浏览记录 清除浏览记录 123456其实就是清除Cookie， 删除cookie是没有什么delete方法的。只有设置maxAge 为0 。 Cookie cookie = new Cookie(&quot;history&quot;,&quot;&quot;); cookie.setMaxAge(0); //设置立即删除 cookie.setPath(&quot;/CookieDemo02&quot;); response.addCookie(cookie); Cookie总结 1234567891011121314151617181920211. 服务器给客户端发送过来的一小份数据，并且存放在客户端上。2. 获取cookie， 添加cookie request.getCookie(); response.addCookie();3. Cookie分类 会话Cookie 默认情况下，关闭了浏览器，那么cookie就会消失。 持久Cookie 在一定时间内，都有效，并且会保存在客户端上。 cookie.setMaxAge(0); //设置立即删除cookie.setMaxAge(100); //100 秒4. Cookie的安全问题。由于Cookie会保存在客户端上，所以有安全隐患问题。 还有一个问题， Cookie的大小与个数有限制。 为了解决这个问题 ---&gt; Session . Session 1234567891011121314151617181920会话 ， Session是基于Cookie的一种会话机制。 Cookie是服务器返回一小份数据给客户端，并且存放在客户端上。 Session是，数据存放在服务器端。常用API //得到会话ID String id = session.getId(); //存值 session.setAttribute(name, value); //取值 session.getAttribute(name); //移除值 session.removeAttribute(name); - Session何时创建 ， 何时销毁?- 创建&gt; 如果有在servlet里面调用了 request.getSession()- 销毁&gt; session 是存放在服务器的内存中的一份数据。 当然可以持久化. Redis . 即使关了浏览器，session也不会销毁。&gt; 1. 关闭服务器&gt; 1. session会话时间过期。 有效期过了，默认有效期： 30分钟。 简单购物车 CartServlet 代码 1234567891011121314151617181920212223242526272829response.setContentType(&quot;text/html;charset=utf-8&quot;); //1. 获取要添加到购物车的商品id int id = Integer.parseInt(request.getParameter(&quot;id&quot;)); // 0 - 1- 2 -3 -4 String [] names = &#123;&quot;Iphone7&quot;,&quot;小米6&quot;,&quot;三星Note8&quot;,&quot;魅族7&quot; , &quot;华为9&quot;&#125;; //取到id对应的商品名称 String name = names[id]; //2. 获取购物车存放东西的session Map&lt;String , Integer&gt; iphoen7 3 //把一个map对象存放到session里面去，并且保证只存一次。 Map&lt;String, Integer&gt; map = (Map&lt;String, Integer&gt;) request.getSession().getAttribute(&quot;cart&quot;); //session里面没有存放过任何东西。 if(map == null)&#123; map = new LinkedHashMap&lt;String , Integer&gt;(); request.getSession().setAttribute(&quot;cart&quot;, map); &#125; //3. 判断购物车里面有没有该商品 if(map.containsKey(name))&#123; //在原来的值基础上 + 1 map.put(name, map.get(name) + 1 ); &#125;else&#123; //没有购买过该商品，当前数量为1 。 map.put(name, 1); &#125; //4. 输出界面。（跳转） response.getWriter().write(&quot;&lt;a href=&apos;product_list.jsp&apos;&gt;&lt;h3&gt;继续购物&lt;/h3&gt;&lt;/a&gt;&lt;br&gt;&quot;); response.getWriter().write(&quot;&lt;a href=&apos;cart.jsp&apos;&gt;&lt;h3&gt;去购物车结算&lt;/h3&gt;&lt;/a&gt;&quot;); 移除Session中的元素 12345//强制干掉会话，里面存放的任何数据就都没有了。session.invalidate();//从session中移除某一个数据//session.removeAttribute(&quot;cart&quot;); 总结： 1234567891011121314151617181920212223242526272829303132- 请求转发和重定向（面试经常问。）- Cookie 服务器给客户端发送一小份数据， 存放在客户端上。 基本用法： 添加cookie 获取cookie。演练例子：1. 获取上一次访问时间2. 获取商品浏览记录。- 什么时候有cookie response.addCookie(new Cookie())- Cookie 分类&gt;&gt;会话Cookie 关闭浏览器，就失效&gt;&gt;持久cookie 存放在客户端上。 在指定的期限内有效。 setMaxAge(); - Session也是基于cookie的一种会话技术， 数据存放存放在服务器端会在cookie里面添加一个字段 JSESSIONID . 是tomcat服务器生成。 &gt;&gt;setAttribute 存数据&gt;&gt;getAttribute 取数据&gt;&gt;removeAttribute 移除数据&gt;&gt;getSessionId(); 获取会话id&gt;&gt;invalidate() 强制让会话失效。- 创建和销毁 ，调用request.getSesion创建 服务器关闭 ， 会话超时（30分） setAttribute 存放的值， 在浏览器关闭后，还有没有。 有！，就算客户端把电脑砸了也还有。 JSP &amp; EL &amp; JSTL jsp 1234567Java Server Page - 什么是jsp&gt; 从用户角度看待 ，就是是一个网页 ， 从程序员角度看待 ， 其实是一个java类， 它继承了servlet，所以可以直接说jsp 就是一个Servlet.- 为什么会有jsp?&gt; html 多数情况下用来显示静态内容 ， 一成不变的。 但是有时候我们需要在网页上显示一些动态数据， 比如： 查询所有的学生信息， 根据姓名去查询具体某个学生。 这些动作都需要去查询数据库，然后在网页上显示。 html是不支持写java代码 ， jsp里面可以写java代码。 怎么用JSP 12指令写法&lt;%@ 指令名字 %&gt; 123456789101112131415161718page指令- language&gt;&gt;&gt;&gt;表明jsp页面中可以写java代码- contentType&gt;&gt;&gt;&gt;其实即使说这个文件是什么类型，告诉浏览器我是什么内容类型，以及使用什么编码 contentType=&quot;text/html; charset=UTF-8&quot; text/html MIMEType 这是一个文本，html网页- pageEncoding jsp内容编码- extends 用于指定jsp翻译成java文件后，继承的父类是谁，一般不用改。- import 导包使用的，一般不用手写。- session &gt;&gt;&gt;&gt;值可选的有true or false . 用于控制在这个jsp页面里面，能够直接使用session对象。 具体的区别是，请看翻译后的java文件 如果该值是true , 那么在代码里面会有getSession（）的 调用，如果是false : 那么就不会有该方法调用，也就是没有session对象了。在页面上自然也就不 能使用session了。- errorPage&gt;&gt;&gt;&gt;指的是错误的页面， 值需要给错误的页面路径- isErrorPage&gt;&gt;&gt;&gt;上面的errorPage 用于指定错误的时候跑到哪一个页面去。 那么这个isErroPage , 就是声明某一个 页面到底是不是错误的页面。 12345include指令&gt; 包含另外一个jsp的内容进来。 &lt;%@ include file=&quot;other02.jsp&quot;%&gt;- 背后细节:&gt; 把另外一个页面的所有内容拿过来一起输出。 所有的标签元素都包含进来。 1234taglib指令&lt;%@ taglib prefix=&quot;&quot; uri=&quot;&quot;%&gt; uri: 标签库路径prefix : 标签库的别名 JSP 动作标签 123456789101112131415161718192021222324&lt;jsp:include page=&quot;&quot;&gt;&lt;/jsp:include&gt;&lt;jsp:param value=&quot;&quot; name=&quot;&quot;/&gt;&lt;jsp:forward page=&quot;&quot;&gt;&lt;/jsp:forward&gt;jsp:include&lt;jsp:include page=&quot;other02.jsp&quot;&gt;&lt;/jsp:include&gt;包含指定的页面， 这里是动态包含。 也就是不把包含的页面所有元素标签全部拿过来输出，而是把它的运行结果拿过来。 jsp:forward&lt;jsp:forward page=&quot;&quot;&gt;&lt;/jsp:forward&gt;前往哪一个页面。&lt;% //请求转发 request.getRequestDispatcher(&quot;other02.jsp&quot;).forward(request, response);%&gt; jsp:param意思是： 在包含某个页面的时候，或者在跳转某个页面的时候，加入这个参数。 &lt;jsp:forward page=&quot;other02.jsp&quot;&gt; &lt;jsp:param value=&quot;beijing&quot; name=&quot;address&quot;/&gt; &lt;/jsp:forward&gt; 在other02.jsp中获取参数 &lt;br&gt;收到的参数是：&lt;br&gt;&lt;%= request.getParameter(&quot;address&quot;)%&gt; JSP内置对象 12345678910111213141516171819202122232425262728&gt; 所谓内置对象，就是我们可以直接在jsp页面中使用这些对象。 不用创建。- pageContext- request- session- application以上4个是作用域对象 ,- 作用域 表示这些对象可以存值，他们的取值范围有限定。 setAttribute 和 getAttribute使用作用域来存储数据&lt;br&gt; &lt;% pageContext.setAttribute(&quot;name&quot;, &quot;page&quot;); request.setAttribute(&quot;name&quot;, &quot;request&quot;); session.setAttribute(&quot;name&quot;, &quot;session&quot;); application.setAttribute(&quot;name&quot;, &quot;application&quot;); %&gt; 取出四个作用域中的值&lt;br&gt; &lt;%=pageContext.getAttribute(&quot;name&quot;)%&gt; &lt;%=request.getAttribute(&quot;name&quot;)%&gt; &lt;%=session.getAttribute(&quot;name&quot;)%&gt; &lt;%=application.getAttribute(&quot;name&quot;)%&gt; - 作用域范围大小：pageContext -- request --- session -- application 四个作用域的区别 12345678910111213141516171819202122- pageContext 【PageContext】&gt; 作用域仅限于当前的页面。 &gt; 还可以获取到其他八个内置对象。- request 【HttpServletRequest】&gt; 作用域仅限于一次请求， 只要服务器对该请求做出了响应。 这个域中存的值就没有了。- session 【HttpSession】&gt; 作用域限于一次会话（多次请求与响应） 当中。 - application 【ServletContext】&gt; 整个工程都可以访问， 服务器关闭后就不能访问了。 - out 【JspWriter】- response 【HttpServletResponse】- exception 【Throwable】- page 【Object】 ---就是这个jsp翻译成的java类的实例对象- config 【ServletConfig】 EL表达式 1234&gt; 是为了简化咱们的jsp代码，具体一点就是为了简化在jsp里面写的那些java代码。- 写法格式$&#123;表达式 &#125;&gt; 如果从作用域中取值，会先从小的作用域开始取，如果没有，就往下一个作用域取。 一直把四个作用域取完都没有， 就没有显示。 如何使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657581. 取出4个作用域中存放的值。&lt;% pageContext.setAttribute(&quot;name&quot;, &quot;page&quot;); request.setAttribute(&quot;name&quot;, &quot;request&quot;); session.setAttribute(&quot;name&quot;, &quot;session&quot;); application.setAttribute(&quot;name&quot;, &quot;application&quot;); %&gt; 按普通手段取值&lt;br&gt; &lt;%= pageContext.getAttribute(&quot;name&quot;)%&gt; &lt;%= request.getAttribute(&quot;name&quot;)%&gt; &lt;%= session.getAttribute(&quot;name&quot;)%&gt; &lt;%= application.getAttribute(&quot;name&quot;)%&gt; &lt;br&gt;使用EL表达式取出作用域中的值&lt;br&gt; $&#123; pageScope.name &#125; $&#123; requestScope.name &#125; $&#123; sessionScope.name &#125; $&#123; applicationScope.name &#125; 2.如果域中所存的是数组&lt;% String [] a = &#123;&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;&#125;; pageContext.setAttribute(&quot;array&quot;, a);%&gt;使用EL表达式取出作用域中数组的值&lt;br&gt; $&#123;array[0] &#125; , $&#123;array[1] &#125;,$&#123;array[2] &#125;,$&#123;array[3] &#125;3.如果域中锁存的是集合 使用EL表达式取出作用域中集合的值&lt;br&gt; $&#123;li[0] &#125; , $&#123;li[1] &#125;,$&#123;li[2] &#125;,$&#123;li[3] &#125; &lt;br&gt;-------------Map数据----------------&lt;br&gt; &lt;% Map map = new HashMap(); map.put(&quot;name&quot;, &quot;zhangsna&quot;); map.put(&quot;age&quot;,18); map.put(&quot;address&quot;,&quot;北京..&quot;); map.put(&quot;address.aa&quot;,&quot;深圳..&quot;); pageContext.setAttribute(&quot;map&quot;, map); %&gt; 4.取出Map集合的值&lt;% Map map = new HashMap(); map.put(&quot;name&quot;, &quot;zhangsna&quot;); map.put(&quot;age&quot;,18); map.put(&quot;address&quot;,&quot;北京..&quot;); map.put(&quot;address.aa&quot;,&quot;深圳..&quot;); pageContext.setAttribute(&quot;map&quot;, map); %&gt; 使用EL表达式取出作用域中Map的值&lt;br&gt; $&#123;map.name &#125; , $&#123;map.age &#125; , $&#123;map.address &#125; , $&#123;map[&quot;address.aa&quot;] &#125; 取值细节： 12345678910111213141516171819202122232425262728291. 从域中取值。得先存值。 &lt;% //pageContext.setAttribute(&quot;name&quot;, &quot;zhangsan&quot;); session.setAttribute(&quot;name&quot;, &quot;lisi...&quot;); %&gt; &lt;br&gt;直接指定说了，到这个作用域里面去找这个name&lt;br&gt; $&#123; pageScope.name &#125; &lt;br&gt;//先从page里面找，没有去request找，去session，去application &lt;br&gt; $&#123; name &#125; &lt;br&gt;指定从session中取值&lt;br&gt; $&#123; sessionScope.name &#125; 2. 取值方式如果这份值是有下标的，那么直接使用[]&lt;% String [] array = &#123;&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;&#125; session.setAttribute(&quot;array&quot;,array);%&gt;$&#123; array[1] &#125; --&gt; 这里array说的是attribute的name 如果没有下标， 直接使用 .的方式去取&lt;% User user = new User(&quot;zhangsan&quot;,18); session.setAttribute(&quot;u&quot;, user);%&gt;$&#123; u.name &#125; , $&#123; u.age &#125; 一般使用EL表达式，用的比较多的，都是从一个对象中取出它的属性值，比如取出某一个学生的姓名。 EL表达式 的11个内置对象。 123456789101112131415161718192021$&#123; 对象名.成员 &#125;- pageContext 作用域相关对象- pageScope- requestScope- sessionScope- applicationScope头信息相关对象- header- headerValues参数信息相关对象- param- paramValues- cookie 全局初始化参数- initParam JSTL 123456789&gt; 全称 ： JSP Standard Tag Library jsp标准标签库&gt; 简化jsp的代码编写。 替换 &lt;%%&gt; 写法。 一般与EL表达式配合###怎么使用1. 导入jar文件到工程的WebContent/Web-Inf/lib jstl.jar standard.jar2. 在jsp页面上，使用taglib 指令，来引入标签库3. 注意： 如果想支持 EL表达式，那么引入的标签库必须选择1.1的版本，1.0的版本不支持EL表达式。&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 常用标签 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;c:set&gt;&lt;/c:set&gt;&lt;c:if test=&quot;&quot;&gt;&lt;/c:if&gt;&lt;c:forEach&gt;&lt;/c:forEach&gt;- c:set &lt;!-- 声明一个对象name， 对象的值 zhangsan , 存储到了page（默认） ， 指定是session --&gt; &lt;c:set var=&quot;name&quot; value=&quot;zhangsan&quot; scope=&quot;session&quot;&gt;&lt;/c:set&gt; $&#123;sessionScope.name &#125; - c:if&gt; 判断test里面的表达式是否满足，如果满足，就执行c:if标签中的输出 ， c:if 是没有else的。 &lt;c:set var=&quot;age&quot; value=&quot;18&quot; &gt;&lt;/c:set&gt; &lt;c:if test=&quot;$&#123; age &gt; 26 &#125;&quot;&gt; 年龄大于了26岁... &lt;/c:if&gt; &lt;c:if test=&quot;$&#123; age &lt;= 26 &#125;&quot;&gt; 年龄小于了26岁... &lt;/c:if&gt; ------------------------------ 定义一个变量名 flag 去接收前面表达式的值，然后存在session域中 &lt;c:if test=&quot;$&#123; age &gt; 26 &#125;&quot; var=&quot;flag&quot; scope=&quot;session&quot;&gt; 年龄大于了26岁... &lt;/c:if&gt; - c:forEach 从1 开始遍历到10 ，得到的结果 ，赋值给 i ,并且会存储到page域中， step , 增幅为2， &lt;c:forEach begin=&quot;1&quot; end=&quot;10&quot; var=&quot;i&quot; step=&quot;2&quot;&gt; $&#123;i &#125; &lt;/c:forEach&gt; ----------------------------------------------- &lt;!-- items : 表示遍历哪一个对象，注意，这里必须写EL表达式。 var: 遍历出来的每一个元素用user 去接收。 --&gt; &lt;c:forEach var=&quot;user&quot; items=&quot;$&#123;list &#125;&quot;&gt; $&#123;user.name &#125; ----$&#123;user.age &#125; &lt;/c:forEach&gt; 学生信息管理系统 需求分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711. 先写 login.jsp , 并且搭配一个LoginServlet 去获取登录信息。2. 创建用户表， 里面只要有id , username 和 password3. 创建UserDao, 定义登录的方法 /** - 该dao定义了对用户表的访问规则 */ public interface UserDao &#123; 1. - - 这里简单就返回一个Boolean类型， 成功或者失败即可。 - - 但是开发的时候，登录的方法，一旦成功。这里应该返回该用户的个人信息 - @param userName - @param password - - @return true : 登录成功， false : 登录失败。 */ boolean login(String userName , String password); &#125;4. 创建UserDaoImpl , 实现刚才定义的登录方法。 public class UserDaoImpl implements UserDao &#123; @Override public boolean login(String userName , String password) &#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; //1. 得到连接对象 conn = JDBCUtil.getConn(); String sql = &quot;select * from t_user where username=? and password=?&quot;; //2. 创建ps对象 ps = conn.prepareStatement(sql); ps.setString(1, userName); ps.setString(2, password); //3. 开始执行。 rs = ps.executeQuery(); //如果能够成功移到下一条记录，那么表明有这个用户。 return rs.next(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtil.release(conn, ps, rs); &#125; return false; &#125; &#125;5. 在LoginServlet里面访问UserDao， 判断登录结果。 以区分对待6. 创建stu_list.jsp , 让登录成功的时候跳转过去。7. 创建学生表 ， 里面字段随意。 8. 定义学生的Dao . StuDao public interface StuDao &#123; /** * 查询出来所有的学生信息 * @return List集合 */ List&lt;Student&gt; findAll(); &#125; 9.对上面定义的StuDao 做出实现 StuDaoImplpublic class StuDaoImpl implements StuDao &#123; @Override public List&lt;Student&gt; findAll() &#123; List&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; //1. 得到连接对象 conn = JDBCUtil.getConn(); String sql = &quot;select * from t_stu&quot;; ps = conn.prepareStatement(sql); rs = ps.executeQuery(); //数据多了，用对象装， 对象也多了呢？ 用集合装。 while(rs.next())&#123; //10 次 ，10个学生 Student stu = new Student(); stu.setId(rs.getInt(&quot;id&quot;)); stu.setAge(rs.getInt(&quot;age&quot;)); stu.setName(rs.getString(&quot;name&quot;)); stu.setGender(rs.getString(&quot;gender&quot;)); stu.setAddress(rs.getString(&quot;address&quot;)); list.add(stu); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtil.release(conn, ps, rs); &#125; return list; &#125; &#125; 10. 在登录成功的时候，完成三件事情。11. 查询所有的学生 1. 把这个所有的学生集合存储到作用域中。 2. 跳转到stu_list.jsp protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //提交的数据有可能有中文， 怎么处理。 request.setCharacterEncoding(&quot;UTF-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); //1. 获取客户端提交的信息 String userName = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); //2. 去访问dao ， 看看是否满足登录。 UserDao dao = new UserDaoImpl(); boolean isSuccess = dao.login(userName, password); //3. 针对dao的返回结果，做出响应 if(isSuccess)&#123; //response.getWriter().write(&quot;登录成功.&quot;); //1. 查询出来所有的学生信息。 StuDao stuDao = new StuDaoImpl(); List&lt;Student&gt; list = stuDao.findAll(); //2. 先把这个集合存到作用域中。 request.getSession().setAttribute(&quot;list&quot;, list); //2. 重定向 response.sendRedirect(&quot;stu_list.jsp&quot;); &#125;else&#123; response.getWriter().write(&quot;用户名或者密码错误！&quot;); &#125; &#125;11.在stu_list.jsp中，取出域中的集合，然后使用c标签 去遍历集合。 &lt;table border=&quot;1&quot; width=&quot;700&quot;&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt;住址&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;$&#123;list &#125;&quot; var=&quot;stu&quot;&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;$&#123;stu.id &#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.name &#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.age &#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.gender &#125;&lt;/td&gt; &lt;td&gt;$&#123;stu.address &#125;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot;&gt;更新&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/table&gt; 总结： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253JSP三大指令 page include taglib三个动作标签 &lt;jsp:include&gt; &lt;jsp:forward&gt; &lt;jsp:param&gt; &gt;&gt;&gt;&gt;九个内置对象&gt;&gt;四个作用域pageContextrequestsessionapplicationoutexceptionresponsepageconfig&gt;&gt;EL$&#123; 表达式 &#125;取4个作用域中的值$&#123; name &#125;&gt;&gt;&gt;有11个内置对象。 pageContextpageScoperequestScopesessionScopeapplicationScopeheaderheaderValuesparamparamValuescookieinitParamJSTL&gt; 使用1.1的版本， 支持EL表达式， 1.0不支持EL表达式&gt; 拷贝jar包， 通过taglib 去引入标签库&lt;c:set&gt;&lt;c:if&gt;&lt;c:forEach&gt; 事务&amp;数据库连接池&amp;DBUtils事务 1234&gt; Transaction 其实指的一组操作，里面包含许多个单一的逻辑。只要有一个逻辑没有执行成功，那么都算失败。 所有的数据都回归到最初的状态(回滚) - 为什么要有事务?为了确保逻辑的成功。 例子： 银行的转账。 使用命令行方式演示事务。 12345- 开启事务 start transaction;- 提交或者回滚事务 commit; 提交事务， 数据将会写到磁盘上的数据库 rollback ; 数据回滚，回到最初的状态。 1.关闭自动提交功能。 2.演示事务 使用代码方式演示事务 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&gt; 代码里面的事务，主要是针对连接来的。 &gt; 1. 通过conn.setAutoCommit（false ）来关闭自动提交的设置。&gt; 2. 提交事务 conn.commit();&gt; 3. 回滚事务 conn.rollback();@Testpublic void testTransaction()&#123; Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try &#123; conn = JDBCUtil.getConn(); //连接，事务默认就是自动提交的。 关闭自动提交。 conn.setAutoCommit(false); String sql = &quot;update account set money = money - ? where id = ?&quot;; ps = conn.prepareStatement(sql); //扣钱， 扣ID为1 的100块钱 ps.setInt(1, 100); ps.setInt(2, 1); ps.executeUpdate(); int a = 10 /0 ; //加钱， 给ID为2 加100块钱 ps.setInt(1, -100); ps.setInt(2, 2); ps.executeUpdate(); //成功： 提交事务。 conn.commit(); &#125; catch (SQLException e) &#123; try &#123; //事变： 回滚事务 conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; e.printStackTrace(); &#125;finally &#123; JDBCUtil.release(conn, ps, rs); &#125;&#125; 事务的特性 1234567891011- 原子性&gt; 指的是 事务中包含的逻辑，不可分割。 - 一致性&gt; 指的是 事务执行前后。数据完整性- 隔离性&gt; 指的是 事务在执行期间不应该受到其他事务的影响- 持久性&gt; 指的是 事务执行成功，那么数据应该持久保存到磁盘上。 事务的安全隐患 1234567891011121314&gt; 不考虑隔离级别设置，那么会出现以下问题。- 读&gt; 脏读 不可重读读 幻读.&gt;&gt;&gt;脏读&gt; 一个事务读到另外一个事务还未提交的数据&gt;&gt;&gt;不可重复读 &gt; 一个事务读到了另外一个事务提交的数据 ，造成了前后两次查询结果不一致。写丢失更新 读未提交 演示 1.设置A窗口的隔离级别为 读未提交 2.两个窗口都分别开启事务 读已提交演示 1.设置A窗口的隔离级别为 读已提交 2.A B 两个窗口都开启事务， 在B窗口执行更新操作 3.在A窗口执行的查询结果不一致。 一次是在B窗口提交事务之前，一次是在B窗口提交事务之后。 这个隔离级别能够屏蔽 脏读的现象， 但是引发了另一个问题 ，不可重复读。 可串行化 1234567&gt; 如果有一个连接的隔离级别设置为了串行化 ，那么谁先打开了事务， 谁就有了先执行的权利， 谁后打开事务，谁就只能得着，等前面的那个事务，提交或者回滚后，才能执行。 但是这种隔离级别一般比较少用。 容易造成性能上的问题。 效率比较低。- 按效率划分，从高到低&gt; 读未提交 &gt; 读已提交 &gt; 可重复读 &gt; 可串行化- 按拦截程度 ，从高到底&gt; 可串行化 &gt; 可重复读 &gt; 读已提交 &gt; 读未提交 事务总结 12345678910111213141516171819202122232425262728293031323334353637383940414243需要掌握的1.在代码里面会使用事务 conn.setAutoCommit(false); conn.commit(); conn.rollback(); 2 事务只是针对连接连接对象，如果再开一个连接对象，那么那是默认的提交。3. 事务是会自动提交的。 需要了解的&gt;&gt;安全隐患 读 脏读 一个事务读到了另一个事务未提交的数据 不可重复读 一个事务读到了另一个事务已提交的数据，造成前后两次查询结果不一致 幻读 一个事务读到了另一个事务insert的数据 ，造成前后查询结果不一致 。 写 丢失更新。&gt;&gt;隔离级别读未提交&gt; 引发问题： 脏读 读已提交&gt; 解决： 脏读 ， 引发： 不可重复读可重复读&gt; 解决： 脏读 、 不可重复读 ， 未解决： 幻读可串行化&gt; 解决： 脏读、 不可重复读 、 幻读。 mySql 默认的隔离级别是 可重复读Oracle 默认的隔离级别是 读已提交&gt;&gt;丢失更新 解决丢失更新 悲观锁 可以在查询的时候，加入 for update 乐观锁 要求程序员自己控制。 数据库连接池 123&gt; 1. 数据库的连接对象创建工作，比较消耗性能。 &gt; 2.一开始现在内存中开辟一块空间（集合） ， 一开先往池子里面放置 多个连接对象。 后面需要连接的话，直接从池子里面去。不要去自己创建连接了。 使用完毕， 要记得归还连接。确保连接对象能循环利用。 自定义数据库连接池 12345678910111213- 代码实现- 出现的问题： 1. 需要额外记住 addBack方法 2. 单例。 3. 无法面向接口编程。 UserDao dao = new UserDaoImpl(); dao.insert(); DataSource dataSource = new MyDataSource(); 因为接口里面没有定义addBack方法。 4.怎么解决? 以addBack 为切入点。 解决自定义数据库连接池出现的问题。 123456789101112&gt; 由于多了一个addBack 方法，所以使用这个连接池的地方，需要额外记住这个方法，并且还不能面向接口编程。&gt; 我们打算修改接口中的那个close方法。 原来的Connection对象的close方法，是真的关闭连接。 &gt; 打算修改这个close方法，以后在调用close， 并不是真的关闭，而是归还连接对象。###如何扩展某一个方法?&gt; 原有的方法逻辑，不是我们想要的。 想修改自己的逻辑1. 直接改源码 无法实现。2. 继承， 必须得知道这个接口的具体实现是谁。 3. 使用装饰者模式。 开源连接池 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#### DBCP1. 导入jar文件2. 不使用配置文件：public void testDBCP01()&#123; Connection conn = null; PreparedStatement ps = null; try &#123; //1. 构建数据源对象 BasicDataSource dataSource = new BasicDataSource(); //连的是什么类型的数据库， 访问的是哪个数据库 ， 用户名， 密码。。 //jdbc:mysql://localhost/bank 主协议：子协议 ://本地/数据库 dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost/bank&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //2. 得到连接对象 conn = dataSource.getConnection(); String sql = &quot;insert into account values(null , ? , ?)&quot;; ps = conn.prepareStatement(sql); ps.setString(1, &quot;admin&quot;); ps.setInt(2, 1000); ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtil.release(conn, ps); &#125; &#125; 2.使用配置文件方式： Connection conn = null; PreparedStatement ps = null; try &#123; BasicDataSourceFactory factory = new BasicDataSourceFactory(); Properties properties = new Properties(); InputStream is = new FileInputStream(&quot;src//dbcpconfig.properties&quot;); properties.load(is); DataSource dataSource = factory.createDataSource(properties); //2. 得到连接对象 conn = dataSource.getConnection(); String sql = &quot;insert into account values(null , ? , ?)&quot;; ps = conn.prepareStatement(sql); ps.setString(1, &quot;liangchaowei&quot;); ps.setInt(2, 100); ps.executeUpdate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtil.release(conn, ps); &#125; C3P0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748拷贝jar文件 到 lib目录不使用配置文件方式 Connection conn = null; PreparedStatement ps = null; try &#123; //1. 创建datasource ComboPooledDataSource dataSource = new ComboPooledDataSource(); //2. 设置连接数据的信息 dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); //忘记了---&gt; 去以前的代码 ---&gt; jdbc的文档 dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost/bank&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //2. 得到连接对象 conn = dataSource.getConnection(); String sql = &quot;insert into account values(null , ? , ?)&quot;; ps = conn.prepareStatement(sql); ps.setString(1, &quot;admi234n&quot;); ps.setInt(2, 103200); ps.executeUpdate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtil.release(conn, ps); &#125; 使用配置文件方式 //默认会找 xml 中的 default-config 分支。 ComboPooledDataSource dataSource = new ComboPooledDataSource(); //2. 设置连接数据的信息 dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); //忘记了---&gt; 去以前的代码 ---&gt; jdbc的文档 dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost/bank&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //2. 得到连接对象 conn = dataSource.getConnection(); String sql = &quot;insert into account values(null , ? , ?)&quot;; ps = conn.prepareStatement(sql); ps.setString(1, &quot;admi234n&quot;); ps.setInt(2, 103200); DBUtils 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748增删改 //dbutils 只是帮我们简化了CRUD 的代码， 但是连接的创建以及获取工作。 不在他的考虑范围 QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource()); //增加 //queryRunner.update(&quot;insert into account values (null , ? , ? )&quot;, &quot;aa&quot; ,1000); //删除 //queryRunner.update(&quot;delete from account where id = ?&quot;, 5); //更新 //queryRunner.update(&quot;update account set money = ? where id = ?&quot;, 10000000 , 6); 查询1.直接new接口的匿名实现类 QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource()); Account account = queryRunner.query(&quot;select * from account where id = ?&quot;, new ResultSetHandler&lt;Account&gt;()&#123; @Override public Account handle(ResultSet rs) throws SQLException &#123; Account account = new Account(); while(rs.next())&#123; String name = rs.getString(&quot;name&quot;); int money = rs.getInt(&quot;money&quot;); account.setName(name); account.setMoney(money); &#125; return account; &#125; &#125;, 6); System.out.println(account.toString()); 2.直接使用框架已经写好的实现类。* 查询单个对象 QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource()); //查询单个对象 Account account = queryRunner.query(&quot;select * from account where id = ?&quot;, new BeanHandler&lt;Account&gt;(Account.class), 8);* 查询多个对象 QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource()); List&lt;Account&gt; list = queryRunner.query(&quot;select * from account &quot;, new BeanListHandler&lt;Account&gt;(Account.class)); ResultSetHandler 常用的实现类 12345678910111213以下两个是使用频率最高的BeanHandler, 查询到的单个数据封装成一个对象BeanListHandler, 查询到的多个数据封装 成一个List&lt;对象&gt;ArrayHandler, 查询到的单个数据封装成一个数组ArrayListHandler, 查询到的多个数据封装成一个集合 ，集合里面的元素是数组。MapHandler, 查询到的单个数据封装成一个mapMapListHandler,查询到的多个数据封装成一个集合 ，集合里面的元素是map。 ColumnListHandlerKeyedHandlerScalarHandler 总结 123456789101112131415161718192021222324252627282930313233事务使用命令行演示使用代码演示脏读、不可重复读、幻读丢失更新悲观锁乐观锁4个隔离级别 读未提交 读已提交 可重复读 可串行化 数据连接池- DBCP 不使用配置 使用配置- C3P0 不使用配置 使用配置 （必须掌握）- 自定义连接池 装饰者模式 DBUtils&gt; 简化了我们的CRUD ， 里面定义了通用的CRUD方法。 queryRunner.update();queryRunner.query MVC设计模式元数据 12345Meata data 描述数据的数据 String sql , 描述这份sql字符串的数据叫做元数据数据库元数据 DatabaseMetaData参数元数据 ParameterMetaData结果集元数据 ResultSetMetaData JSP的开发模式 三层架构&amp;MVC练习 学生信息管理系统–数据库准备–查询 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485CREATE DATABASE stus;USE stus;CREATE TABLE stu ( sid INT PRIMARY KEY AUTO_INCREMENT, sname VARCHAR (20), gender VARCHAR (5), phone VARCHAR (20), birthday DATE, hobby VARCHAR(50), info VARCHAR(200));查询1. 先写一个JSP 页面， 里面放一个超链接 。 &lt;a href=&quot;StudentListServlet&quot;&gt; 学生列表显示&lt;/a&gt;2. 写Servlet， 接收请求， 去调用 Service , 由service去调用dao3. 先写Dao , 做Dao实现。public interface StudentDao &#123;/**- 查询所有学生 - @return List&lt;Student&gt; */ List&lt;Student&gt; findAll() throws SQLException ; &#125; public class StudentDaoImpl implements StudentDao &#123; /** * 查询所有学生 * @throws SQLException */ @Override public List&lt;Student&gt; findAll() throws SQLException &#123; QueryRunner runner = new QueryRunner(JDBCUtil02.getDataSource()); return runner.query(&quot;select * from stu&quot;, new BeanListHandler&lt;Student&gt;(Student.class)); &#125; &#125;4.再Service , 做Service的实现。/** * 这是学生的业务处理规范 * @author xiaomi * */ public interface StudentService &#123; /** * 查询所有学生 * @return List&lt;Student&gt; */ List&lt;Student&gt; findAll() throws SQLException ; &#125; ------------------------------------------ /** * 这是学生业务实现 * @author xiaomi * */ public class StudentServiceImpl implements StudentService&#123; @Override public List&lt;Student&gt; findAll() throws SQLException &#123; StudentDao dao = new StudentDaoImpl(); return dao.findAll(); &#125; &#125;5.在servlet 存储数据，并且做出页面响应。protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; try &#123; //1. 查询出来所有的学生 StudentService service = new StudentServiceImpl(); List&lt;Student&gt; list = service.findAll(); //2. 先把数据存储到作用域中 request.setAttribute(&quot;list&quot;, list); //3. 跳转页面 request.getRequestDispatcher(&quot;list.jsp&quot;).forward(request, response); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;在list.jsp上显示数据EL + JSTL + 表格 增加 1234567891011121314151. 先跳转到增加的页面 ， 编写增加的页面2. 点击添加，提交数据到AddServlet . 处理数据。3. 调用service4. 调用dao, 完成数据持久化。5. 完成了这些存储工作后，需要跳转到列表页面。 这里不能直接跳转到列表页面，否则没有什么内容显示。 应该先跳转到查询所有学生信息的那个Servlet， 由那个Servlet再去跳转到列表页面。6. 爱好的value 值有多个。 request.getParameter(&quot;hobby&quot;); String[] hobby = request.getParameterValues(&quot;hobby&quot;) ---&gt; String[] String value = Arrays.toString(hobby): // [爱好， 篮球， 足球] 删除 123456789101112131415161718191.点击超链接，弹出一个询问是否删除的对话框，如果点击了确定，那么就真的删除。&lt;a href=&quot;#&quot; onclick=&quot;doDelete($&#123;stu.sid&#125;)&quot;&gt;删除&lt;/a&gt;2.让超链接，执行一个js方法&lt;script type=&quot;text/javascript&quot;&gt;function doDelete(sid) &#123; /* 如果这里弹出的对话框，用户点击的是确定，就马上去请求Servlet。 如何知道用户点击的是确定。 如何在js的方法中请求servlet。 */ var flag = confirm(&quot;是否确定删除?&quot;); if(flag)&#123; //表明点了确定。 访问servlet。 在当前标签页上打开 超链接， //window.location.href=&quot;DeleteServlet?sid=&quot;+sid; location.href=&quot;DeleteServlet?sid=&quot;+sid; &#125; &#125;&lt;/script&gt;3.在js访问里面判断点击的选项，然后跳转到servlet。4.servlet收到了请求，然后去调用service ， service去调用dao 更新 12345678910111213141516171819202122232425262728293031323334353637383940411. 点击列表上的更新， 先跳转到一个EditServlet &gt; 在这个Servlet里面，先根据ID 去查询这个学生的所有信息出来。2. 跳转到更新的页面。 ，然后在页面上显示数据 &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;sname&quot; value=&quot;$&#123;stu.sname &#125;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt; &lt;!-- 如果性别是男的， 可以在男的性别 input标签里面， 出现checked , 如果性别是男的， 可以在女的性别 input标签里面，出现checked --&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;男&quot; &lt;c:if test=&quot;$&#123;stu.gender == &apos;男&apos;&#125;&quot;&gt;checked&lt;/c:if&gt;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;女&quot; &lt;c:if test=&quot;$&#123;stu.gender == &apos;女&apos;&#125;&quot;&gt;checked&lt;/c:if&gt;&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;爱好&lt;/td&gt; &lt;td&gt; &lt;!-- 爱好： 篮球 ， 足球 ， 看书 因为爱好有很多个， 里面存在包含的关系 --&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;游泳&quot; &lt;c:if test=&quot;$&#123;fn:contains(stu.hobby,&apos;游泳&apos;) &#125;&quot;&gt;checked&lt;/c:if&gt;&gt;游泳 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;篮球&quot; &lt;c:if test=&quot;$&#123;fn:contains(stu.hobby,&apos;篮球&apos;) &#125;&quot;&gt;checked&lt;/c:if&gt;&gt;篮球 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;足球&quot; &lt;c:if test=&quot;$&#123;fn:contains(stu.hobby,&apos;足球&apos;) &#125;&quot;&gt;checked&lt;/c:if&gt;&gt;足球 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;看书&quot; &lt;c:if test=&quot;$&#123;fn:contains(stu.hobby,&apos;看书&apos;) &#125;&quot;&gt;checked&lt;/c:if&gt;&gt;看书 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;写字&quot; &lt;c:if test=&quot;$&#123;fn:contains(stu.hobby,&apos;写字&apos;) &#125;&quot;&gt;checked&lt;/c:if&gt;&gt;写字 &lt;/td&gt; &lt;/tr&gt; 3.修改完毕后，提交数据到UpdateServlet提交上来的数据是没有带id的，所以我们要手动创建一个隐藏的输入框， 在这里面给定id的值， 以便提交表单，带上id。 &lt;form method=&quot;post&quot; action=&quot;UpdateServlet&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;sid&quot; value=&quot;$&#123;stu.sid &#125;&quot;&gt; ... &lt;/form&gt; 4.获取数据，调用service， 调用dao. 分页功能 1234567891011- 物理分页 （真分页）&gt; 来数据库查询的时候，只查一页的数据就返回了。 优点 内存中的数据量不会太大 缺点：对数据库的访问频繁了一点。 SELECT * FROM stu LIMIT 5 OFFSET 2 - 逻辑分页 （假分页）&gt; 一口气把所有的数据全部查询出来，然后放置在内存中。 优点： 访问速度快。缺点： 数据库量过大，内存溢出。 Ajax &amp; JqueryAjax 12345678910- 是什么?&gt; “Asynchronous Javascript And XML”（异步JavaScript和XML），&gt; 并不是新的技术，只是把原有的技术，整合到一起而已。 1.使用CSS和XHTML来表示。 2. 使用DOM模型来交互和动态显示。 3.使用XMLHttpRequest来和服务器进行异步通信。 4.使用javascript来绑定和调用。 - 有什么用?&gt; 咱们的网页如果想要刷新局部内容。 那么需要重新载入整个网页。用户体验不是很好。 就是为了解决局部刷新的问题。 保持其他部分不动，只刷新某些地方。 数据请求 Get 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263641.创建对象 function ajaxFunction()&#123; var xmlHttp; try&#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; catch (e)&#123;&#125; &#125; &#125; return xmlHttp; &#125; 2. 发送请求 //执行get请求function get() &#123; //1. 创建xmlhttprequest 对象 var request = ajaxFunction(); //2. 发送请求。 // http://localhost:8080/day16/demo01.jsp //http://localhost:8080/day16/DemoServlet01 /* 参数一： 请求类型 GET or POST 参数二： 请求的路径 参数三： 是否异步， true or false */ request.open(&quot;GET&quot; ,&quot;/day16/DemoServlet01&quot; ,true ); request.send();&#125;如果发送请求的同时，还想获取数据，那么代码如下//执行get请求function get() &#123; //1. 创建xmlhttprequest 对象 var request = ajaxFunction(); //2. 发送请求 request.open(&quot;GET&quot; ,&quot;/day16/DemoServlet01?name=aa&amp;age=18&quot; ,true ); //3. 获取响应数据 注册监听的意思。 一会准备的状态发生了改变，那么就执行 = 号右边的方法 request.onreadystatechange = function()&#123; //前半段表示 已经能够正常处理。 再判断状态码是否是200 if(request.readyState == 4 &amp;&amp; request.status == 200)&#123; //弹出响应的信息 alert(request.responseText); &#125; &#125; request.send();&#125; 数据请求 Post 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;script type=&quot;text/javascript&quot;&gt;//1. 创建对象function ajaxFunction()&#123; var xmlHttp; try&#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; catch (e)&#123;&#125; &#125; &#125; return xmlHttp; &#125;function post() &#123; //1. 创建对象 var request = ajaxFunction(); //2. 发送请求 request.open( &quot;POST&quot;, &quot;/day16/DemoServlet01&quot;, true ); //如果不带数据，写这行就可以了 //request.send(); //如果想带数据，就写下面的两行 //如果使用的是post方式带数据，那么 这里要添加头， 说明提交的数据类型是一个经过url编码的form表单数据 request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); //带数据过去 ， 在send方法里面写表单数据。 request.send(&quot;name=aobama&amp;age=19&quot;);&#125;&lt;/script&gt;需要获取数据function post() &#123; //1. 创建对象 var request = ajaxFunction(); //2. 发送请求 request.open( &quot;POST&quot;, &quot;/day16/DemoServlet01&quot;, true ); //想获取服务器传送过来的数据， 加一个状态的监听。 request.onreadystatechange=function()&#123; if(request.readyState==4 &amp;&amp; request.status == 200)&#123; alert(&quot;post：&quot;+request.responseText); &#125; &#125; //如果使用的是post方式带数据，那么 这里要添加头， 说明提交的数据类型是一个经过url编码的form表单数据 request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); //带数据过去 ， 在send方法里面写表单数据。 request.send(&quot;name=aobama&amp;age=19&quot;); &#125; 校验用户名是否可用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566671. 搭建环境页面准备&lt;body&gt; &lt;table border=&quot;1&quot; width=&quot;500&quot;&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; onblur=&quot;checkUserName()&quot;&gt;&lt;span id=&quot;span01&quot;&gt;&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;邮箱&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;简介&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; 2.数据库准备 Servlet代码 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; try &#123; request.setCharacterEncoding(&quot;UTF-8&quot;); //1. 检测是否存在 String name = request.getParameter(&quot;name&quot;); System.out.println(&quot;name=&quot;+name); UserDao dao = new UserDaomImpl(); boolean isExist = dao.checkUserName(name); //2. 通知页面，到底有还是没有。 if(isExist)&#123; response.getWriter().println(1); //存在用户名 &#125;else&#123; response.getWriter().println(2); //不存在该用户名 &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;&#125;3. Dao代码public class UserDaomImpl implements UserDao&#123; @Override public boolean checkUserName(String username) throws SQLException &#123; QueryRunner runner = new QueryRunner(JDBCUtil02.getDataSource()); String sql = &quot;select count(*) from t_user where username =?&quot;; runner.query(sql, new ScalarHandler(), username); Long result = (Long) runner.query(sql, new ScalarHandler(), username); return result &gt; 0 ; &#125; &#125; jsp页面显示 1234567891011121314151617181920212223242526272829function checkUserName() &#123;//获取输入框的值 document 整个网页 var name = document.getElementById(&quot;name&quot;).value; // value value() val val() //1. 创建对象 var request = ajaxFunction(); //2. 发送请求 request.open(&quot;POST&quot; ,&quot;/day16/CheckUserNameServlet&quot; , true ); //注册状态改变监听，获取服务器传送过来的数据 request.onreadystatechange = function()&#123; if(request.readyState == 4 &amp;&amp; request.status == 200)&#123; //alert(request.responseText); var data = request.responseText; if(data == 1)&#123; //alert(&quot;用户名已存在&quot;); document.getElementById(&quot;span01&quot;).innerHTML = &quot;&lt;font color=&apos;red&apos;&gt;用户名已存在!&lt;/font&gt;&quot;; &#125;else&#123; document.getElementById(&quot;span01&quot;).innerHTML = &quot;&lt;font color=&apos;green&apos;&gt;用户名可用!&lt;/font&gt;&quot;; //alert(&quot;用户名未存在&quot;); &#125; &#125; &#125; request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); request.send(&quot;name=&quot;+name);&#125; JQuery 123456- 是什么?&gt; javascript 的代码框架。 - 有什么用?&gt; 简化代码，提高效率。 - 核心 &gt; write less do more , 写得更少，做的更多。 load 123456789&lt;a href=&quot;&quot; onclick=&quot;load()&quot;&gt;使用JQuery执行load方法&lt;/a&gt;有两次刷新， 先走 onClick的方法，取到数据回来之后，赋值显示。 接着 走 href=&quot;&quot;的路径，但是这个属性没有给值，所以会把当前的页面重新再刷新一次。所以导致看不见值。//找到这个元素， 去执行加载的动作， 加载/day16/DemoServlet02 ， 得到的数据，赋值显示$(&quot;#aaa&quot;).load(&quot;/day16/DemoServlet02&quot; , function(responseText , statusTXT , xhr) &#123; //找到id为text01的元素， 设置它的value属性值为 responseText 对应的值 $(&quot;#aaa&quot;).val(responseText); &#125;); Get 123456789$.get(&quot;/day16/DemoServlet02&quot; , function(data ,status) &#123; $(&quot;#div01&quot;).text(data); &#125;);赋值显示- val(&quot;aa&quot;); &gt; 只能放那些标签带有value属性- html(&quot;aa&quot;); ---写html代码- text(&quot;aa&quot;);&gt; 其实没有什么区别，如果想针对这分数据做html样式处理，那么只能用html() load &amp; get 12345678910111213141516load$(&quot;#元素id&quot;).load(url地址);$(&quot;#div1&quot;).load(serlvet); ---&gt; 使用的get请求，回来赋值的时候， 使用text（）;去赋值get语法格式 ： $.get(URL,callback); 使用案例： $.get(&quot;/day16/DemoServlet02&quot; , function(data ,status) &#123; $(&quot;#div01&quot;).text(data); &#125;);post语法格式：$.post(URL,data,callback); function post() &#123; $.post(&quot;/day16/DemoServlet02&quot;, &#123;name:&quot;zhangsan&quot;,age:18&#125;,function(data,status) &#123; //想要放数据到div里面去。 --- 找到div $(&quot;#div01&quot;).html(data); &#125;); &#125; 使用JQuery去实现校验用户名 1234567891011121314151617function checkUserName() &#123; //1. 获取输入框的内容 var name = $(&quot;#name&quot;).val(); //2. 发送请求 $.post(&quot;/day16/CheckUserNameServlet&quot; , &#123;name:name&#125; , function(data , status)&#123; //alert(data); if(data == 1)&#123;//用户名存在 //alert(&quot;用户名存在&quot;); $(&quot;#span01&quot;).html(&quot;&lt;font color=&apos;red&apos;&gt;用户名已被注册&lt;/font&gt;&quot;); &#125;else&#123; //alert(&quot;用户名可用&quot;); $(&quot;#span01&quot;).html(&quot;&lt;font color=&apos;green&apos;&gt;用户名可以使用&lt;/font&gt;&quot;); &#125; &#125; ); //3. 输出响应的数据到页面上。&#125; 实现百度搜索提示 12345678910111213141516171819202122232425262728293031323334353637383940搭建环境1.定义首页&lt;body&gt; &lt;center&gt; &lt;h2&gt;黑马&lt;/h2&gt; &lt;input type=&quot;text&quot; name=&quot;word&quot; id=&quot;word&quot; style=&quot;width: 600px ; height: 50px ;font-size: 20px;&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;黑马一下&quot; style=&quot;height: 55px ; width: 100px ; &quot;&gt; &lt;div id=&quot;div01&quot; style=&quot;position:relative; left : -54px; width: 600px; height: 200px ; border: 1px solid blue; display: none&quot;&gt;&lt;/div&gt;&lt;/center&gt;&lt;/body&gt;2.定义数据库###捕获键盘弹起$(function()&#123; $(&quot;#word&quot;).keyup(function() &#123; alert(&quot;键盘弹起了..&quot;); &#125;)&#125;);###JS请求$(function()&#123; $(&quot;#word&quot;).keyup(function() &#123; //2。 获取输入框的值 //var word = $(&quot;#word&quot;).val(); //this 对应就是执行这个方法的那个对象， $(&quot;#word&quot;) var word = $(this).val(); if(word == &quot;&quot;)&#123; $(&quot;#div01&quot;).hide(); &#125;else&#123; //3. 请求数据。 $.post(&quot;find&quot;,&#123;word:word&#125; ,function(data , status)&#123; //alert(data); $(&quot;#div01&quot;).show(); $(&quot;#div01&quot;).html(data); &#125;); &#125; &#125;)&#125;); Servlet代码 123456789101112131415161718192021222324252627protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(&quot;utf-8&quot;); try &#123; //1. 先获取参数 String word = request.getParameter(&quot;word&quot;); System.out.println(&quot;word=&quot;+word); //2. 让dao执行查询 WordsDao dao = new WordsDaoImpl(); List&lt;WordBean&gt; list = dao.findWords(word); for (WordBean wordBean : list) &#123; System.out.println(&quot;===&quot;+wordBean.toString()); &#125; request.setAttribute(&quot;list&quot;, list); //3. 返回数据 response.setContentType(&quot;text/html;charset=utf-8&quot;); //response.getWriter().write(&quot;数据是：&quot;); request.getRequestDispatcher(&quot;list.jsp&quot;).forward(request, response); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; list.jsp 1234567891011&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt; &lt;table style=&quot;width: 100%&quot;&gt; &lt;c:forEach items=&quot;$&#123;list &#125;&quot; var=&quot;wordBean&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;wordBean.words&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; 使用JQuery实现 省市联动 1234567891011121314151617181920环境准备1. 准备数据库2 。 准备页面&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.11.3.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/city.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; 省份: &lt;select name=&quot;province&quot; id =&quot;province&quot;&gt; &lt;option value=&quot;&quot; &gt;-请选择 - &lt;option value=&quot;1&quot; &gt;广东 &lt;option value=&quot;2&quot; &gt;湖南 &lt;option value=&quot;3&quot; &gt;湖北 &lt;option value=&quot;4&quot; &gt;四川 &lt;/select&gt; 城市: &lt;select name=&quot;city&quot; id=&quot;city&quot;&gt; &lt;option value=&quot;&quot; &gt;-请选择 - &lt;/select&gt; &lt;/body&gt; XStream的使用 1234567891011//3. 返回数据。手动拼 ---&gt; XStream 转化 bean对象成 xml XStream xStream = new XStream(); //想把id做成属性 xStream.useAttributeFor(CityBean.class, &quot;id&quot;); //设置别名 xStream.alias(&quot;city&quot;, CityBean.class); //转化一个对象成xml字符串 String xml = xStream.toXML(list); JS代码 12345678910111213141516171819202122232425262728293031323334353637383940$(function() &#123; //1。找到省份的元素 $(&quot;#province&quot;).change(function() &#123; //2. 一旦里面的值发生了改变，那么就去请求该省份的城市数据 //$(&quot;#province&quot;).varl(); var pid = $(this).val(); /*&lt;list&gt; &lt;city&gt; &lt;id&gt;1&lt;id&gt; &lt;pid&gt;1&lt;/pid&gt; &lt;cname&gt;深圳&lt;/cname&gt; &lt;/city&gt; &lt;city &gt; &lt;id&gt;2&lt;id&gt; &lt;pid&gt;1&lt;/pid&gt; &lt;cname&gt;东莞&lt;/cname&gt; &lt;/city&gt; &lt;/list&gt;*/ $.post( &quot;CityServlet&quot;,&#123;pid:pid&#125; ,function(data,status)&#123; //alert(&quot;回来数据了:&quot;+data); //先清空以前的值： $(&quot;#city&quot;).html(&quot;&lt;option value=&apos;&apos; &gt;-请选择-&quot;) //遍历： //从data数据里面找出所有的city ， 然后遍历所有的city。 //遍历一个city，就执行一次function方法 $(data).find(&quot;city&quot;).each(function() &#123; //遍历出来的每一个city，取它的孩子。 id , cname var id = $(this).children(&quot;id&quot;).text(); var cname = $(this).children(&quot;cname&quot;).text(); $(&quot;#city&quot;).append(&quot;&lt;option value=&apos;&quot;+id+&quot;&apos; &gt;&quot;+cname) &#125;); &#125; ); &#125;);&#125;); 服务器和客户端数据传输的方式 1234567891011121314151617181920212223242526xml&lt;list&gt; &lt;city&gt; &lt;id&gt;1&lt;id&gt; &lt;pid&gt;1&lt;/pid&gt; &lt;cname&gt;深圳&lt;/cname&gt; &lt;/city&gt; &lt;city &gt; &lt;id&gt;2&lt;id&gt; &lt;pid&gt;1&lt;/pid&gt; &lt;cname&gt;东莞&lt;/cname&gt; &lt;/city&gt; &lt;/list&gt; json阅读性更好 、 容量更小。&#123;&quot;name&quot;:&quot;aaa&quot; , &quot;age&quot;:19&#125;把javaBean 转化成 json数据 //3. 把list ---&gt; json数据 //JSONArray ---&gt; 变成数组 ， 集合 [] //JSONObject ---&gt; 变成简单的数据 &#123; name : zhangsan , age:18&#125; JSONArray jsonArray = JSONArray.fromObject(list); String json = jsonArray.toString(); 使用json格式数据显示省市联动效果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960serlvet代码：protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; try &#123; //1. 获取参数 int pid = Integer.parseInt(request.getParameter(&quot;pid&quot;)); //2 找出所有的城市 CityDao dao = new CityDaoImpl(); List&lt;CityBean&gt; list = dao.findCity(pid); //3. 把list ---&gt; json数据 //JSONArray ---&gt; 变成数组 ， 集合 [] //JSONObject ---&gt; 变成简单的数据 &#123; name : zhangsan , age:18&#125; JSONArray jsonArray = JSONArray.fromObject(list); String json = jsonArray.toString(); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().write(json); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;;&#125;js代码$(function() &#123; //1。找到省份的元素 $(&quot;#province&quot;).change(function() &#123; //2. 一旦里面的值发生了改变，那么就去请求该省份的城市数据 //$(&quot;#province&quot;).varl(); var pid = $(this).val(); /*[ &#123; &quot;cname&quot;: &quot;深圳&quot;, &quot;id&quot;: 1, &quot;pid&quot;: 1 &#125;, &#123; &quot;cname&quot;: &quot;东莞&quot;, &quot;id&quot;: 2, &quot;pid&quot;: 1 &#125; ... ]*/ $.post( &quot;CityServlet02&quot;,&#123;pid:pid&#125; ,function(data,status)&#123; //先清空 $(&quot;#city&quot;).html(&quot;&lt;option value=&apos;&apos; &gt;-请选择-&quot;); //再遍历，追加 $(data).each(function(index , c) &#123; $(&quot;#city&quot;).append(&quot;&lt;option value=&apos;&quot;+c.id+&quot;&apos; &gt;&quot;+c.cname) &#125;); &#125;,&quot;json&quot; ); &#125;); &#125;); ##总结 ###Ajax 发送get请求 发送post请求 都要求带数据 + 获取数据＋ 放置到元素上。 JQuery 发送get请求 发送post请求 都要求带数据 + 获取数据＋ 放置到元素上。 服务器返回xml数据 服务器返回json数据]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>JavaEE</tag>
      </tags>
  </entry>
</search>
