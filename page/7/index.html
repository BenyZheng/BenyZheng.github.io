<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/libs/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/libs/pace/pace-theme-flash.min.css?v=1.0.2">


















  
  
  
  

  
    
    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Monda:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|Monda:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext">
  






<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_small.ico?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.0',
    sidebar: {"position":"left","display":"hide","offset":12,"onmobile":true,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Beny&#39;s blog">
<meta property="og:url" content="https://benyzheng.github.io/page/7/index.html">
<meta property="og:site_name" content="Beny&#39;s blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Beny&#39;s blog">





  
  
  <link rel="canonical" href="https://benyzheng.github.io/page/7/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Beny's blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Beny's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Nothing worth having comes easy.</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">15</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">71</span></a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

<a href="https://github.com/bengzheng" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/数据库/数据库之索引/数据库之索引/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/数据库/数据库之索引/数据库之索引/" class="post-title-link" itemprop="url">数据库之索引</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 23:44:39" itemprop="dateModified" datetime="2019-10-06T23:44:39+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T23:44:39+08:00" content="2019-10-06">
                2019-10-06 23:44:39
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/数据库/数据库之索引/数据库之索引/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/数据库/数据库之索引/数据库之索引/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据库之索引"><a href="#数据库之索引" class="headerlink" title="数据库之索引"></a>数据库之索引</h1><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>在创建表的时候添加索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable(  </span><br><span class="line">    <span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,   </span><br><span class="line">    username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">    <span class="keyword">INDEX</span> [indexName] (username(<span class="keyword">length</span>))  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在创建表以后添加索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> my_table <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span>] <span class="keyword">INDEX</span> index_name(column_name);</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> my_table(column_name);</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>1、索引需要占用磁盘空间，因此在创建索引时要考虑到磁盘空间是否足够</p>
<p>2、创建索引时需要对表加锁，因此实际操作中需要在业务空闲期间进行</p>
<h3 id="根据索引进行查询"><a href="#根据索引进行查询" class="headerlink" title="根据索引进行查询"></a>根据索引进行查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">具体查询：</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_1=column_2;(为column_1建立了索引)</span><br><span class="line"></span><br><span class="line">或者模糊查询</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_1 <span class="keyword">LIKE</span> <span class="string">'%三'</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_1 <span class="keyword">LIKE</span> <span class="string">'三%'</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_1 <span class="keyword">LIKE</span> <span class="string">'%三%'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_1 <span class="keyword">LIKE</span> <span class="string">'_好_'</span></span><br><span class="line"> </span><br><span class="line">如果要表示在字符串中既有A又有B，那么查询语句为：</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_1 <span class="keyword">LIKE</span> <span class="string">'%A%'</span> <span class="keyword">AND</span> column_1 <span class="keyword">LIKE</span> <span class="string">'%B%'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_1 <span class="keyword">LIKE</span> <span class="string">'[张李王]三'</span>;  //表示column_1中有匹配张三、李</span><br><span class="line">三、王三的都可以</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_1 <span class="keyword">LIKE</span> <span class="string">'[^张李王]三'</span>;  //表示column_1中有匹配除了张</span><br><span class="line">三、李三、王三的其他三都可以</span><br><span class="line"></span><br><span class="line">//在模糊查询中，%表示任意0个或多个字符；_表示任意单个字符（有且仅有），通常用来限制字符串长度;[]表示</span><br><span class="line">其中的某一个字符；[^]表示除了其中的字符的所有字符</span><br><span class="line"> </span><br><span class="line">或者在全文索引中模糊查询</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(<span class="keyword">content</span>) AGAINST(<span class="string">'word1'</span>,<span class="string">'word2'</span>,...);</span><br></pre></td></tr></table></figure>
<p>删除索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> my_index <span class="keyword">ON</span> tablename；</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name;</span><br></pre></td></tr></table></figure>
<p>查看表中的索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> tablename</span><br></pre></td></tr></table></figure>
<p>查看查询语句查询索引的情况</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//<span class="keyword">explain</span> 加查询语句</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_1=<span class="string">'123'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h3><p>优点：</p>
<ul>
<li>可以快速检索，加快检索速度</li>
<li>根据索引分组和排序，可以加快分组和排序</li>
</ul>
<p>缺点：</p>
<ul>
<li>索引本身也是表，会占据存储空间</li>
<li>索引表的创建和维护需要时间，随数据量增大而增大</li>
<li>降低数据表的修改操作（删除、添加、修改）的效率，因为在修改数据表的同时也要修改索引表</li>
</ul>
<h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>常见的索引类型有：主键索引、唯一索引、普通索引、全文索引、组合索引</p>
<p>1、主键索引：即主索引，根据主键pk_clolum（length）建立索引，<strong>不允许重复，不允许空值</strong>；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span> pk_index(<span class="string">'col'</span>)；</span><br></pre></td></tr></table></figure>
<p>2、唯一索引：用来建立索引的列的值必须是<strong>唯一的，允许空值</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> index_name(<span class="string">'col'</span>)；</span><br></pre></td></tr></table></figure>
<p>3、普通索引：用表中的普通列构建的索引，没有任何限制</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name(<span class="string">'col'</span>)；</span><br></pre></td></tr></table></figure>
<p>4、全文索引：用大文本对象的列构建的索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> FULLTEXT <span class="keyword">INDEX</span> ft_index(<span class="string">'col'</span>)；</span><br></pre></td></tr></table></figure>
<p>5、组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name(<span class="string">'col1'</span>,<span class="string">'col2'</span>,<span class="string">'col3'</span>)；</span><br></pre></td></tr></table></figure>
<p>遵循“<strong>最左前缀</strong>”原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引<strong>相当于建立了col1,col1col2,col1col2col3三个索引</strong>，而col2或者col3是不能使用索引的。</p>
<p>在使用组合索引的时候可能因为列名长度过长而导致索引的key太大，导致效率降低，在允许的情况下，可以只取col1和col2的前几个字符作为索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name(col1(<span class="number">4</span>),col2（<span class="number">3</span>))；</span><br></pre></td></tr></table></figure>
<p>表示使用col1的前4个字符和col2的前3个字符作为索引。</p>
<h3 id="索引的选取类型"><a href="#索引的选取类型" class="headerlink" title="索引的选取类型"></a>索引的选取类型</h3><p>1、越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快</p>
<p>2、简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂</p>
<p>3、尽量避免NULL：应该指定列为NOT nuLL,在MySQL中， 含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂</p>
<h3 id="什么场景不适合创建索引"><a href="#什么场景不适合创建索引" class="headerlink" title="什么场景不适合创建索引"></a>什么场景不适合创建索引</h3><p>1、很少使用查询或者只是作为参考的列，因为这些列很少用到，添加索引只会增加开销和维护成本</p>
<p>2、很少数据集的列也不应该加索引，例如班级的同学的性别，只有男或女，利用索引相当于全表搜索，没意义</p>
<p>3、当修改性能远远大于检索性能时，因为修改性能和检索性能互相矛盾</p>
<p>4、不会出现在where条件中的字段不该建立索引</p>
<h3 id="什么的字段适合索引"><a href="#什么的字段适合索引" class="headerlink" title="什么的字段适合索引"></a>什么的字段适合索引</h3><p>1、表的主键和外键必须有索引，外键唯一，且经常查询</p>
<p>2、数据量比较多的超过300需要索引</p>
<p>3、经常需要和其他表进行连接查询的字段应该建立索引</p>
<p>4、经常出现在where子句中的字段，加快判断速度</p>
<p>5、经常用到排序的列上，因为索引已经排序</p>
<p>6、经常用在范围内搜索的列上创建索引，因为索引已经排序，指定范围是连续（B+树）</p>
<h3 id="MySQL索引的底层原理"><a href="#MySQL索引的底层原理" class="headerlink" title="MySQL索引的底层原理"></a>MySQL索引的底层原理</h3><p>索引是帮助MySQL高效获取数据的数据结构</p>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/索引方式思路图.png" alt></p>
<p>上图展示的是一种可能的索引方式</p>
<p>左边是数据表，一共有两列14条记录，最左边是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上并不一定物理相邻），但实际数据库系统几乎没有使用二叉查找树或其进化品种<a href="https://link.jianshu.com/?t=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FRed-black_tree" target="_blank" rel="noopener">红黑树</a>（red-black tree）实现</p>
<p>目前大部分数据库系统及文件系统都采用B Tree或其变种B+Tree作为索引结构，MySQL普遍使用B+树实现索引</p>
<p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的</p>
<p><strong>MyISAM和InnoDB对索引和数据的存储在磁盘上是如何体现的</strong></p>
<p>role表使用的存储引擎是MyISAM，而user使用的是InnoDB：</p>
<ol>
<li>role表有三个文件，对应如下：</li>
</ol>
<ul>
<li>role.frm：表结构文件</li>
<li>role.MYD：数据文件（MyISAM Data）</li>
<li>role.MYI：索引文件（MyISAM Index）</li>
</ul>
<ol start="2">
<li>user表有两个文件，对应如下：</li>
</ol>
<ul>
<li>user.frm：表结构文件</li>
<li>user.ibd：索引和数据文件（InnoDB Data）</li>
</ul>
<p>由于两种引擎对索引和数据的存储方式的不同，我们也称MyISAM的索引为非聚集索引，InnoDB的索引为聚集索引。</p>
<p><strong>MyISAM索引实现</strong></p>
<p>MyISAM引擎使用B+Tree作为索引结构，叶节点data域存放数据记录的地址</p>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/MyISAM索引实现.png" alt></p>
<p>设Col1为主键，上图是一个MyISAM表的主索引（Primary key）示例。<br>可以看出MyISAM的索引文件仅仅保存数据记录的地址。<br>在MyISAM中，主索引和辅索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅索引的key可以重复（为什么没有区别，是因为SQL语句中where子句可以使用的是其他字段来作为条件，如clo2&gt;…之类的语句，所以主索引和辅助索引在MyISAM没有区别）<br>如果我们在Col2上建立一个辅索引，则此索引的结构如下图所示：</p>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/MyISAM辅助索引图.png" alt></p>
<p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分</p>
<p><strong>InnoDB索引实现</strong></p>
<ul>
<li>MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址</li>
<li>而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引</li>
</ul>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/InnoDB主索引.png" alt></p>
<p>与MyISAM的区别两点：</p>
<p>一、因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有）</p>
<p>如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键</p>
<p>如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形</p>
<p>二、InnoDB的辅索引data域存储相应记录主键的值而不是地址。</p>
<p>InnoDB的所有辅助索引都引用主键作为data域</p>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/InnoDB辅助索引图.png" alt></p>
<h3 id="索引存在但未使用情况（索引失效、索引优化）"><a href="#索引存在但未使用情况（索引失效、索引优化）" class="headerlink" title="索引存在但未使用情况（索引失效、索引优化）"></a>索引存在但未使用情况（索引失效、索引优化）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_test_a1234 <span class="keyword">ON</span> <span class="keyword">test</span>(a1,a2,a3,a4);//创建联合索引来说明索引失效的一下情况</span><br></pre></td></tr></table></figure>
<p>1.字符串为使用引号，导致索引失效（不能在索引列上干任何操作(计算,函数,类型转换) ）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span>  a1 = a1;//可以查到数据，数据库自动转换类型，但索引失效</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 = <span class="string">'a1'</span>;</span><br></pre></td></tr></table></figure>
<p>2、索引最左原则使用不当，导致索引失效（where子句后面的顺序无关，只要用到就可以）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 = <span class="string">'a1'</span> <span class="keyword">and</span> a2 = <span class="string">'a2'</span> <span class="keyword">and</span> a3 = <span class="string">'a3'</span> <span class="keyword">and</span> a4 = <span class="string">'a4'</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a4= <span class="string">'a4'</span> <span class="keyword">and</span> a3 = <span class="string">'a3'</span> <span class="keyword">and</span> a2 = <span class="string">'a2'</span> <span class="keyword">and</span> a1= <span class="string">'a1'</span>;</span><br><span class="line">以上两个查询中，where条件中的索引位置是相反的，但是执行结果是一致的，这个是由mysql优化器来处理的，因</span><br><span class="line">为两个查询中都出现了联合索引a1,a2，a3,a4，MySQL优化器底层会进行优化处理。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 = <span class="string">'a1'</span> <span class="keyword">and</span> a3 = <span class="string">'a3'</span> <span class="keyword">and</span> a4 = <span class="string">'a4'</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a4= <span class="string">'a4'</span> <span class="keyword">and</span> a3 = <span class="string">'a3'</span> <span class="keyword">and</span> a1= <span class="string">'a1'</span>;</span><br><span class="line">以上两个查询只用到一个索引a1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 = <span class="string">'a1'</span> <span class="keyword">and</span> a2 = <span class="string">'a2'</span>  <span class="keyword">and</span> a4 = <span class="string">'a4'</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a4= <span class="string">'a4'</span> <span class="keyword">and</span> a2 = <span class="string">'a2'</span> <span class="keyword">and</span> a1= <span class="string">'a1'</span>;</span><br><span class="line">以上两个查询用到两个索引</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a2 = <span class="string">'a2'</span> <span class="keyword">and</span> a3 = <span class="string">'a3'</span> <span class="keyword">and</span> a4 = <span class="string">'a4'</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a4= <span class="string">'a4'</span> <span class="keyword">and</span> a3 = <span class="string">'a3'</span> <span class="keyword">and</span> a2 = <span class="string">'a2'</span></span><br><span class="line">以上两个查询未使用索引</span><br></pre></td></tr></table></figure>
<p>3、范围查找导致索引失效（存储引擎不能使用索引中范围条件右边的列）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select * from test where a1 = &apos;a1&apos; and a2 = &apos;a2&apos; and a3 &gt;&apos;a3&apos; and a4 = &apos;a4&apos;;</span><br><span class="line">以上用到a1、a2、a3，3个索引，因为a3右边是a4，导致a4的索引不可用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select * from test where a1 = &apos;a1&apos; and a2 = &apos;a2&apos; and a4 &gt;&apos;a4&apos; and a3= &apos;a3&apos;;</span><br><span class="line">以上用到a1、a2、a3、a4，4个索引，因为a4后面已经没有索引了，不影响</span><br></pre></td></tr></table></figure>
<p>4、order by使用不当，导致索引失效</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 = <span class="string">'a1'</span> <span class="keyword">and</span> a2 = <span class="string">'a2'</span> <span class="keyword">and</span> a4 = <span class="string">'a4'</span> <span class="keyword">order</span> <span class="keyword">by</span> a3</span><br><span class="line"><span class="keyword">explain</span>语句显示两个索引，严格来说以上用到两个索引查询，三个索引排序</span><br><span class="line">因为查找的<span class="keyword">where</span>条件中跳过了a3,违背了索引的最左原则，导致索引a4失效</span><br><span class="line">严格意义上来说，以上查询使用了<span class="number">3</span>个索引，a3并未用于查找，但是在排序中使用到了，只是为统计到<span class="keyword">explain</span>中，即</span><br><span class="line">满足索引的两大功能：查找和排序</span><br></pre></td></tr></table></figure>
<p>以下排序中，索引使用不当，导致产生了文件内排序，影响性能</p>
<p>a2之后a3断开，导致a4索引失效，mysql 为了将结果展现出来，进行了内部排序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 =<span class="string">'a1'</span> <span class="keyword">and</span> a2 = <span class="string">'a2'</span>  <span class="keyword">order</span> <span class="keyword">by</span> a4;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/索引失效oderby1.png" alt></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 =<span class="string">'a1'</span> <span class="keyword">and</span> a5 = <span class="string">'a5'</span>  <span class="keyword">order</span> <span class="keyword">by</span> a2,a3;</span><br><span class="line">使用到a1一个索引</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 =<span class="string">'a1'</span> <span class="keyword">and</span> a5= <span class="string">'a5'</span>  <span class="keyword">order</span> <span class="keyword">by</span> a3,a2;</span><br><span class="line">使用到a1索引，并且产生文件内排序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 =<span class="string">'a1'</span> <span class="keyword">and</span> a2 = <span class="string">'a2'</span>  <span class="keyword">order</span> <span class="keyword">by</span> a2,a3;</span><br><span class="line">使用到a1、a2两个索引，没有产生文件内排序</span><br><span class="line"></span><br><span class="line">原文：https://blog.csdn.net/weixin_39539399/article/details/80842750</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/索引失效oderby2.png" alt></p>
<p>5、group by使用不当导致索引失效</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 =<span class="string">'a1'</span><span class="keyword">and</span> a4 = <span class="string">'a4'</span> <span class="keyword">group</span> <span class="keyword">by</span> a2，a3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 =<span class="string">'a1'</span><span class="keyword">and</span> a4 = <span class="string">'a4'</span> <span class="keyword">group</span> <span class="keyword">by</span> a3，a2;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/索引失效groupby.png" alt></p>
<p>分组之前必排序，group by 表面上是分组，但是对索引的使用和order by 的使用大致相同，所以group by后面如果索引错乱，会产生临时表，导致mysql内部进行排序</p>
<p>6、通配符like的使用不当导致索引失效（like以通配符开头(“%abc…”) ）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 <span class="keyword">like</span> <span class="string">'%a'</span>;索引失效</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>  * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 <span class="keyword">like</span> <span class="string">'a%'</span>;索引不失效</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>  a1 <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 <span class="keyword">like</span> <span class="string">'%a'</span>;覆盖索引，解决最左匹配不当的索引失效问题</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>  * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 <span class="keyword">like</span> <span class="string">'c%'</span>;索引失效</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>  * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 <span class="keyword">like</span> <span class="string">'%c'</span>;索引失效</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>  * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 <span class="keyword">like</span> <span class="string">'abc%'</span>;索引不失效</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/索引失效通配符like.png" alt></p>
<p>6、MYSQL 中!=,&lt;&gt;导致索引失效（is null, is not null 也无法使用索引）</p>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/索引失效等号.png" alt></p>
<p>尽量使用覆盖索引(只访问索引的查询),减少select *，可以解决索引失效的以上问题</p>
<p>7、少用or,用它来连接时索引会失效</p>
<p>关于or导致的索引失效，是有存在这种情况的，即or的左右边的查询条件，有一个列没有加索引，那么另一个列的索引会失效。要想使得索引生效，需要保证or两边的列都有索引，且一个列是主键。</p>
<p>小总结</p>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/索引总结1.png" alt></p>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/索引总结2.png" alt></p>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/索引总结3.png" alt></p>
<p>索引的底层原理其实没有我总结那么简单，水平有限，B+B-树随缘再总结</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/数据结构/4 树和二叉树/树与二叉树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/" class="post-title-link" itemprop="url">树与二叉树</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 22:21:52" itemprop="dateModified" datetime="2019-10-06T22:21:52+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T22:21:52+08:00" content="2019-10-06">
                2019-10-06 22:21:52
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h3><p>一对多的树形结构</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树的结构定义.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树结点相关概念.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树结点相关概念2.png" alt></p>
<h5 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h5><ul>
<li>树中的结点等于所有结点的度数加1</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树的性质1.png" alt></p>
<ul>
<li>度为m的树中第i层上至多有m<sup>i-1</sup>个结点（i&gt;=1）</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树的性质2.png" alt></p>
<ul>
<li><p>高度为h的m叉树至多有（m<sup>h</sup>-1)/(m-1)个结点</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树的性质3.png" alt></p>
</li>
<li><p>具有n个结点的m叉树的最小高度为取上整[log<sub>m</sub>(n(m-1)+1)]</p>
</li>
</ul>
<p>解上一个方程的h即可</p>
<h5 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h5><h6 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h6><p>双亲表示法：用一组连续的存储空间存储树的结点，同时在每个结点中，用一个变量存储该结点的双亲结点在数组中的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//结点数据</span></span><br><span class="line">    <span class="keyword">int</span> parent;<span class="comment">//该结点双亲在数组的下标</span></span><br><span class="line">&#125;TNode;<span class="comment">//结点的数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    TNode nodes[MaxSize];<span class="comment">//结点数组</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//结点的数量</span></span><br><span class="line">&#125;Tree;<span class="comment">//结点双亲表示结构</span></span><br></pre></td></tr></table></figure>
<p>双亲表示法可以根据parent找到该结点的双亲结点，时间复杂度为O(1)。但如果找到某节点的孩子结点就需要遍历</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/顺序存储结构.png" alt></p>
<h6 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h6><p>孩子表示法：把每个结点的孩子结点排列起来存储成一个单链表。所以n个结点就有n个链表；如果时叶子结点，那这个结点的孩子单链表就是空的；然后n个单链表的头指针又存储在一个顺序表（数组）中。</p>
<p>需要设计两种结合结构类型：</p>
<ul>
<li>孩子链表的结点</li>
<li>每个孩子链表的表头结点（存在数组中）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> child;<span class="comment">//该孩子在表头数组的下标</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CNode</span> *<span class="title">next</span>;</span><span class="comment">//指向该结点的下一个孩子结点</span></span><br><span class="line">&#125;CNode,*Child;<span class="comment">//孩子结点数据结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype data;<span class="comment">//结点数据域</span></span><br><span class="line">    Child firstchild;<span class="comment">//指向该结点的第一个孩子结点</span></span><br><span class="line">&#125;TNode<span class="comment">//孩子结点的数据类型</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    TNode nodes[MaxSize];<span class="comment">//结点数据域</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//树中结点个数</span></span><br><span class="line">&#125;Tree;<span class="comment">//树的孩子表示结构</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/链式存储结构.png" alt></p>
<p>孩子兄弟表示法：要存储孩子结点和兄弟结点，就是设置两个指针，分别指向该结点的第一个孩子结点和该结点的兄弟结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//该结点的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">rightsib</span>//指向该结点的第一个孩子结点和该结点的右兄弟结点</span></span><br><span class="line"><span class="class">&#125;<span class="title">CSNode</span>;</span><span class="comment">//孩子兄弟结点数据类型</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/链式存储结构2.png" alt></p>
<h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><p>每个结点最多有两颗子树</p>
<p>左右子树有顺序</p>
<p>五种基本形态</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树五种形态.png" alt></p>
<h6 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/斜树.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/满二叉树.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/完全二叉树.png" alt></p>
<h5 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h5><ul>
<li>非空二叉树上叶子结点等于度为2的结点数加1</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树性质1.png" alt></p>
<ul>
<li>非空二叉树上第K层上至多有2<sup>k-1</sup>个结点（k&gt;=1）</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树性质2.png" alt></p>
<ul>
<li>高度为H的二叉树至多有2<sup>H</sup>-1个结点（H&gt;=1）</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树性质3.png" alt></p>
<ul>
<li>具有N个(N&gt;0)结点的完全二叉树的高度为上取整[log<sub>2</sub>(N+1)]或下取整[log<sub>2</sub>N]+1</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树性质4.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树性质5.png" alt></p>
<h5 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h5><h6 id="顺序存储结构-1"><a href="#顺序存储结构-1" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h6><p>二叉树的顺序存储结构就是用一组地址连续的存储单元依次自上而下，自左而右存储完全二叉树上的结点元素</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树顺序存储.png" alt></p>
<h6 id="链式存储结构-1"><a href="#链式存储结构-1" class="headerlink" title="链式存储结构"></a>链式存储结构</h6><p>二叉树每个结点最多两个孩子，所以设计二叉树的结点结构时考虑两个指针指向该结点的两个孩子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//指向该结点的左右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTNode;<span class="comment">//二叉树结点结构</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树链式存储结构.png" alt></p>
<h5 id="二叉树遍历-递归"><a href="#二叉树遍历-递归" class="headerlink" title="二叉树遍历(递归)"></a>二叉树遍历(递归)</h5><p>二叉树的遍历是指按某种次序依次访问树中的每个结点，使得每个结点均被访问一次，而且仅被访问一次</p>
<h6 id="递归先序遍历"><a href="#递归先序遍历" class="headerlink" title="递归先序遍历"></a>递归先序遍历</h6><p>操作过程：</p>
<ul>
<li>访问根结点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data)<span class="comment">//根节点</span></span><br><span class="line">        PreOrder(T-&gt;lchild);<span class="comment">//左子树</span></span><br><span class="line">        PreOrder(T-&gt;rchild);<span class="comment">//右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="递归中序遍历"><a href="#递归中序遍历" class="headerlink" title="递归中序遍历"></a>递归中序遍历</h6><p>操作过程：</p>
<ul>
<li>中序遍历左子树</li>
<li>访问根节点</li>
<li>中序遍历右子树</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="递归后序遍历"><a href="#递归后序遍历" class="headerlink" title="递归后序遍历"></a>递归后序遍历</h6><p>操作过程：</p>
<ul>
<li>后序遍历左子树</li>
<li>后序遍历右子树</li>
<li>访问根节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        PostOrder(T-&gt;lchild);</span><br><span class="line">        PostOrder(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉树遍历-非递归"><a href="#二叉树遍历-非递归" class="headerlink" title="二叉树遍历(非递归)"></a>二叉树遍历(非递归)</h5><h6 id="非递归先序遍历"><a href="#非递归先序遍历" class="headerlink" title="非递归先序遍历"></a>非递归先序遍历</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree b)</span></span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    BitTree p=b;<span class="comment">//工作指针p</span></span><br><span class="line">    <span class="keyword">while</span>(p || !IsEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,p-&gt;data);<span class="comment">//先序先遍历结点</span></span><br><span class="line">            Push(S,p);<span class="comment">//进栈保存</span></span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!IsEmpty(S))&#123;</span><br><span class="line">            p=Pop(S);</span><br><span class="line">            p=p-rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="非递归中序遍历"><a href="#非递归中序遍历" class="headerlink" title="非递归中序遍历"></a>非递归中序遍历</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree b)</span></span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    BitTree p=b;<span class="comment">//工作指针p</span></span><br><span class="line">    <span class="keyword">while</span>(p || !IsEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            Push(S,p);<span class="comment">//进栈保存</span></span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p=Pop(S);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,p-&gt;data);</span><br><span class="line">        p=p-rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="非递归后序遍历"><a href="#非递归后序遍历" class="headerlink" title="非递归后序遍历"></a>非递归后序遍历</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/非递归后续遍历.png" alt></p>
<h6 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h6><p>操作过程：</p>
<p>若树为空，则什么都不做直接返回；</p>
<p>否则从树的第一层开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问</p>
<p>出队-&gt;访问-&gt;左右孩子入队</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree b)</span></span>&#123;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q,b);<span class="comment">//根节点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,p);<span class="comment">//队头元素出队</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q,p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q,p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h5><p>二叉链表表示的二叉树存在大量空指针</p>
<p>N个结点的二叉树，每个结点都有指向左右孩子的结点指针，所以一共有2N个指针，而N个结点的二叉树一共有N-1个分支，也就是说存在2N-(N-1)=N+1个空指针。</p>
<p>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/线索二叉树.png" alt></p>
<p>对二叉树以某种次序遍历使其变为线索二叉树的过程叫做线索化。</p>
<p>如何区分指针是指向左孩子还是前驱，右孩子还是后继？</p>
<p>在二叉链表结点的结构基础上增加两个标志位ltag和rtag</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,*ThreadTree;<span class="comment">//线索链表</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/线索二叉树结构.png" alt></p>
<ul>
<li>ltag==0表示lchild指向该结点左孩子</li>
<li>ltag==1表示rchild指向该结点前驱</li>
<li>rtag==0表示rchild指向该结点右孩子</li>
<li>rtag==1表示指向该结点后继</li>
</ul>
<h6 id="构造线索二叉树"><a href="#构造线索二叉树" class="headerlink" title="构造线索二叉树"></a>构造线索二叉树</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/构造线索二叉树.png" alt></p>
<h6 id="遍历线索二叉树"><a href="#遍历线索二叉树" class="headerlink" title="遍历线索二叉树"></a>遍历线索二叉树</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/遍历线索二叉树.png" alt></p>
<h5 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h5><p>概念：</p>
<p>权：树中结点相关的数值</p>
<p>路径长度：从树中某个结点到另一个结点之间的分支数目（经过的边数）</p>
<p>带权路径长度：从树的根节点到任意结点的路径长度（经过的边数）与该结点上权值的乘积称为该结点的带权路径长度</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树的带权路径长度.png" alt></p>
<p>哈夫曼树：含有N个带权叶子结点的二叉树中，带有带权路径长度（WPL）最小的二叉树，也成为最优二叉树。</p>
<h6 id="设计哈夫曼树"><a href="#设计哈夫曼树" class="headerlink" title="设计哈夫曼树"></a>设计哈夫曼树</h6><ul>
<li>将这N个结点分别作为N颗仅含一个结点的二叉树，构成森林F</li>
<li>构造一个新结点，并从F中选取两颗根节点权值最小的树作为新结点的左右子树，并且将新结点的权值置为左右子树上根节点的权值之和</li>
<li>从F中删除刚才选出的两棵树，同时将新得到的树加入F中</li>
<li>重复步骤2和3，直至F中只剩下一棵树为止</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/构造哈夫曼树.png" alt></p>
<h6 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h6><p>左子树为0，右子树为1</p>
<p>哈夫曼编码性质</p>
<ul>
<li>哈夫曼编码是前缀编码</li>
<li>哈夫曼编码是最优前缀编码</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/哈夫曼编码.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/哈夫曼编码2.png" alt></p>
<h5 id="二叉树、树和森林"><a href="#二叉树、树和森林" class="headerlink" title="二叉树、树和森林"></a>二叉树、树和森林</h5><h6 id="树转化成二叉树"><a href="#树转化成二叉树" class="headerlink" title="树转化成二叉树"></a>树转化成二叉树</h6><p>用到一个孩子兄弟表示法（回归本章树的链式存储）</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树转二叉树1.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树转二叉树2.png" alt></p>
<h6 id="二叉树转树"><a href="#二叉树转树" class="headerlink" title="二叉树转树"></a>二叉树转树</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树转树.png" alt></p>
<h6 id="森林转二叉树"><a href="#森林转二叉树" class="headerlink" title="森林转二叉树"></a>森林转二叉树</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/森林转二叉树.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/森林转二叉树2.png" alt></p>
<h6 id="二叉树转森林"><a href="#二叉树转森林" class="headerlink" title="二叉树转森林"></a>二叉树转森林</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树转森林.png" alt></p>
<h6 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h6><p>树的先序遍历</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树的先序遍历.png" alt></p>
<p>树的后序遍历</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树的后序遍历.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树与二叉树先序后序遍历比较.png" alt></p>
<h6 id="森林遍历"><a href="#森林遍历" class="headerlink" title="森林遍历"></a>森林遍历</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/森林先序后序遍历.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/数据结构/6 查找/查找/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/数据结构/6 查找/查找/" class="post-title-link" itemprop="url">查找</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 22:23:26" itemprop="dateModified" datetime="2019-10-06T22:23:26+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T22:23:26+08:00" content="2019-10-06">
                2019-10-06 22:23:26
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/数据结构/6 查找/查找/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/数据结构/6 查找/查找/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>查找：在数据集合中寻找满足某种条件的数据元素的过程</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/1 查找表.png" alt></p>
<p>关键字：数据元素中某个可以唯一标识该元素的数据项</p>
<p>平均查找长度</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/2 平均查找长度.png" alt></p>
<h5 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h5><p><img src="/2019/05/26/数据结构/6 查找/查找/3 顺序查找过程.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/4 顺序查找ASL.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/5 顺序查找时间复杂度.png" alt></p>
<h5 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h5><p><img src="/2019/05/26/数据结构/6 查找/查找/6 折半查找.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/7 折半查找判定树.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/8 折半查找时间复杂度.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/9 折半查找成功ASL.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/10 折半查找失败ASL.png" alt></p>
<h5 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h5><p>分块查找又称为索引顺序查找</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/11 分块查找概念.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/12 分块查找思路.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/13 分块查找ASL.png" alt></p>
<h5 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h5><p><img src="/2019/05/26/数据结构/6 查找/查找/14 二叉排序树概念.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/15 二叉排序树查找思路.png" alt></p>
<p>二叉排序树查找递归代码</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/16 二叉排序树查找递归代码.png" alt></p>
<p>二叉排序树查找非递归代码</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/17 二叉排序树非递归代码.png" alt></p>
<p>二叉排序树插入关键字代码</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/18 二叉排序树插入关键字.png" alt></p>
<p>时间复杂度</p>
<p>有n个结点就需要插入n个结点操作，插入一个的时间复杂度为O(log<sub>2</sub>n)，构造复杂度为O(nlog2n)</p>
<p>二叉排序树构造代码</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/19 二叉排序树构造代码.png" alt></p>
<p>二叉排序树删除结点</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/20 二叉排序树删除结点.png" alt></p>
<p>删除叶子结点</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/21 二叉排序树删除叶子结点.png" alt></p>
<p>删除只有左子树或者右子树的结点</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/22 二叉排序树删除只有左子树或右子树结点.png" alt></p>
<p>删除左右子树都有的结点</p>
<p>找到该结点的前驱和后继(即中序遍历的前驱和后继)</p>
<p>前驱替代结点</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/23 二叉排序树删除左右子树都有的结点1.png" alt></p>
<p>后继替代结点</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/24 二叉排序树删除左右子树都有的结点2.png" alt></p>
<p>二叉排序树分析</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/25 二叉排序树分析.png" alt></p>
<h5 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树(AVL树)"></a>平衡二叉树(AVL树)</h5><p><img src="/2019/05/26/数据结构/6 查找/查找/26 平衡二叉树.png" alt></p>
<p>最小不平衡子树</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/27 最小不平衡子树.png" alt></p>
<p>不平衡二叉树类型</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/28 最小不平衡子树类型.png" alt></p>
<p>构建平衡二叉树过程</p>
<p>LL调整</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/29 构建平衡二叉树1.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/30 构建平衡二叉树2.png" alt></p>
<p>RR调整</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/31 构建平衡二叉树3.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/32 构建平衡二叉树4.png" alt></p>
<p>RL调整</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/33 构建平衡二叉树5.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/34 构建平衡二叉树6.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/35 构建平衡二叉树7.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/36 构建平衡二叉树8.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/37 构建平衡二叉树9.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/38 构建平衡二叉树10.png" alt></p>
<p>平衡二叉树结点规律</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/39 平衡二叉树结点规律.png" alt></p>
<h5 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h5><p>2-3树：</p>
<p>2-3是一种多路查找树：2和3的意思就是2-3树包含两种结点</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/40 2-3树.png" alt></p>
<p>2-3-4树：<br><img src="/2019/05/26/数据结构/6 查找/查找/41 2-3-4树.png" alt></p>
<p>B树</p>
<p>磁盘管理系统中的目录管理，以及数据库系统中的索引组织多数都采用B树数据结构</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/42 B树.png" alt></p>
<p>B树查找操作</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/43 B树查找操作.png" alt></p>
<p>B树插入操作</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/44 B树插入操作.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/45 B树插入操作2.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/46 B树插入操作3.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/47 B树插入操作4.png" alt></p>
<p>B树删除操作</p>
<p>删除的关键字在终端结点上(最底层非叶子结点)</p>
<p>第一种情况</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/48 B树删除操作1.png" alt></p>
<p>第二种情况</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/49 B树删除操作2-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/50 B树删除操作2-2.png" alt></p>
<p>第三中情况</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/51 B树删除操作3-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/52 B树删除操作3-2.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/53 B树删除操作3-3.png" alt></p>
<p>删除关键字不在终端结点上(最底层非叶子结点)</p>
<p>第一种情况</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/54 B树删除操作4-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/55 B树删除操作4-2.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/56 B树删除操作4-3.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/57 B树删除操作4-4.png" alt></p>
<p>第二种情况</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/58 B树删除操作5-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/59 B树删除操作5-2.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/60 B树删除操作5-3.png" alt></p>
<p>B+树</p>
<p>B+树是B树的变形树，适合用于文件索引系统</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/61 B+树.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/62 B+树与B树区别.png" alt></p>
<h5 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h5><p>散列表基本概念</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/63 散列表基本概念.png" alt></p>
<p>散列函数和冲突处理方法</p>
<p>常用Hash函数的构造方法</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/64 散列表Hash函数构造方法.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/65 散列表Hash函数构造方法2.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/66 散列表Hash函数构造方法3.png" alt></p>
<p>常用Hash函数的冲突处理方法</p>
<p>开放地址法</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/67 散列表冲突处理.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/68 散列表冲突处理2.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/69 散列表冲突处理3.png" alt></p>
<p>拉链法(链地址法)</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/70 散列表冲突处理4.png" alt></p>
<p>散列表的查找过程和性能</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/71 散列表查找过程和性能.png" alt></p>
<p>散列表实例</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/72 散列表实例.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/73 散列表实例2.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/74 散列表实例3.png" alt></p>
<p>ASL计算方式：查找成功ASL看关键字，查找失败ASL看地址个数</p>
<p>开放地址法(线性探测再散列法)计算ASL：<a href="https://blog.csdn.net/wangran51/article/details/8826633/" target="_blank" rel="noopener">https://blog.csdn.net/wangran51/article/details/8826633/</a></p>
<h5 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h5><p>KMP算法是用于解决字符串模式匹配的问题，字符串的模式匹配，是求一个字符串（模式串）在另一个字符串（主串）中的位置</p>
<p>BF(Brute-Force)算法</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/75 字符串模式匹配.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/76 BF算法代码.png" alt></p>
<p>BF算法效率O(n*m)</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/77 BF算法效率.png" alt></p>
<p>KMP算法</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/78 KMP算法.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/79 KMP算法2.png" alt></p>
<p>KMP算法next数组</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/80 KMP算法next数组.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/81 KMP算法next数组代码.png" alt></p>
<p>next例子情况</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/82 KMP算法next数组例子.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/83 KMP算法next数组例子2.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/84 KMP算法next数组例子3.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/85 KMP算法next数组例子4.png" alt></p>
<p>当P[k] == P[j]时，</p>
<p>有next[j+1] == next[j] + 1</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/86 next数组例子5.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/87 next数组例子6.png" alt></p>
<p>当P[k] != P[j]</p>
<p>像上边的例子，我们已经不可能找到[ A，B，A，B ]这个最长的后缀串了，但我们还是可能找到[ A，B ]、[ B ]这样的前缀串的。所以这个过程像不像在定位[ A，B，A，C ]这个串，当C和主串不一样了（也就是k位置不一样了），那当然是把指针移动到next[k]啦。</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/88 next数组例子7.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/89 next数组例子8.png" alt></p>
<p>KMP算法代码</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/90 KMP算法代码.png" alt></p>
<p>KMP算法效率</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/91 KMP算法效率.png" alt></p>
<p>手动求解next数组的值</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/92 KMP算法手动next数组1.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/93 KMP算法手动next数组2.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/数据结构/5 图/图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/数据结构/5 图/图/" class="post-title-link" itemprop="url">图</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 22:22:43" itemprop="dateModified" datetime="2019-10-06T22:22:43+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T22:22:43+08:00" content="2019-10-06">
                2019-10-06 22:22:43
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/数据结构/5 图/图/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/数据结构/5 图/图/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>图G由顶点集V和边集E组成，记为G=(V,E)</p>
<p><img src="/2019/05/26/数据结构/5 图/图/1 图的概念1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/2 图的概念2.png" alt></p>
<h6 id="简单图和多重图"><a href="#简单图和多重图" class="headerlink" title="简单图和多重图"></a>简单图和多重图</h6><p>简单图</p>
<ul>
<li>不存在顶点到自身的边</li>
<li>同一条边不重复出现</li>
</ul>
<p>多重图</p>
<p>若图G中某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联</p>
<p><img src="/2019/05/26/数据结构/5 图/图/3 简单图和多重图.png" alt></p>
<h6 id="完全图"><a href="#完全图" class="headerlink" title="完全图"></a>完全图</h6><p>无向完全图：如果任意两个顶点之间都存在边</p>
<p>有向完全图：如果任意两个顶点之间都存在方向相反的两条弧</p>
<p><img src="/2019/05/26/数据结构/5 图/图/4 完全图.png" alt></p>
<h6 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h6><p><img src="/2019/05/26/数据结构/5 图/图/5 子图.png" alt></p>
<h6 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h6><p><img src="/2019/05/26/数据结构/5 图/图/6 连通图.png" alt></p>
<p>强连通</p>
<p><img src="/2019/05/26/数据结构/5 图/图/7 强连通分量.png" alt></p>
<h6 id="连通图的生成树"><a href="#连通图的生成树" class="headerlink" title="连通图的生成树"></a>连通图的生成树</h6><p><img src="/2019/05/26/数据结构/5 图/图/8 连通图生成树.png" alt></p>
<h6 id="度"><a href="#度" class="headerlink" title="度"></a>度</h6><p><img src="/2019/05/26/数据结构/5 图/图/9 度.png" alt></p>
<h6 id="权和网"><a href="#权和网" class="headerlink" title="权和网"></a>权和网</h6><p><img src="/2019/05/26/数据结构/5 图/图/10 权和网.png" alt></p>
<h6 id="基本概念总结"><a href="#基本概念总结" class="headerlink" title="基本概念总结"></a>基本概念总结</h6><p><img src="/2019/05/26/数据结构/5 图/图/11 基本概念总结.png" alt></p>
<h5 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h5><ul>
<li>邻接矩阵(顺序存储)</li>
<li>邻接表(链式存储)<ul>
<li>十字链表(有向图)</li>
<li>邻接多重表(无向图)</li>
</ul>
</li>
</ul>
<h6 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h6><p>顶点：用一维数组来存储</p>
<p>边或弧：用二维数组来存储</p>
<p>二维数组就是一维数组的扩展，相当于一维数组中每个元素也是一维数组，二维数组也叫做邻接矩阵</p>
<p>无向图的邻接矩阵</p>
<p><img src="/2019/05/26/数据结构/5 图/图/12 无向图邻接矩阵.png" alt></p>
<p>有向图的邻接矩阵</p>
<p><img src="/2019/05/26/数据结构/5 图/图/13 有向图邻接矩阵.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/14 矩阵数据结构.png" alt></p>
<h6 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h6><p>对于稀疏图(E远小于V)，顺序存储结构存在预先分配内存可能浪费的问题</p>
<p>无向图邻接表</p>
<p><img src="/2019/05/26/数据结构/5 图/图/15 无向图邻接表.png" alt></p>
<p>有向图邻接表</p>
<p><img src="/2019/05/26/数据结构/5 图/图/16 有向图邻接表.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/17 邻接表问题.png" alt></p>
<h6 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h6><p>十字链表是针对有向图的存储方式，对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点</p>
<p><img src="/2019/05/26/数据结构/5 图/图/18 十字链表.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/19 十字链表实例.png" alt></p>
<p>十字链表数据结构</p>
<p><img src="/2019/05/26/数据结构/5 图/图/20 十字链表结构.png" alt></p>
<h6 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h6><p><img src="/2019/05/26/数据结构/5 图/图/21 设计邻接多重表.png" alt></p>
<p>边表结构</p>
<p><img src="/2019/05/26/数据结构/5 图/图/22 边表结构.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/23 邻接多重表实例.png" alt></p>
<h5 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h5><p>图的遍历：从图中某一个顶点出发遍历图中其余的顶点，且使每一个顶点仅访问一次，这个过程叫做图的遍历</p>
<p>图中顶点没有特殊性，可能存在沿着某条路径搜索后回到原起点，而有些顶点没有访问到。</p>
<p>解决办法：设置一个访问数组，记录遍历过程中访问过的顶点。</p>
<h6 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历(BFS)"></a>广度优先遍历(BFS)</h6><p><img src="/2019/05/26/数据结构/5 图/图/24 广度优先遍历.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/25 广度优先代码.png" alt></p>
<p>BFS算法实例</p>
<p><img src="/2019/05/26/数据结构/5 图/图/26 广度优先遍历实例.png" alt></p>
<p>BFS空间复杂度</p>
<p>BFS需要借助一个队列，n个顶点均需要入队一次，所以最坏情况下n个顶点在队列，那么则需要O(|V|)的空间复杂度</p>
<p>BFS时间复杂度</p>
<ol>
<li>邻接表：每个顶点入队一次，时间复杂度为O(|V|)，对于每个顶点，搜索它的邻接点，就需要访问这个顶点的所有边，所以时间复杂度为O(|E|)。所以总的时间复杂度为<strong>O(|V|+|E|)</strong>。</li>
<li>邻接矩阵：每个顶点入队一次，时间复杂度为O(|V|)，对于每个顶点，搜索它的邻接点，需要遍历一遍矩阵，所以时间复杂度为O(|V|)，所以总的时间复杂度为<strong>O(|V|<sup>2</sup>)</strong>。</li>
</ol>
<p>BFS应用</p>
<p>BFS解决单源非带权图最短路径问题：按照距离由近到远来遍历图中每个顶点</p>
<p><img src="/2019/05/26/数据结构/5 图/图/27 广度优先应用.png" alt></p>
<p>广度优先生成树</p>
<p><img src="/2019/05/26/数据结构/5 图/图/28 广度优先生成树.png" alt></p>
<h6 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历(DFS)"></a>深度优先遍历(DFS)</h6><p>深度优先遍历（DFS：Depth-First-Serch）：深度优先遍历类似于树的先序遍历算法</p>
<p>遍历过程：首先访问图中某一起始顶点v，然后由v出发，访问与v邻接且未被访问的任一顶点w1，再访问与w1邻接且未被访问的任一顶点w2，。。。。重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直到图中所有顶点均被访问过为止。</p>
<p><img src="/2019/05/26/数据结构/5 图/图/29 深度优先遍历过程.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/30 深度优先遍历代码.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/31 深度优先遍历实例.png" alt></p>
<p>深度优先复杂度</p>
<p>空间复杂度：</p>
<p>由于DFS是一个递归算法，递归是一个需要工作栈来辅助工作，最多需要图中所有顶点进栈，所以空间复杂度为O(|V|)</p>
<p>时间复杂度：</p>
<ol>
<li>邻接表：遍历过程的主要操作是对顶点遍历它的邻接点，由于通过访问边表来查找邻接点，所以时间复杂度为O(|E|)，访问访问顶点时间为O(|V|)，所以总的时间复杂度为<strong>O(|V|+|E|)</strong>。</li>
<li>邻接矩阵：查找每个顶点的邻接点时间复杂度为O(|V|)，对每个顶点都进行查找，所以总的时间复杂度<strong>O(|V|<sup>2</sup>)</strong>。</li>
</ol>
<p>深度优先生成树</p>
<p><img src="/2019/05/26/数据结构/5 图/图/32 深度优先生成树.png" alt></p>
<h5 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h5><h6 id="最小生成树-Prim、Kruskal"><a href="#最小生成树-Prim、Kruskal" class="headerlink" title="最小生成树(Prim、Kruskal)"></a>最小生成树(Prim、Kruskal)</h6><p>连通图的生成树，是一个极小的连通子图。包含图中全部的顶点，但只有足以构成一棵树的n-1条边</p>
<p><img src="/2019/05/26/数据结构/5 图/图/33 生成树不唯一.png" alt></p>
<ul>
<li>普里姆(Prim)算法</li>
<li>克鲁斯卡尔(Kruskal)算法</li>
</ul>
<p>普里姆算法</p>
<p><img src="/2019/05/26/数据结构/5 图/图/34 普利姆算法思路.png" alt></p>
<p>初始化</p>
<p><img src="/2019/05/26/数据结构/5 图/图/35 普利姆算法代码0.png" alt></p>
<p>i=1</p>
<p><img src="/2019/05/26/数据结构/5 图/图/35 普利姆算法代码1.png" alt></p>
<p>i=2</p>
<p><img src="/2019/05/26/数据结构/5 图/图/36 普利姆算法代码2-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/37 普利姆算法代码2-2.png" alt></p>
<p>i=3</p>
<p><img src="/2019/05/26/数据结构/5 图/图/38 普利姆算法代码3-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/39 普利姆算法代码3-2.png" alt></p>
<p>i=4</p>
<p><img src="/2019/05/26/数据结构/5 图/图/40 普利姆算法代码4-1.png" alt></p>
<p>i=5</p>
<p><img src="/2019/05/26/数据结构/5 图/图/41 普利姆算法代码5.png" alt></p>
<p>i=6</p>
<p><img src="/2019/05/26/数据结构/5 图/图/42 普利姆算法代码6.png" alt></p>
<p>Prim算法时间复杂度</p>
<p><img src="/2019/05/26/数据结构/5 图/图/43 普利姆算法复杂度.png" alt></p>
<p>克鲁斯卡尔算法(Kruskal)</p>
<p><img src="/2019/05/26/数据结构/5 图/图/44 克鲁斯卡尔算法思路.png" alt></p>
<p>并查集</p>
<p><img src="/2019/05/26/数据结构/5 图/图/45 并查集.png" alt></p>
<p>算法思路</p>
<p>初始化，将边权值进行排序</p>
<p><img src="/2019/05/26/数据结构/5 图/图/46 克鲁斯算法代码初始化.png" alt></p>
<p>第一次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/47 克鲁斯算法过程1-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/48 克鲁斯算法过程1-2.png" alt></p>
<p>第二次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/49 克鲁斯算法过程2-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/50 克鲁斯算法过程2-2.png" alt></p>
<p>第三次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/51 克鲁斯算法过程3-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/52 克鲁斯算法过程3-2.png" alt></p>
<p>第四次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/53 克鲁斯算法过程4-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/54 克鲁斯算法过程4-2.png" alt></p>
<p>第五次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/55 克鲁斯算法过程5.png" alt></p>
<p>第六次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/56 克鲁斯算法过程6-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/57 克鲁斯算法过程6-2.png" alt></p>
<p>第七次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/58 克鲁斯算法过程7-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/59 克鲁斯算法过程7-2.png" alt></p>
<p>4-6之后的边循环都不进行操作了，已经形成六条边(n-1)，形成最小生成树</p>
<p>克鲁斯卡尔算法复杂度</p>
<p><img src="/2019/05/26/数据结构/5 图/图/60 克鲁斯算法复杂度.png" alt></p>
<h6 id="最短路径-Dijkstra、floyd"><a href="#最短路径-Dijkstra、floyd" class="headerlink" title="最短路径(Dijkstra、floyd)"></a>最短路径(Dijkstra、floyd)</h6><p><img src="/2019/05/26/数据结构/5 图/图/61 最短路径.png" alt></p>
<ul>
<li>迪杰斯特拉算法：一个源点到其余顶点的最短路径</li>
<li>弗洛伊德算法：所有顶点到所有顶点的最短路径</li>
</ul>
<p>迪杰斯特拉算法思路：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/62 迪杰斯特拉算法思路.png" alt></p>
<p>迪杰斯特拉算法实例</p>
<p>第一次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/63 迪杰斯特拉算法实例1-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/64 迪杰斯特拉算法实例1-2.png" alt></p>
<p>第二次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/65 迪杰斯特拉算法实例2.png" alt></p>
<p>第三次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/66 迪杰斯特拉算法实例3.png" alt></p>
<p>第四次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/67 迪杰斯特拉算法实例4.png" alt></p>
<p>第五次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/68 迪杰斯特拉算法实例5.png" alt></p>
<p>迪杰斯特拉算法代码</p>
<p><img src="/2019/05/26/数据结构/5 图/图/69 迪杰斯特拉算法代码1-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/70 迪杰斯特拉算法代码1-2.png" alt></p>
<p>迪杰斯特拉复杂度</p>
<p><img src="/2019/05/26/数据结构/5 图/图/71 迪杰斯特拉算法复杂度.png" alt></p>
<p>弗洛伊德算法</p>
<p>弗洛伊德算法是求图中任意一对顶点间的最短路径的算法</p>
<p>算法思想：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/72 佛洛依德算法思路.png" alt></p>
<p>佛洛依德算法实例</p>
<p>初始化</p>
<p><img src="/2019/05/26/数据结构/5 图/图/73 佛洛依德算法实例初始化.png" alt></p>
<p>第一次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/74 佛洛依德算法实例1.png" alt></p>
<p>第二次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/75 弗洛依德算法实例2.png" alt></p>
<p>第三次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/76 弗洛依德算法实例3.png" alt></p>
<p>第四次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/77 弗洛依德算法实例4.png" alt></p>
<p>弗洛伊德算法代码和复杂度</p>
<p><img src="/2019/05/26/数据结构/5 图/图/78 弗洛依德算法实例5.png" alt></p>
<h6 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h6><p>AOV网</p>
<p><img src="/2019/05/26/数据结构/5 图/图/79 AOV网.png" alt></p>
<p>拓扑排序算法思路</p>
<p><img src="/2019/05/26/数据结构/5 图/图/80 拓扑排序算法思路.png" alt></p>
<p>第一轮：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/81 拓扑排序算法过程1.png" alt></p>
<p>第二轮：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/82 拓扑排序算法过程2.png" alt></p>
<p>第三轮：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/83 拓扑排序算法过程3.png" alt></p>
<p>第四轮：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/84 拓扑排序算法过程4.png" alt></p>
<p>第五轮：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/85 拓扑排序算法过程5.png" alt></p>
<p>第六轮：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/86 拓扑排序算法过程6.png" alt></p>
<p>第七轮：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/87 拓扑排序算法过程7.png" alt></p>
<p>拓扑排序算法代码</p>
<p><img src="/2019/05/26/数据结构/5 图/图/88 拓扑排序算法代码.png" alt></p>
<p>拓扑排序算法复杂度</p>
<p><img src="/2019/05/26/数据结构/5 图/图/89 拓扑排序算法复杂度.png" alt></p>
<p>拓扑排序规律</p>
<p><img src="/2019/05/26/数据结构/5 图/图/90 拓扑排序算法规律.png" alt></p>
<h6 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h6><p>AOE网</p>
<p><img src="/2019/05/26/数据结构/5 图/图/91 AOE网.png" alt></p>
<p>关键路径</p>
<p><img src="/2019/05/26/数据结构/5 图/图/92 关键路径.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/93 关键路径规律.png" alt></p>
<p>寻找关键路径步骤</p>
<p><img src="/2019/05/26/数据结构/5 图/图/94 关键路径步骤1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/95 关键路径步骤2.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/96 关键路径步骤3.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/java集合类/集合类之List/集合类之List/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/java集合类/集合类之List/集合类之List/" class="post-title-link" itemprop="url">集合类之List</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 23:54:22" itemprop="dateModified" datetime="2019-10-06T23:54:22+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T23:54:22+08:00" content="2019-10-06">
                2019-10-06 23:54:22
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/集合框架/" itemprop="url" rel="index"><span itemprop="name">集合框架</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/java集合类/集合类之List/集合类之List/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/java集合类/集合类之List/集合类之List/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="集合类之List"><a href="#集合类之List" class="headerlink" title="集合类之List"></a>集合类之List</h1><p>List接口扩展自Collection，定义一个允许重复的有序集合，从List接口中的方法来看，List接口主要是增加了面向位置的操作，允许在指定位置上操作元素，同时增加了一个能够双向遍历线性表的新列表迭代器ListIterator。List接口的两个重要的具体实现类，也是我们可能最常用的类，ArrayList和LinkedList。</p>
<p><img src="/2019/05/26/java集合类/集合类之List/集合类之List/集合框架体系图.jpg" alt="集合框架体系图"></p>
<h3 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1.ArrayList"></a>1.ArrayList</h3><p>它是用数组存储元素的，这个数组可以动态创建，如果元素个数超过了数组的容量，那么就创建一个更大的新数组（通过移位运算符&gt;&gt;1扩大1倍再加上自己原本的容量即扩充1.5倍），并将当前数组中的所有元素都复制到新数组中。假设第一次是集合没有任何元素，下面以插入一个元素为例看看源码的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、找到add()实现方法。</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="number">2</span>、此方法主要是确定将要创建的数组大小。</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<span class="comment">//取出两个较大的容量</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;<span class="comment">//记录了结构性改变的次数。结构性改变指的是那些修改了列表大小的操作，在迭代过程中可能会造成错误的结果。</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="number">3</span>、最后是创建数组，可以明显的看到先是确定了添加元素后的大小之后将元素复制到新数组中。</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//1.5倍扩容</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList遍历三种方法</p>
<p>1、通过迭代器Iterator()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator iter = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(iter.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、随机访问，通过索引值去遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = list.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) </span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(list.get(i));        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、for循环遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String str:list)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">　　 &#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList常见问题</p>
<p>1、ArrayList如何实现自动增加</p>
<p>当试图在arraylist中增加一个对象的时候，Java会去检查arraylist，以确保已存在的数组中有足够的容量来存储这个新的对象。如果没有足够容量的话，那么就会新建一个长度更长的数组，旧的数组就会使用Arrays.copyOf方法被复制到新的数组中去，现有的数组引用指向了新的数组。</p>
<p>2、当传递ArrayList到某个方法中，或者某个方法返回ArrayList，什么时候要考虑安全隐患？如何修复安全违规这个问题呢？</p>
<p>当array被当做参数传递到某个方法中，如果array在没有被复制的情况下直接被分配给了成员变量，那么就可能发生这种情况，即当原始的数组被调用的方法改变的时候，传递到这个方法中的数组也会改变。</p>
<p><img src="/2019/05/26/java集合类/集合类之List/集合类之List/arrayList安全隐患.png" alt="arrayList安全隐患"></p>
<p>3、什么情况下你会使用ArrayList？什么时候你会选择LinkedList？</p>
<p>多数情况下，当你遇到访问元素比插入或者是删除元素更加频繁的时候，你应该使用ArrayList。另外一方面，当你在某个特别的索引中，插入或者是删除元素更加频繁，或者你根本就不需要访问元素的时候，你会选择LinkedList。这里的主要原因是，在ArrayList中访问元素的最糟糕的时间复杂度是”1″，而在LinkedList中可能就是”n”了。在ArrayList中增加或者删除某个元素，通常会调用System.arraycopy方法，这是一种极为消耗资源的操作，因此，在频繁的插入或者是删除元素的情况下，LinkedList的性能会更加好一点。</p>
<p>System.arraycopy方法消耗资源原因：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</span><br><span class="line">代码解释:</span><br><span class="line">　　Object src : 原数组</span><br><span class="line">   int srcPos : 从元数据的起始位置开始</span><br><span class="line">　　Object dest : 目标数组</span><br><span class="line">　　int destPos : 目标数组的开始起始位置</span><br><span class="line">　　int length  : 要copy的数组的长度</span><br><span class="line"></span><br><span class="line">我们使用System.arraycopy进行转换(copy)</span><br><span class="line"></span><br><span class="line">System.arrayCopy(srcBytes,0,destBytes ,0,5)</span><br><span class="line">上面这段代码就是 : 创建一个一维空数组,数组的总长度为 12位,然后将srcBytes源数组中 从0位 到 第5位之间的数值 copy 到 destBytes目标数组中,在目标数组的第0位开始放置.</span><br><span class="line">那么这行代码的运行效果应该是 2,4,0,0,0,</span><br><span class="line"></span><br><span class="line">增加或者删除都要进行一次copy，消耗资源多。</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/java集合类/集合类之List/集合类之List/arraylist增加.jpg" alt="arraylist增加"></p>
<p><img src="/2019/05/26/java集合类/集合类之List/集合类之List/arraylist删除.jpg" alt="arraylist删除"></p>
<p>4、如何复制某个ArrayList到另一个ArrayList中去？写出你的代码？</p>
<p>下面就是把某个ArrayList复制到另一个ArrayList中去的几种技术：</p>
<ol>
<li>使用clone()方法，比如ArrayList newArray = oldArray.clone();</li>
<li>使用ArrayList构造方法，比如：ArrayList myObject = new ArrayList(myTempObject);</li>
<li>使用Collection的copy方法。</li>
</ol>
<p>注意1和2是浅拷贝(shallow copy)。</p>
<p>浅拷贝和深拷贝区别：</p>
<p>| 浅拷贝：只复制引用，另一处修改，你当下的对象也会修改。         </p>
<p>| 深拷贝：引用对象的值等信息，复制一份一样的。</p>
<p>浅拷贝—能复制变量，如果对象内还有对象，则只能复制对象的地址（指针指向同一个内存空间）</p>
<p>深拷贝—能复制变量，也能复制当前对象的内部对象</p>
<p>利用序列化实现深拷贝</p>
<p>把对象写到流里的过程是序列化过程（Serialization），而把对象从流中读出来的过程则叫做反序列化过程（Deserialization）。</p>
<p>在Java语言里深复制一个对象，常常可以先使对象实现Serializable接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。</p>
<h3 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2.LinkedList"></a>2.LinkedList</h3><p><img src="/2019/05/26/java集合类/集合类之List/集合类之List/LinkedList结构图.png" alt="LinkedList结构图"></p>
<p>1、继承了AbstractSequentialList抽象类：在遍历LinkedList的时候，官方更推荐使用顺序访问，也就是使用我们的迭代器。（因为LinkedList底层是通过一个双向链表来实现的）（虽然LinkedList也提供了get（int index）方法，但是底层的实现是：每次调用get（int index）方法的时候，都需要从链表的头部或者尾部进行遍历，每一的遍历时间复杂度是O(index)，而相对比ArrayList的底层实现，每次遍历的时间复杂度都是O(1)。所以不推荐通过get（int index）遍历LinkedList。</p>
<p>至于上面的说从链表的头部后尾部进行遍历：官方源码对遍历进行了优化：通过判断索引index更靠近链表的头部还是尾部来选择遍历的方向）（所以这里遍历LinkedList推荐使用迭代器）。</p>
<p>2、实现了List接口。（提供List接口中所有方法的实现）<br>实现了Cloneable接口，它支持克隆（浅克隆），底层实现：LinkedList节点并没有被克隆，只是通过Object的clone（）方法得到的Object对象强制转化为了LinkedList,然后把它内部的实例域都置空，然后把被拷贝的LinkedList节点中的每一个值都拷贝到clone中。</p>
<p>3、实现了Deque接口。实现了Deque所有的可选的操作。</p>
<p>4、实现了Serializable接口。表明它支持序列化。（和ArrayList一样，底层都提供了两个方法：readObject（ObjectInputStream o）、writeObject（ObjectOutputStream o），用于实现序列化，底层只序列化节点的个数和节点的值）</p>
<p>底层重要方法分析：</p>
<p><strong>addAll(int index, Collection）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先调用一下空的构造器。</span></span><br><span class="line"><span class="comment">//然后调用addAll(c)方法。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过调用addAll(int index, Collection&lt;? extends E&gt; c) 完成集合的添加。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//几乎所有的涉及到在指定位置添加或者删除或修改操作都需要判断传进来的参数是否合法。</span></span><br><span class="line"><span class="comment">// checkPositionIndex(index)方法就起这个作用。  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"><span class="comment">//先把集合转化为数组，然后为该数组添加一个新的引用（Objext[] a）。</span></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line"><span class="comment">//新建一个变量存储数组的长度。</span></span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line"><span class="comment">//如果待添加的集合为空，直接返回，无需进行后面的步骤。后面都是用来把集合中的元素添加到</span></span><br><span class="line"><span class="comment">//LinkedList中。</span></span><br><span class="line">        <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//Node&lt;E&gt; succ：指代待添加节点的位置。</span></span><br><span class="line"><span class="comment">//Node&lt;E&gt; pred：指代待添加节点的前一个节点。</span></span><br><span class="line"><span class="comment">//下面的代码是依据新添加的元素的位置分为两个分支：</span></span><br><span class="line"><span class="comment">//①新添加的元素的位置位于LinkedList最后一个元素的后面。</span></span><br><span class="line"><span class="comment">//新添加的元素的位置位于LinkedList中。</span></span><br><span class="line"><span class="comment">//如果index==size;说明此时需要添加LinkedList中的集合中的每一个元素都是在LinkedList</span></span><br><span class="line"><span class="comment">//最后面。所以把succ设置为空，pred指向尾节点。</span></span><br><span class="line"><span class="comment">//否则的话succ指向插入待插入位置的节点。这里用到了node（int index）方法，这个方法</span></span><br><span class="line"><span class="comment">//后面会详细分析，这里只需要知道该方法返回对应索引位置上的Node（节点）。pred指向succ节点的前一个节点。</span></span><br><span class="line">        Node&lt;E&gt; pred, succ;</span><br><span class="line">        <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">            succ = <span class="keyword">null</span>;</span><br><span class="line">            pred = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            succ = node(index);</span><br><span class="line">            pred = succ.prev;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//接着遍历数组中的每个元素。在每次遍历的时候，都新建一个节点，该节点的值存储数组a中遍历</span></span><br><span class="line"><span class="comment">//的值，该节点的prev用来存储pred节点，next设置为空。接着判断一下该节点的前一个节点是否为</span></span><br><span class="line"><span class="comment">//空，如果为空的话，则把当前节点设置为头节点。否则的话就把当前节点的前一个节点的next值</span></span><br><span class="line"><span class="comment">//设置为当前节点。最后把pred指向当前节点，以便后续新节点的添加。</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">            Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                first = newNode;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = newNode;</span><br><span class="line">            pred = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//这里仍然和上面一样，分两种情况对待：</span></span><br><span class="line"><span class="comment">//①当succ==null（也就是新添加的节点位于LinkedList集合的最后一个元素的后面），</span></span><br><span class="line"><span class="comment">//通过遍历上面的a的所有元素，此时pred指向的是LinkedList中的最后一个元素，所以把</span></span><br><span class="line"><span class="comment">//last指向pred指向的节点。</span></span><br><span class="line"><span class="comment">//当不为空的时候，表明在LinkedList集合中添加的元素，需要把pred的next指向succ上，</span></span><br><span class="line"><span class="comment">//succ的prev指向pred。</span></span><br><span class="line"><span class="comment">//最后把集合的大小设置为新的大小。</span></span><br><span class="line"><span class="comment">//modCount（修改的次数）自增。</span></span><br><span class="line">        <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = pred;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pred.next = succ;</span><br><span class="line">            succ.prev = pred;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size += numNew;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>虽然是增加一个集合的元素，但是modCount只增加了一次</p>
<p><strong>将LinkedList写入到流中。（也就是把LinkedList状态保存到流中）（序列化）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Write out any hidden serialization magic</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        s.writeObject(x.item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>从流中把LinkedList读取出来（读取流，拼装成LinkedList）（反序列化）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// Read in any hidden serialization magic</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size</span></span><br><span class="line">    <span class="keyword">int</span> size = s.readInt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        linkLast((E)s.readObject());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>LinkedList提供了两种迭代器，一种是返回Iterator，另一种返回ListIterator。</strong></p>
<p><strong>①返回ListIterator迭代器：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>②返回Iterator迭代器：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DescendingIterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/数据结构/7 排序/排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/数据结构/7 排序/排序/" class="post-title-link" itemprop="url">排序</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-23 14:04:58" itemprop="dateModified" datetime="2019-10-23T14:04:58+08:00">2019-10-23</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-23T14:04:58+08:00" content="2019-10-23">
                2019-10-23 14:04:58
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/数据结构/7 排序/排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/数据结构/7 排序/排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>排序就是将原本无序的序列重新排列成有序的序列</p>
<p>排序的稳定性</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/1 排序稳定性.png" alt></p>
<p>内部排序：指的是待排序记录全部存放在计算机内存中进行排序的过程</p>
<p>外部排序：指的是待排序的记录的数量很大，以致内存一次不能容纳全部记录，在排序过程中尚需要对外存进行访问的排序过程</p>
<p>内部排序分类</p>
<ul>
<li>插入类：将无序子序列中的一个或几个记录插入到有序序列中，从而增加记录的有序子序列的长度，包括直接插入排序、折半插入排序、希尔排序</li>
<li>交换类：通过交换无序序列中的记录从而得到其中关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度，包括冒泡排序和快速排序</li>
<li>选择类：从记录的无序子序列中选择关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加有序子序列的长度，包括简单选择排序、树形选择排序、堆排序</li>
<li><p>归并类：通过归并两个或两个以上的记录有序子序列，逐步增加记录有序序列的长度，包括2路归并排序</p>
</li>
<li><p>分配类：是唯一一类不需要关键字之间的比较的排序方法，排序时主要利用分配和收集两种基本操作完成。基数排序是主要的分配类排序</p>
</li>
</ul>
<h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><h6 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h6><p><img src="/2019/05/26/数据结构/7 排序/排序/2 直接插入排序代码.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 插入排序;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接插入排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入需要排序的数字"</span>);</span><br><span class="line">		System.out.println(<span class="string">"01 02 03 04 05 06 07 08 09 10"</span>);</span><br><span class="line">		<span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>];</span><br><span class="line">		<span class="keyword">while</span>(i&lt;<span class="number">11</span>) &#123;</span><br><span class="line">			array[i] = sc.nextInt();</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		InsertSort(array);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>;a&lt;<span class="number">11</span>;a++)</span><br><span class="line">			System.out.print(array[a]+<span class="string">","</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> array[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i,j;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;array.length;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(array[i]&lt;array[i-<span class="number">1</span>]) &#123;</span><br><span class="line">				array[<span class="number">0</span>]=array[i];</span><br><span class="line">				<span class="keyword">for</span>(j=i-<span class="number">1</span>;array[j]&gt;array[<span class="number">0</span>];j--) &#123;</span><br><span class="line">					array[j+<span class="number">1</span>] = array[j];</span><br><span class="line">				&#125;</span><br><span class="line">				array[j+<span class="number">1</span>] = array[<span class="number">0</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空间时间复杂度</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/3 直接插入排序时间复杂度.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/4 直接插入排序时间复杂度2.png" alt></p>
<p>时间复杂度最好O(n)，最坏O(n<sup>2</sup>)</p>
<p>直接插入排序是<strong>稳定</strong>的</p>
<h6 id="折半查找排序"><a href="#折半查找排序" class="headerlink" title="折半查找排序"></a>折半查找排序</h6><p><img src="/2019/05/26/数据结构/7 排序/排序/5 折半插入排序.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/6 折半插入排序例子.png" alt></p>
<p>折半排序代码</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/7 折半插入排序代码.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 插入排序;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 	折半插入排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 11053</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryInsertSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入需要排序的数字"</span>);</span><br><span class="line">		System.out.println(<span class="string">"01 02 03 04 05 06 07 08 09 10"</span>);</span><br><span class="line">		<span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>];</span><br><span class="line">		<span class="keyword">while</span>(i&lt;<span class="number">11</span>) &#123;</span><br><span class="line">			array[i] = sc.nextInt();</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		BinaryInsertSort(array);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>;a&lt;<span class="number">11</span>;a++)</span><br><span class="line">			System.out.print(array[a]+<span class="string">","</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BinaryInsertSort</span><span class="params">(<span class="keyword">int</span> array[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i,j,mid,low,high;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;array.length;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(array[i]&lt;array[i-<span class="number">1</span>]) &#123;</span><br><span class="line">				array[<span class="number">0</span>] = array[i];</span><br><span class="line">				low = <span class="number">1</span>;</span><br><span class="line">				high = i-<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">while</span>(low&lt;=high) &#123;</span><br><span class="line">					mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">					<span class="keyword">if</span>(array[mid]&gt;array[<span class="number">0</span>]) high = mid-<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">else</span> low = mid+<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span>(j=i-<span class="number">1</span>;j&gt;=high+<span class="number">1</span>;j--)</span><br><span class="line">					array[j+<span class="number">1</span>] = array[j];</span><br><span class="line">				array[high+<span class="number">1</span>] = array[<span class="number">0</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/8 折半插入排序时间复杂度.png" alt></p>
<p>时间复杂度O(n<sup>2</sup>)</p>
<p>折半插入排序是<strong>稳定</strong>的</p>
<h6 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h6><p><img src="/2019/05/26/数据结构/7 排序/排序/9 希尔排序.png" alt></p>
<p>希尔排序过程</p>
<p>第一趟：10个元素取增量10/2=5</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/10 希尔排序第一趟.png" alt></p>
<p>第二趟：5/2向下取整=2</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/11 希尔排序第二趟.png" alt></p>
<p>第三趟：最后增量为1</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/12 希尔排序第三趟.png" alt></p>
<p>希尔排序的时间复杂度</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/13 希尔排序时间复杂度.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/14 希尔排序稳定性.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 插入排序;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  希尔排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 11053</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入需要排序的数字"</span>);</span><br><span class="line">		System.out.println(<span class="string">"01 02 03 04 05 06 07 08 09 10"</span>);</span><br><span class="line">		<span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>];</span><br><span class="line">		<span class="keyword">while</span>(i&lt;<span class="number">11</span>) &#123;</span><br><span class="line">			array[i] = sc.nextInt();</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		ShellSort(array);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>;a&lt;<span class="number">11</span>;a++)</span><br><span class="line">			System.out.print(array[a]+<span class="string">","</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> array[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> d,i,j;</span><br><span class="line">		<span class="keyword">for</span>(d=array.length/<span class="number">2</span>;d&gt;=<span class="number">1</span>;d=d/<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(i=d+<span class="number">1</span>;i&lt;=array.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(array[i]&lt;array[i-d]) &#123;</span><br><span class="line">					array[<span class="number">0</span>] = array[i];</span><br><span class="line">					<span class="keyword">for</span>(j=i-d;j&gt;<span class="number">0</span>&amp;&amp;array[j]&gt;array[<span class="number">0</span>];j-=d) &#123;</span><br><span class="line">						array[j+d] = array[j];</span><br><span class="line">					&#125;</span><br><span class="line">					array[j+d] = array[<span class="number">0</span>];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度最好<strong>O(n<sup>1.3</sup>)，最坏O(n<sup>2</sup>)</strong>.</p>
<p>希尔排序<strong>不稳定</strong></p>
<h5 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h5><p>交换类排序：根据序列中两个元素关键字的比较结果来交换它两在序列中的位置</p>
<h6 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h6><p><img src="/2019/05/26/数据结构/7 排序/排序/15 冒泡排序.png" alt></p>
<p>冒泡排序代码</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/16 冒泡排序代码.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 交换排序;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  冒泡排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 11053</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入需要排序的数字"</span>);</span><br><span class="line">		System.out.println(<span class="string">"01 02 03 04 05 06 07 08 09 10"</span>);</span><br><span class="line">		<span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>];</span><br><span class="line">		<span class="keyword">while</span>(i&lt;<span class="number">11</span>) &#123;</span><br><span class="line">			array[i] = sc.nextInt();</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		BubbleSort(array);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>;a&lt;<span class="number">11</span>;a++)</span><br><span class="line">			System.out.print(array[a]+<span class="string">","</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> array[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i,j,temp;</span><br><span class="line">		<span class="keyword">boolean</span> flag;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;array.length;i++) &#123;</span><br><span class="line">			flag=<span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">for</span>(j=array.length-<span class="number">1</span>;j&gt;i;j--) &#123;</span><br><span class="line">				<span class="keyword">if</span>(array[j-<span class="number">1</span>]&gt;array[j]) &#123;</span><br><span class="line">					temp = array[j];</span><br><span class="line">					array[j] = array[j-<span class="number">1</span>];</span><br><span class="line">					array[j-<span class="number">1</span>] = temp;</span><br><span class="line">					flag = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag==<span class="keyword">false</span>) <span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序时间复杂度<strong>最好O(n)，最坏O(n<sup>2</sup>)</strong>.</p>
<p>冒泡排序<strong>稳定</strong>.</p>
<h6 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h6><p>快速排序是一种基于分治法的排序方法</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/17 快速排序.png" alt></p>
<p>快速排序代码</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/18 快速排序代码1.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/19 快速排序代码2.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/20 快速排序最坏时间复杂度.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/21 快速排序最坏时间复杂度2.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/22 快速排序空间复杂度.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 交换排序;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 11053</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入需要排序的数字"</span>);</span><br><span class="line">		System.out.println(<span class="string">"01 02 03 04 05 06 07 08 09 10"</span>);</span><br><span class="line">		<span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>];</span><br><span class="line">		<span class="keyword">while</span>(i&lt;<span class="number">11</span>) &#123;</span><br><span class="line">			array[i] = sc.nextInt();</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		QuickSort(array,<span class="number">1</span>,array.length-<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>;a&lt;<span class="number">11</span>;a++)</span><br><span class="line">			System.out.print(array[a]+<span class="string">","</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(low&lt;high) &#123;</span><br><span class="line">			<span class="keyword">int</span> pivotloc = Partition(array,low,high);</span><br><span class="line">			QuickSort(array,low,pivotloc-<span class="number">1</span>);</span><br><span class="line">			QuickSort(array,pivotloc+<span class="number">1</span>,high);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> pivot = array[low];</span><br><span class="line">		<span class="keyword">while</span>(low&lt;high) &#123;</span><br><span class="line">			<span class="keyword">while</span>(low&lt;high&amp;&amp;array[high]&gt;=pivot) high--;</span><br><span class="line">			array[low] = array[high];</span><br><span class="line">			<span class="keyword">while</span>(low&lt;high&amp;&amp;array[low]&lt;=pivot) low++;</span><br><span class="line">			array[high] = array[low];</span><br><span class="line">		&#125;</span><br><span class="line">		array[low] = pivot;</span><br><span class="line">		<span class="keyword">return</span> low;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快速排序时间复杂度最好<strong>O(nlogn)，最坏O(n<sup>2</sup>)</strong>.</p>
<p>序列越乱序，效率越高；序列越有序，效率越低</p>
<p>空间复杂度最好<strong>O(logn)，最坏O(n)</strong>.</p>
<p>快速排序<strong>不稳定</strong>.</p>
<h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><p><img src="/2019/05/26/数据结构/7 排序/排序/23 选择排序.png" alt></p>
<h6 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h6><p><img src="/2019/05/26/数据结构/7 排序/排序/24 选择排序代码.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/25 选择排序稳定性.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 选择排序;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单选择排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入需要排序的数字"</span>);</span><br><span class="line">		System.out.println(<span class="string">"01 02 03 04 05 06 07 08 09 10"</span>);</span><br><span class="line">		<span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>];</span><br><span class="line">		<span class="keyword">while</span>(i&lt;<span class="number">11</span>) &#123;</span><br><span class="line">			array[i] = sc.nextInt();</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		SelectSort(array);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>;a&lt;<span class="number">11</span>;a++)</span><br><span class="line">			System.out.print(array[a]+<span class="string">","</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> array[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i,j,min;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;array.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">			min = i;</span><br><span class="line">			<span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;array.length;j++) </span><br><span class="line">				<span class="keyword">if</span>(array[min]&gt;array[j]) min = j;</span><br><span class="line">			<span class="keyword">if</span>(min!=i) &#123;</span><br><span class="line">				array[<span class="number">0</span>] = array[min];</span><br><span class="line">				array[min] = array[i];</span><br><span class="line">				array[i] = array[<span class="number">0</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单选择排序时间复杂度O(n<sup>2</sup>)</p>
<p>不稳定，交换会打破顺序</p>
<h6 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h6><p>堆的定义</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/26 堆排序.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/27 堆排序形成.png" alt></p>
<p>大顶堆过程</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/28 大顶堆排序1.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/29 大顶堆排序2.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/30 大顶堆排序3.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/31 大顶堆排序4.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/32 大顶堆排序5.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/33 大顶堆排序6.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/34 大顶堆排序7.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/35 大顶堆排序8.png" alt></p>
<p>堆排序算法</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/36 堆排序算法思路.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/37 堆排序算法.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/38 堆排序算法2.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/39 堆排序时间复杂度.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/40 堆排序时间复杂度2.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/41 堆排序时间复杂度3.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/42 堆排序时间复杂度4.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/43 堆排序时间复杂度5.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 选择排序;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入需要排序的数字"</span>);</span><br><span class="line">		System.out.println(<span class="string">"01 02 03 04 05 06 07 08 09 10"</span>);</span><br><span class="line">		<span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>];</span><br><span class="line">		<span class="keyword">while</span>(i&lt;<span class="number">11</span>) &#123;</span><br><span class="line">			array[i] = sc.nextInt();</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		HeadSort(array);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>;a&lt;<span class="number">11</span>;a++)</span><br><span class="line">			System.out.print(array[a]+<span class="string">","</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeadSort</span><span class="params">(<span class="keyword">int</span> array[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = array.length-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		BuildMaxHead(array, len);</span><br><span class="line">		<span class="keyword">for</span>(i=len;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">			Swap(array,<span class="number">1</span>,i);</span><br><span class="line">			HeadAjust(array,<span class="number">1</span>,i-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BuildMaxHead</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//len=10</span></span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i=len/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">			HeadAjust(array,i,len);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeadAjust</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> k,<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		array[<span class="number">0</span>] = array[k];</span><br><span class="line">		<span class="keyword">for</span>(i=k*<span class="number">2</span>;i&lt;=len;i=i*<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;len&amp;&amp;array[i]&lt;array[i+<span class="number">1</span>])</span><br><span class="line">				i++;</span><br><span class="line">			<span class="keyword">if</span>(array[i]&lt;array[<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				array[k] = array[i];</span><br><span class="line">				k=i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		array[k] = array[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> top,<span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">		array[<span class="number">0</span>] = array[top];</span><br><span class="line">		array[top] = array[bottom];</span><br><span class="line">		array[bottom] = array[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆排序时间复杂度<strong>O(nlog<sub>2</sub>n)，空间复杂度O(1)</strong>。</p>
<p>堆排序<strong>不稳定</strong>.</p>
<h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><p><img src="/2019/05/26/数据结构/7 排序/排序/44 归并排序.png" alt></p>
<p>归并排序代码</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/45 归并排序代码.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/46 归并排序代码2.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/47 归并排序时间复杂度.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/49 归并排序空间复杂度.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 归并排序;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  归并排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 11053</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入需要排序的数字"</span>);</span><br><span class="line">		System.out.println(<span class="string">"01 02 03 04 05 06 07 08 09 10"</span>);</span><br><span class="line">		<span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>];</span><br><span class="line">		<span class="keyword">while</span>(i&lt;<span class="number">11</span>) &#123;</span><br><span class="line">			array[i] = sc.nextInt();</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		MergeSort(array,<span class="number">1</span>,array.length-<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>;a&lt;<span class="number">11</span>;a++)</span><br><span class="line">			System.out.print(array[a]+<span class="string">","</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> mid;</span><br><span class="line">		<span class="keyword">if</span>(low&lt;high) &#123;</span><br><span class="line">			mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">			MergeSort(array,low,mid);</span><br><span class="line">			MergeSort(array,mid+<span class="number">1</span>,high);</span><br><span class="line">			Merge(array,low,mid,high);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i,j,k;</span><br><span class="line">		<span class="keyword">int</span> len = array.length;</span><br><span class="line">		<span class="keyword">int</span> temp[] = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">		<span class="keyword">for</span>(k=low;k&lt;=high;k++)</span><br><span class="line">			temp[k] = array[k];</span><br><span class="line">		<span class="keyword">for</span>(i=low,j=mid+<span class="number">1</span>,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(temp[i]&lt;temp[j])</span><br><span class="line">				array[k]=temp[i++];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				array[k]=temp[j++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;=mid) array[k++]=temp[i++];</span><br><span class="line">		<span class="keyword">while</span>(j&lt;=high) array[k++]=temp[j++];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(nlogn),空间复杂度O(n)</p>
<p>归并排序稳定</p>
<h5 id="非比较排序"><a href="#非比较排序" class="headerlink" title="非比较排序"></a>非比较排序</h5><h6 id="基数排序-桶排序"><a href="#基数排序-桶排序" class="headerlink" title="基数排序(桶排序)"></a>基数排序(桶排序)</h6><p><img src="/2019/05/26/数据结构/7 排序/排序/50 基数排序.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/51 基数排序1.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/52 基数排序2.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/53 基数排序3.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/54 基数排序4.png" alt></p>
<p>MSD</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/55 基数排序5.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/56 基数排序6.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/57 基数排序7.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/58 基数排序8.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/59 各排序算法复杂度总结.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/java集合类/集合类之MAP/集合类之MAP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/java集合类/集合类之MAP/集合类之MAP/" class="post-title-link" itemprop="url">集合类之MAP</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 23:55:21" itemprop="dateModified" datetime="2019-10-06T23:55:21+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T23:55:21+08:00" content="2019-10-06">
                2019-10-06 23:55:21
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/集合框架/" itemprop="url" rel="index"><span itemprop="name">集合框架</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/java集合类/集合类之MAP/集合类之MAP/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/java集合类/集合类之MAP/集合类之MAP/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="集合类之MAP"><a href="#集合类之MAP" class="headerlink" title="集合类之MAP"></a>集合类之MAP</h1><h3 id="map架构"><a href="#map架构" class="headerlink" title="map架构"></a>map架构</h3><p><img src="/2019/05/26/java集合类/集合类之MAP/集合类之MAP/map架构图.jpg" alt></p>
<p>如上图：<br>(1) Map 是<strong>映射接口</strong>，Map中存储的内容是<strong>键值对*</strong>(key-value)*。<br>(2) AbstractMap 是<strong>继承于Map的抽象类，它实现了Map中的大部分API</strong>。其它Map的实现类可以通过继承AbstractMap来减少重复编码。<br>(3) SortedMap 是继承于Map的接口。SortedMap中的内容是<strong>排序的键值对</strong>，排序的方法是通过比较器(Comparator)。<br>(4) NavigableMap 是继承于SortedMap的接口。相比于SortedMap，NavigableMap有一系列的导航方法；如”获取大于/等于某对象的键值对”、“获取小于/等于某对象的键值对”等等。<br>(5) TreeMap 继承于AbstractMap，且实现了NavigableMap接口；因此，TreeMap中的内容是“<strong>有序的键值对</strong>”！<br>(6) HashMap 继承于AbstractMap，但没实现NavigableMap接口；因此，HashMap的内容是“<strong>键值对，但不保证次序</strong>”！<br>(7) Hashtable 虽然不是继承于AbstractMap，但它继承于Dictionary(Dictionary也是键值对的接口)，而且也实现Map接口；因此，Hashtable的内容也是“<strong>键值对，也不保证次序</strong>”。但和HashMap相比，Hashtable是线程安全的，而且它支持通过Enumeration去遍历。<br>(8) WeakHashMap 继承于AbstractMap。它和HashMap的键类型不同，<strong>WeakHashMap的键是“弱键”</strong>。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>1、HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。</p>
<p>2、HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。</p>
<p>3、HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。</p>
<p>4、HashMap中的映射<strong>不是有序</strong>的。</p>
<p>HashMap 的实例有两个参数影响其性能：“<strong>初始容量</strong>” 和 “<strong>加载因子</strong>”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有<strong>大约两倍</strong>的桶数。<br>通常，<strong>默认加载因子是 0.75</strong>, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。</p>
<p><img src="/2019/05/26/java集合类/集合类之MAP/集合类之MAP/HashMap接口.jpg" alt="HashMap接口"></p>
<p>从图中可以看出：<br>(01) HashMap继承于AbstractMap类，实现了Map接口。Map是”key-value键值对”接口，AbstractMap实现了”键值对”的通用函数接口。<br>(02) HashMap是通过”拉链法”实现的哈希表。它包括几个重要的成员变量：table, size, threshold, loadFactor, modCount。<br>　　table是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。<br>　　size是HashMap的大小，它是HashMap保存的键值对的数量。<br>　　threshold是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值=”容量*加载因子”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。<br>　　loadFactor就是加载因子。<br>　　modCount是用来实现fail-fast机制的。</p>
<p>1、存储结构</p>
<ol>
<li><p>hashmap底层是以数组方式进行存储。将key-value对作为数组中的一个元素进行存储。</p>
</li>
<li><p>key-value都是Map.Entry中的属性。其中将key的值进行hash之后进行存储，即每一个key都是计算hash值，然后再存储。每一个Hash值对应一个数组下标，<strong>数组下标</strong>是根据<strong>hash值和数组长度</strong>计算得来。</p>
</li>
<li><p>由于不同的key有可能hash值相同，即该位置的数组中的元素出现两个，对于这种情况，hashmap采用链表形式进行存储。</p>
</li>
<li><p>下图描述了hashmap的存储结构图 </p>
<p><img src="/2019/05/26/java集合类/集合类之MAP/集合类之MAP/HashMap存储结构.png" alt="HashMap存储结构"></p>
</li>
</ol>
<p>Entry结构分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;<span class="comment">// map中key值，可以为null。</span></span><br><span class="line">        V value; <span class="comment">// map中的value值，可以为null。</span></span><br><span class="line">        Entry&lt;K,V&gt; next;<span class="comment">// 链表引用，防止key值不同，hash值相同。</span></span><br><span class="line">        <span class="keyword">int</span> hash; <span class="comment">// 每个key的hash值</span></span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">        Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同一个key时，新值替换旧值，返回旧值</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// key值重写equals方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry e = (Map.Entry)o;</span><br><span class="line">            Object k1 = getKey();</span><br><span class="line">            Object k2 = e.getKey();</span><br><span class="line">            <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">                Object v1 = getValue();</span><br><span class="line">                Object v2 = e.getValue();</span><br><span class="line">                <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 重写hashCode值</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 其他方法省略</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>HashMap属性分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *默认情况下，hashmap大小为16.即1&lt;&lt;4就是1乘以2的4次幂=16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * hashMap的最大值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认加载加载因子，即使用空间达到总空间的0.75时，需要扩容。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明hashmap一个空数组。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最开始时，hashmap是一个空数组。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * map的元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * hashmap的实际存储空间大小。这个空间是总空间*加载因子得出的大小。</span></span><br><span class="line"><span class="comment">     * 比如默认是16，加载因子是0.74。则threshold就是12。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载因子，即使用空间达到总空间的0.75时，需要扩容。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  threshold这个值的最大值就是Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;</span><br></pre></td></tr></table></figure>
<p>put方法</p>
<p>put（key,value）方法是hashmap中最重要的方法，使用hashmap最主要的就是使用put,get两个方法。可以从put方法的源码进行分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 首次存储元素，初始化存储空间</span></span><br><span class="line">       <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">           inflateTable(threshold);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果key为null，则将null放入元素的第一个位置</span></span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">       <span class="comment">// 计算key的hash值    </span></span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       <span class="comment">// 根据key的hash值，数组长度计算该Entry&lt;key,value&gt;的数组下标</span></span><br><span class="line">       <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">       **如果当前key的已经存在于map中，则将新值替换成旧值。</span></span><br><span class="line"><span class="comment">       **/</span></span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           <span class="comment">// 判断同一个key，既要判断hash值相同，还要判断key是同一个key，因为</span></span><br><span class="line">           <span class="comment">// 相同的key有可能hash值也相同。双重判断保证是同一个key。</span></span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               e.value = value;</span><br><span class="line">               e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="comment">// 如果是新的key需要存储，则增加操作次数modCount++</span></span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="comment">// 将新增key-value键值对添加中map中。</span></span><br><span class="line">       addEntry(hash, key, value, i);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>addEntry方法</p>
<ol>
<li>addEntry方法是将新增的key-value键值对存入到map中。该方法主要完成两个功能：<br>1.1. 添加新元素前， 判断是否需要对map的数组进行扩容，如果需要扩容，则扩容空间大小是原来的两倍<br>1.2. 对于新增key-value键值对，如果key的hash值相同，则构造单向列表。</li>
<li>从源码分析结果如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">**  hash:key的hash值</span></span><br><span class="line"><span class="comment">**  key:存储的键</span></span><br><span class="line"><span class="comment">**  value：存储的value对象值</span></span><br><span class="line"><span class="comment">*** bucketIndex：数组下标位置，即key-value在数组中的位置。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * table.length);<span class="comment">//扩容两倍</span></span><br><span class="line">            hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 往数组中添加新的key-value键值对</span></span><br><span class="line">      createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>createEntry方法</p>
<ul>
<li><p>该方法主要完成两个功能</p>
<p>1、添加新的key到Entry数组中</p>
<p>2、对于不同key的hash值相同的情况下，在同一个数组下标处，构建单向链表进行存储。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 取出当前位置的元素，如果是新添加的key,则e为null，已经有的元素为不为空。</span></span><br><span class="line">       Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">       <span class="comment">// 添加新的key-value值或构建链表</span></span><br><span class="line">       table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>遍历HashMap的键</p>
<ol>
<li>根据keySet()获取HashMap的“键”的Set集合。</li>
<li>通过Iterator迭代器遍历“第一步”得到的集合</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设map是HashMap对象</span></span><br><span class="line"><span class="comment">// map中的key是String类型，value是Integer类型</span></span><br><span class="line">String key = <span class="keyword">null</span>;</span><br><span class="line">Integer integ = <span class="keyword">null</span>;</span><br><span class="line">Iterator iter = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        <span class="comment">// 获取key</span></span><br><span class="line">    key = (String)iter.next();</span><br><span class="line">        <span class="comment">// 根据key，获取value</span></span><br><span class="line">    integ = (Integer)map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历HashMap的值</p>
<ol>
<li>根据value()获取HashMap的“值”的集合。</li>
<li>通过Iterator迭代器遍历“第一步”得到的集合。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设map是HashMap对象</span></span><br><span class="line"><span class="comment">// map中的key是String类型，value是Integer类型</span></span><br><span class="line">Integer value = <span class="keyword">null</span>;</span><br><span class="line">Collection c = map.values();</span><br><span class="line">Iterator iter= c.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    value = (Integer)iter.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ol>
<li>TreeMap 是一个<strong>有序的key-value集合</strong>，它是通过红黑树实现的。</li>
<li>TreeMap <strong>继承于AbstractMap</strong>，所以它是一个Map，即一个key-value集合。</li>
<li>TreeMap 实现了NavigableMap接口，意味着它<strong>支持一系列的导航方法。</strong>比如返回有序的key集合。</li>
<li>TreeMap 实现了Cloneable接口，意味着<strong>它能被克隆</strong>。</li>
<li>TreeMap 实现了java.io.Serializable接口，意味着<strong>它支持序列化</strong>。</li>
<li>TreeMap基于<strong>红黑树（Red-Black tree）实现</strong>。该映射根据<strong>其键的自然顺序进行排序</strong>，或者根据<strong>创建映射时提供的 Comparator 进行排序</strong>，具体取决于使用的构造方法。</li>
<li>TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n)（jdk1.8之后加入红黑树由o(n)变为o( log(n) )  ） 。</li>
<li>TreeMap是<strong>非同步</strong>的。 它的iterator 方法返回的<strong>迭代器是fail-fastl</strong>的</li>
</ol>
<p><img src="/2019/05/26/java集合类/集合类之MAP/集合类之MAP/Treemap接口图.jpg" alt></p>
<p>从图中可以看出：<br>(1) TreeMap实现继承于AbstractMap，并且实现了NavigableMap接口。<br>(2) TreeMap的本质是R-B Tree(红黑树)，它包含几个重要的成员变量： root, size, comparator。<br>　　root 是红黑数的根节点。它是Entry类型，Entry是红黑数的节点，它包含了红黑数的6个基本组成成分：key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色)。Entry节点根据key进行排序，Entry节点包含的内容为value。<br>　　红黑数排序时，根据Entry中的key进行排序；Entry中的key比较大小是根据比较器comparator来进行判断的。size是红黑数中节点的个数。</p>
<p>数据结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;    <span class="comment">//键</span></span><br><span class="line">    V value;    <span class="comment">//值</span></span><br><span class="line">    Entry&lt;K,V&gt; left = <span class="keyword">null</span>;     <span class="comment">//左孩子节点</span></span><br><span class="line">    Entry&lt;K,V&gt; right = <span class="keyword">null</span>;    <span class="comment">//右孩子节点</span></span><br><span class="line">    Entry&lt;K,V&gt; parent;          <span class="comment">//父节点</span></span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;      <span class="comment">//节点的颜色，在红黑树种，只有两种颜色，红色和黑色</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法，用指定的key,value ,parent初始化，color默认为黑色</span></span><br><span class="line">    Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回该节点对应的value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//替换节点的值，并返回旧值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        V oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写equals()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">        <span class="comment">//两个节点的key相等，value相等，这两个节点才相等</span></span><br><span class="line">        <span class="keyword">return</span> valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写hashCode()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> keyHash = (key==<span class="keyword">null</span> ? <span class="number">0</span> : key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> valueHash = (value==<span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">        <span class="comment">//key和vale hash值得异或运算，相同则为零，不同则为1 </span></span><br><span class="line">        <span class="keyword">return</span> keyHash ^ valueHash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写toString()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key + <span class="string">"="</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法，comparator用键的顺序做比较</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法，提供比较器，用指定比较器排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    his.comparator = comparator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将m中的元素转化daoTreeMap中，按照键的顺序做比较排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = <span class="keyword">null</span>;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法，指定的参数为SortedMap</span></span><br><span class="line"><span class="comment">//采用m的比较器排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = m.comparator();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buildFromSorted(m.size(), m.entrySet().iterator(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TreeMap提供了四个构造方法，实现了方法的重载。无参构造方法中比较器的值为null,采用自然排序的方法，如果指定了比较器则称之为定制排序.</p>
<ul>
<li>自然排序：TreeMap的所有key必须实现Comparable接口，所有的key都是同一个类的对象</li>
<li>定制排序：创建TreeMap对象传入了一个Comparator对象，该对象负责对TreeMap中所有的key进行排序，采用定制排序不要求Map的key实现Comparable接口。</li>
</ul>
<p>Put()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;     <span class="comment">//红黑树的根节点</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;        <span class="comment">//红黑树是否为空</span></span><br><span class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line">        <span class="comment">//构造根节点，因为根节点没有父节点，传入null值。 </span></span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);  </span><br><span class="line">        size = <span class="number">1</span>;     <span class="comment">//size值加1</span></span><br><span class="line">        modCount++;    <span class="comment">//改变修改的次数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;    <span class="comment">//返回null </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;    <span class="comment">//定义节点</span></span><br><span class="line"></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;     <span class="comment">//获取比较器</span></span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;      <span class="comment">//如果定义了比较器，采用自定义比较器进行比较</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;      <span class="comment">//将红黑树根节点赋值给parent</span></span><br><span class="line">            cmp = cpr.compare(key, t.key);     <span class="comment">//比较key, 与根节点的大小</span></span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)      <span class="comment">//如果key &lt; t.key , 指向左子树</span></span><br><span class="line">                t = t.left;   <span class="comment">//t = t.left  , t == 它的做孩子节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;  <span class="comment">//如果key &gt; t.key , 指向它的右孩子节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);      <span class="comment">//如果它们相等，替换key的值</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);        <span class="comment">//循环遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//自然排序方式，没有指定比较器</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  <span class="comment">//抛出异常</span></span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;    <span class="comment">//类型转换</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)     <span class="comment">// key &lt; t.key </span></span><br><span class="line">                t = t.left;   <span class="comment">//左孩子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)   <span class="comment">// key &gt; t.key </span></span><br><span class="line">                t = t.right;    <span class="comment">//右孩子</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);   <span class="comment">//t == t.key , 替换value值</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);   <span class="comment">//创建新节点，并制定父节点</span></span><br><span class="line">    <span class="comment">//根据比较结果，决定新节点为父节点的左孩子或者右孩子</span></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);   <span class="comment">//新插入节点后重新调整红黑树 </span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比较方法，如果comparator==null ,采用comparable.compartTo进行比较，否则采用指定比较器比较大小</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object k1, Object k2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> comparator==<span class="keyword">null</span> ? ((Comparable&lt;? <span class="keyword">super</span> K&gt;)k1).compareTo((K)k2)</span><br><span class="line">        : comparator.compare((K)k1, (K)k2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//插入的节点默认的颜色为红色</span></span><br><span class="line">    x.color = RED;    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//情形1： 新节点x 是树的根节点，没有父节点不需要任何操作</span></span><br><span class="line">    <span class="comment">//情形2： 新节点x 的父节点颜色是黑色的，也不需要任何操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">    <span class="comment">//情形3：新节点x的父节点颜色是红色的</span></span><br><span class="line">    <span class="comment">//判断x的节点的父节点位置，是否属于左孩子</span></span><br><span class="line">    <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">          <span class="comment">//获取x节点的父节点的兄弟节点，上面语句已经判断出x节点的父节点为左孩子，所以直接取右孩子</span></span><br><span class="line">         Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">         <span class="comment">//判断是否x节点的父节点的兄弟节点为红色。</span></span><br><span class="line">         <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">              setColor(parentOf(x), BLACK); <span class="comment">// x节点的父节点设置为黑色</span></span><br><span class="line">              setColor(y, BLACK);           <span class="comment">// y节点的颜色设置为黑色</span></span><br><span class="line">              setColor(parentOf(parentOf(x)), RED); <span class="comment">// x.parent.parent设置为红色</span></span><br><span class="line">              x = parentOf(parentOf(x)); <span class="comment">// x == x.parent.parent ,进行遍历。</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//x的父节点的兄弟节点是黑色或者缺少的</span></span><br><span class="line">               <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;   <span class="comment">//判断x节点是否为父节点的右孩子</span></span><br><span class="line">                    x = parentOf(x);     <span class="comment">//x == 父节点</span></span><br><span class="line">                    rotateLeft(x);    <span class="comment">//左旋转操作</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//x节点是其父的左孩子</span></span><br><span class="line">               setColor(parentOf(x), BLACK);</span><br><span class="line">               setColor(parentOf(parentOf(x)), RED);  <span class="comment">//上面两句将x.parent 和x.parent.parent的颜色做调换</span></span><br><span class="line">               rotateRight(parentOf(parentOf(x)));   <span class="comment">//进行右旋转</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));  <span class="comment">//y 是x 节点的祖父节点的左孩子</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;    <span class="comment">//判断颜色</span></span><br><span class="line">                setColor(parentOf(x), BLACK);    <span class="comment">//父节点设置为黑色</span></span><br><span class="line">                setColor(y, BLACK);         <span class="comment">//父节点的兄弟节点设置为黑色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);   <span class="comment">//祖父节点设置为红色</span></span><br><span class="line">                x = parentOf(parentOf(x));   <span class="comment">//将祖父节点作为新插入的节点，遍历调整</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;     <span class="comment">//x 是其父亲的左孩子</span></span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateRight(x);    <span class="comment">//以父节点为旋转点，进行右旋操作</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);    <span class="comment">//父节点为设置为黑色</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);  <span class="comment">//祖父节点设置为红色</span></span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));  <span class="comment">//以父节点为旋转点，进行左旋操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK; <span class="comment">//通过节点位置的调整，最终将红色的节点条调换到了根节点的位置，根节点重新设置为黑色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增加删除节点都运用了红黑树的原理，红黑树有五个特点：</p>
<ol>
<li>每个节点只能是红色或者黑色</li>
<li>根节点永远是黑色的</li>
<li>所有的叶子的子节点都是空节点，并且都是黑色的</li>
<li>每个红色节点的两个子节点都是黑色的（不会有两个连续的红色节点）</li>
<li>从任一个节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点（叶子节点到根节点的黑色节点数量每条路径都相同）</li>
</ol>
<p>红黑树插入新节点的三个关键地方：<br>1、插入新节点总是红色节点。<br>2、插入节点的父节点是黑色，能维持性质。<br>3、如果插入节点的父节点是红色，破坏了性质。故插入算法就是通过重新着色或旋转，来维持性质</p>
<p>deleteEntry()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">        modCount++;      <span class="comment">//修改次数 +1</span></span><br><span class="line">        size--;          <span class="comment">//元素个数 -1</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 被删除节点的左子树和右子树都不为空，那么就用 p节点的中序后继节点代替 p 节点</span></span><br><span class="line"><span class="comment">         * successor(P)方法为寻找P的替代节点。规则是右分支最左边，或者 左分支最右边的节点</span></span><br><span class="line"><span class="comment">         * ---------------------（1）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;  </span><br><span class="line">            Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">            p.key = s.key;</span><br><span class="line">            p.value = s.value;</span><br><span class="line">            p = s;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//replacement为替代节点，如果P的左子树存在那么就用左子树替代，否则用右子树替代</span></span><br><span class="line">        Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 删除节点，分为上面提到的三种情况</span></span><br><span class="line"><span class="comment">         * -----------------------（2）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//如果替代节点不为空</span></span><br><span class="line">        <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;</span><br><span class="line">            replacement.parent = p.parent;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *replacement来替代P节点</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//若P没有父节点，则跟节点直接变成replacement</span></span><br><span class="line">            <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">                root = replacement;</span><br><span class="line">            <span class="comment">//如果P为左节点，则用replacement来替代为左节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left  = replacement;</span><br><span class="line">          <span class="comment">//如果P为右节点，则用replacement来替代为右节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.parent.right = replacement;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//同时将P节点从这棵树中剔除掉</span></span><br><span class="line">            p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 若P为红色直接删除，红黑树保持平衡</span></span><br><span class="line"><span class="comment">             * 但是若P为黑色，则需要调整红黑树使其保持平衡</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">                fixAfterDeletion(replacement);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123;     <span class="comment">//p没有父节点，表示为P根节点，直接删除即可</span></span><br><span class="line">            root = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;      <span class="comment">//P节点不存在子节点，直接删除即可</span></span><br><span class="line">            <span class="keyword">if</span> (p.color == BLACK)         <span class="comment">//如果P节点的颜色为黑色，对红黑树进行调整</span></span><br><span class="line">                fixAfterDeletion(p);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//删除P节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                    p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                    p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">                p.parent = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>TreeMap还有很多地方没有写全，后续再来补学。</p>
<p>TreeMap问题集锦</p>
<p>1、TreeMap的键、值能否为null</p>
<ul>
<li>value是可以为null的</li>
<li>当未实现 Comparator 接口时，key 不可以为null，否则抛 NullPointerException 异常；</li>
<li>当实现 Comparator 接口时，若未对 null 情况进行判断，则可能抛 NullPointerException 异常。如果针对null情况实现了，可以存入，但是却不能正常使用get()访问，只能通过遍历去访问。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">测试Value能否为<span class="keyword">null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;String, Integer&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        treeMap.put(<span class="string">"1"</span>,<span class="number">1</span>);</span><br><span class="line">        treeMap.put(<span class="string">"2"</span>,<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(treeMap.get(<span class="string">"2"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    结果：<span class="keyword">null</span></span><br><span class="line">    </span><br><span class="line">测试key能否为<span class="keyword">null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;String, Integer&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        treeMap.put(<span class="string">"1"</span>,<span class="number">1</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        System.out.println(treeMap.get(<span class="string">"2"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    结果：Exception in thread <span class="string">"main"</span> java.lang.NullPointerException</span><br><span class="line">	at java.util.TreeMap.put(TreeMap.java:<span class="number">563</span>)</span><br><span class="line">	at com.crazy_june.test_treemap.main(test_treemap.java:<span class="number">9</span>)</span><br><span class="line">	</span><br><span class="line">测试当自己实现一个comparator接口时</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;String, Integer&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;(<span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> o2.charAt(<span class="number">0</span>)-o1.charAt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeMap.put(<span class="string">"1"</span>,<span class="number">1</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">null</span>,<span class="number">12</span>);</span><br><span class="line">        treeMap.put(<span class="string">"2"</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(treeMap.get(<span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    结果：<span class="keyword">null</span></span><br><span class="line">    证明不能通过get()取出来</span><br><span class="line">    </span><br><span class="line">测试通过遍历entry可以取出来不</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry:treeMap.entrySet())&#123;</span><br><span class="line">            System.out.println(entry.getKey()+<span class="string">":"</span>+entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">   结果：</span><br><span class="line">        <span class="number">2</span>:<span class="number">2</span></span><br><span class="line">        <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">        <span class="keyword">null</span>:<span class="number">12</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/java集合类/集合类之SET/集合类之SET/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/java集合类/集合类之SET/集合类之SET/" class="post-title-link" itemprop="url">集合类之SET</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 23:55:57" itemprop="dateModified" datetime="2019-10-06T23:55:57+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T23:55:57+08:00" content="2019-10-06">
                2019-10-06 23:55:57
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/集合框架/" itemprop="url" rel="index"><span itemprop="name">集合框架</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/java集合类/集合类之SET/集合类之SET/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/java集合类/集合类之SET/集合类之SET/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="集合类之SET"><a href="#集合类之SET" class="headerlink" title="集合类之SET"></a>集合类之SET</h1><p>set集合可以存储多个对象，但并不会记住元素的存储顺序，也不允许集合中有重复元素(不同的set集合有不同的判断方法)。</p>
<h3 id="1-HashSet"><a href="#1-HashSet" class="headerlink" title="1.HashSet"></a>1.HashSet</h3><p>HashSet按照Hash算法存储集合中的元素，具有很好的存取和查找性能。当向HashSet中添加一些元素时，HashSet会根据该对象的HashCode()方法来得到该对象的HashCode值，然后根据这些HashCode的值来决定元素的位置。(HashSet的底层原理是HashMap)</p>
<p>HashSet的特点：1.存储顺序和添加的顺序不同</p>
<p>　　　　　　　　2.HashSet不是同步的，如果多个线程同时访问一个HashSet，假设有两个或更多的线程修改了                集合中的值，则必须通过代码使线程同步。</p>
<p>　　　　　　　　3.HastSet允许集合中的元素为null。</p>
<p>​                   4.非线程安全</p>
<p>在Hashset集合中，<strong>判断两个元素相同的标准是：两个对象通过equals()方法相等，且HashCode()方法的返回值也相等。</strong>如果有两个元素通过equals()方法比较相等，而HashCode()的返回值不同，HashSet会将这两个对象保存在不同的地方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;  </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;  </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5024744406713321676L</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 底层使用HashMap来保存HashSet中所有元素。  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 默认的无参构造器，构造一个空的HashSet。 </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;();  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 构造一个包含指定collection中的元素的新set。 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 实际底层使用默认的加载因子0.75和足以包含指定 </span></span><br><span class="line"><span class="comment">     * collection中所有元素的初始容量来创建一个HashMap。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 其中的元素将存放在此set中的collection。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));  </span><br><span class="line">    addAll(c);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 以指定的initialCapacity和loadFactor构造一个空的HashSet。 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 实际底层以相应的参数构造一个空的HashMap。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 初始容量。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadFactor 加载因子。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;  </span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(initialCapacity, loadFactor);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 以指定的initialCapacity构造一个空的HashSet。 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 初始容量。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;  </span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(initialCapacity);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 </span></span><br><span class="line"><span class="comment">     * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 初始容量。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadFactor 加载因子。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dummy 标记。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;  </span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。 </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * 底层实际调用底层HashMap的keySet来返回所有的key。 </span></span><br><span class="line"><span class="comment">     * 可见HashSet中的元素，只是存放在了底层HashMap的key上， </span></span><br><span class="line"><span class="comment">     * value使用一个static final的Object对象标识。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对此set中元素进行迭代的Iterator。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回此set中的元素的数量（set的容量）。 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 此set中的元素的数量（set的容量）。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> map.size();  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 如果此set不包含任何元素，则返回true。 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果此set不包含任何元素，则返回true。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> map.isEmpty();  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 如果此set包含指定元素，则返回true。 </span></span><br><span class="line"><span class="comment">     * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e)) </span></span><br><span class="line"><span class="comment">     * 的e元素时，返回true。 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的containsKey判断是否包含指定key。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 在此set中的存在已得到测试的元素。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果此set包含指定元素，则返回true。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 如果此set中尚未包含指定元素，则添加指定元素。 </span></span><br><span class="line"><span class="comment">     * 更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2)) </span></span><br><span class="line"><span class="comment">     * 的元素e2，则向此set 添加指定的元素e。 </span></span><br><span class="line"><span class="comment">     * 如果此set已包含该元素，则该调用不更改set并返回false。 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 底层实际将将该元素作为key放入HashMap。 </span></span><br><span class="line"><span class="comment">     * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key </span></span><br><span class="line"><span class="comment">     * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）， </span></span><br><span class="line"><span class="comment">     * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， </span></span><br><span class="line"><span class="comment">     * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， </span></span><br><span class="line"><span class="comment">     * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 将添加到此set中的元素。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果此set尚未包含指定元素，则返回true。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 如果指定元素存在于此set中，则将其移除。 </span></span><br><span class="line"><span class="comment">     * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e， </span></span><br><span class="line"><span class="comment">     * 则将其移除。如果此set已包含该元素，则返回true </span></span><br><span class="line"><span class="comment">     * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的remove方法删除指定Entry。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 如果存在于此set中则需要将其移除的对象。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果set包含指定元素，则返回true。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 从此set中移除所有元素。此调用返回后，该set将为空。 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的clear方法清空Entry中所有元素。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    map.clear();  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) <span class="keyword">super</span>.clone();  </span><br><span class="line">            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();  </span><br><span class="line">            <span class="keyword">return</span> newSet;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashSet所有方法都直接在HashMap上运用，了解HashMap自然可以了解HashSet。</p>
<p>其中需要了解一下HashSet的加载因子和容量：</p>
<p>在HashSet中我们new对象的时候会创建一个<strong>初始默认容量是16</strong>的HashSet集合；其中默认的一个值loadFactor：<br> 加载因子：0.75<br> 加载因子是数组的长度的百分比；16*0.75 = 12；<br> 意思就是数组中的桶数达到12个时数组就要扩容；（复制），扩容到原来的2倍；<br> 0.75是一个折中的数据；是增删改查的最优速度；<br> new的时候可以直接初始化数组长度和loadFactor（加载因子）来改变加载因子；</p>
<p>注意：</p>
<ul>
<li>对于HashSet中保存的对象，主要要正确重写equals方法和hashCode方法，以保证放入Set对象的唯一性</li>
<li>虽说是Set是对于重复的元素不放入，<strong>倒不如直接说是底层的Map直接把原值替代了</strong></li>
<li>HashSet没有提供get()方法，愿意是同HashMap一样，Set内部是无序的，只能通过迭代的方式获得</li>
</ul>
<h3 id="2-LinkedHashSet"><a href="#2-LinkedHashSet" class="headerlink" title="2.LinkedHashSet"></a>2.LinkedHashSet</h3><p>LinkedHashSet是继承自HashSet，底层实现是LinkedHashMap。并且其初始化时直接<code>super(......)</code></p>
<p>查看了LinkedHashMap的构造方法后，发现其因为继承自HashMap，所以其底层实现也是HashMap!!!，然后发现了LinkedHashMap调用父类构造方法初始化时，还顺便设置了变量<code>accessOrder = false</code>，看上面得源码可以知道，这是给了迭代器一个参数，<strong>false代表迭代时使用插入得顺序</strong></p>
<h3 id="3-TreeSet"><a href="#3-TreeSet" class="headerlink" title="3.TreeSet"></a>3.TreeSet</h3><p>1、TreeSet(树集)是一个有序集合，可以按照任何顺序将元素插入该集合，当对该集合进行迭代时，各个值将自动以排序后的顺序出现。TreeSet中的元素按照升序排列，缺省是按照自然顺序进行排序，意味着TreeSet中的元素要实现Comparable接口，或者有一个自定义的比较器Comparator。</p>
<p>2、TreeSet底层使用的是TreeMap，TreeMap的底层实现是红黑树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public TreeSet()</span><br><span class="line">&#123;</span><br><span class="line">       this(new TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>　　1、TreeSet的排列顺序必须是全局顺序，也就是说任何两个元素都是必须可比的，同时只有当他们比较相同时才返回0。</p>
<p>　　2、如果树集包含了n个元素，那么平均需要进行log2n次比较，才能找到新元素的正确位置。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/JavaEE/JDBC/JDBC知识总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/JavaEE/JDBC/JDBC知识总结/" class="post-title-link" itemprop="url">JDBC知识总结</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-07 14:22:26" itemprop="dateModified" datetime="2019-10-07T14:22:26+08:00">2019-10-07</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-07T14:22:26+08:00" content="2019-10-07">
                2019-10-07 14:22:26
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JavaEE/" itemprop="url" rel="index"><span itemprop="name">JavaEE</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/JavaEE/JDBC/JDBC知识总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/JavaEE/JDBC/JDBC知识总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JDBC知识总结"><a href="#JDBC知识总结" class="headerlink" title="JDBC知识总结"></a>JDBC知识总结</h1><h3 id="JDBC的接口和类"><a href="#JDBC的接口和类" class="headerlink" title="JDBC的接口和类"></a>JDBC的接口和类</h3><p>JDBC API主要位于java.sql包中，关键的接口和类包括以下几种。</p>
<table>
<thead>
<tr>
<th>类/接口</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Driver接口、DriverManager类</td>
<td>前者表示驱动器、后者表示驱动管理器</td>
</tr>
<tr>
<td>Connection接口</td>
<td>表示数据库的链接</td>
</tr>
<tr>
<td>Statement接口</td>
<td>负责执行SQL语句</td>
</tr>
<tr>
<td>PreparedStatement接口</td>
<td>负责执行预备的SQL语句</td>
</tr>
<tr>
<td>CallableStatement接口</td>
<td>负责执行SQL存储过程</td>
</tr>
<tr>
<td>ResultSet接口</td>
<td>表示SQL查询语句返回的结果集</td>
</tr>
</tbody>
</table>
<h3 id="JDBC步骤"><a href="#JDBC步骤" class="headerlink" title="JDBC步骤"></a>JDBC步骤</h3><p>1、注册驱动</p>
<p>2、获取与数据库的链接</p>
<p>3、创建代表SQL语句的对象</p>
<p>4、执行SQL语句</p>
<p>5、如果是查询语句，需要遍历结果集</p>
<p>6、释放占用的资源</p>
<p><img src="/2019/05/26/JavaEE/JDBC/JDBC知识总结/JDBC建立步骤.png" alt></p>
<h3 id="DriverManager接口和DriverManager类"><a href="#DriverManager接口和DriverManager类" class="headerlink" title="DriverManager接口和DriverManager类"></a>DriverManager接口和DriverManager类</h3><p>DriverManager类用来建立和数据库的连接及管理JDBC驱动器。DriverManager类的方法都是静态的，主要包括以下几种</p>
<table>
<thead>
<tr>
<th><strong>类/接口</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>registerDriver（Driver driver）</td>
<td>在DriverManeger中注册JDBC驱动器<br></td>
</tr>
<tr>
<td>getConnection(String url,String user,String password)</td>
<td>建立和数据的连接</td>
</tr>
<tr>
<td>setLoginTime（int seconds）</td>
<td>设定等待建立数据连接的超时时间</td>
</tr>
<tr>
<td>setlogWriter（PrintWriter out）</td>
<td>设定输出JDBC日志的PrintWriter对象</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册数据库的驱动</span></span><br><span class="line">Class.forName(<span class="string">"com.MySQL.jdbc.Driver"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建数据库的链接信息(指定要连接那个数据库)：数据库路径、数据库的账号和密码</span></span><br><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3306/dataBase_Name"</span>;</span><br><span class="line"><span class="comment">//jdbc:数据库://ip地址:端口号;数据库名 </span></span><br><span class="line">String username = <span class="string">"root"</span>;</span><br><span class="line">String password = <span class="string">"123456"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//连接数据库，返回连接结果，该结果的类型是Connection</span></span><br><span class="line">Connection conn = DriverManager.getConnection(url,username,password);<span class="comment">//获得连接</span></span><br></pre></td></tr></table></figure>
<p>注意，上面代码可能出现的两种异常：</p>
<p>   1、ClassNotFoundException：这个异常是在加载数据库驱动的时候，出现这个异常有两个可能：</p>
<p>​          a、检查是否导入了Mysql的jar包</p>
<p>​          b、将数据库的驱动名打错，检查是否是com.MySQL.jdbc.Driver</p>
<p>   2、SQLException：这个异常出现在连接数据库的过程，出现这个异常就是三个参数的问题。</p>
<p>Class.forName(“com.mysql.jdbc.Driver”)和DriverManager.registerDriver(new com.mysql.jdbc.Driver())的区别</p>
<p>Class.forName(“com.mysql.jdbc.Driver”)的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      DriverManager.registerDriver(<span class="keyword">new</span> Driver());<span class="comment">//静态代码块，加载即初始化</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>DriverManager.registerDriver(new com.mysql.jdbc.Driver())</p>
<p>Driver类的静态代码块会注册一次，那么此时new Driver的时候就会注册一次，然后外层又会注册一次，所以注册了两次驱动(加载一次、初始化一次)</p>
<h3 id="connection接口"><a href="#connection接口" class="headerlink" title="connection接口"></a>connection接口</h3><p>Connection接口代表Java程序和数据库的连接，主要包括以下方法。</p>
<table>
<thead>
<tr>
<th><strong>类/接口</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>getMetaData（）</td>
<td>返回表示数据库的元数据的DatabaseMetaData对象，元数据包含了描述数据库的相关信息</td>
</tr>
<tr>
<td>createStatement（）</td>
<td>创建并返回Statement对象</td>
</tr>
<tr>
<td>prepareStatement（）</td>
<td>创建并返回prepareStatement对象</td>
</tr>
</tbody>
</table>
<p>Connection最为重要的方法就是获取Statement或者prepareStatement对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Statement的用法</span></span><br><span class="line">Statement st = conn.createStatement(sql);</span><br><span class="line">ResultSet rs = stmt.executeQuery();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//prepareStatement的用法</span></span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">ResultSet rs = ps.executeQuery();</span><br></pre></td></tr></table></figure>
<h3 id="Statement接口"><a href="#Statement接口" class="headerlink" title="Statement接口"></a>Statement接口</h3><p>Statement接口提供了3个执行SQL语句的方法</p>
<table>
<thead>
<tr>
<th><strong>类/接口</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>execute（String sql）</td>
<td>执行各种SQL语句，该方法返回一个boolean类型的值。该方法返回的是boolean类型，表示SQL语句是否有结果集。</td>
</tr>
</tbody>
</table>
<pre><code>如果执行的是更新语句，那么还要调用int getUpdateCount()来获取insert、update、delete语句所影响的行数。
如果执行的是查询语句，那么还要调用ResultSet对象的getResultSet()来获取select语句的查询结果。 |
</code></pre><p>| executeUpdate（String sql） | 执行SQL的<strong>insert</strong>、<strong>update</strong>和<strong>delet**</strong>等<strong>语句，适用于</strong>不需要返回结果的SQL语句。该方法返回一个int类型的值，表示数据库中受该SQL语句影响的记录的数目。 |<br>| executeQuery（String sql）  | 执行SQL的select语句。查询操作会返回ResultSet对象，即结果集。 |</p>
<p>PrepareStatement接口</p>
<p>PrepareStatement接口继承了Statement接口，用来执行准备的SQL语句。在访问数据库时，可能会遇到某条SQL语句被多次执行，但是其中的参数却不同的情况。</p>
<p>使用PrepareStatement，而不是Statement来执行SQL语句，这样做具有以下优点：</p>
<ul>
<li>简化程序代码，是程序更加灵活。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建SQL语句</span></span><br><span class="line">String sql = <span class="string">"Select * From users Where name = ? And sex = ? And age = ?"</span>;</span><br><span class="line"><span class="comment">//设置参数值</span></span><br><span class="line">ps.setString(<span class="number">1</span>,<span class="string">"LaoYe"</span>);     <span class="comment">//此处的1表示name中的?，而LaoYe表示name的值，下面同理</span></span><br><span class="line">ps.isBoolean(<span class="number">2</span>,<span class="keyword">true</span>);</span><br><span class="line">ps.setInt(<span class="number">3</span>,<span class="number">18</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>提高访问数据库的性能。PrepareStatement执行预准备的SQL语句，数据库只需对这种SQL语句编译一次，然后就可以多次执行。而每次用Statement执行SQL语句时，数据库都需要对该SQL语句进行编译。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、创建SQL语句</span></span><br><span class="line">String sql = <span class="string">"Insert Into users(name,sex,age) Values(?,?,?)"</span>;</span><br><span class="line"><span class="comment">//2、连接数据库，获取连接对象</span></span><br><span class="line">Connection conn = DriverManager.getConnection(url,account,password);</span><br><span class="line"><span class="comment">//3、预准备SQL语句</span></span><br><span class="line">PrepareStatement ps = conn.prepareStatement(sql);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//第一次插入</span></span><br><span class="line">ps.setString(<span class="number">1</span>,<span class="string">"LaoYe"</span>);     <span class="comment">//此处的1表示name中的?，而LaoYe表示name的值，下面同理</span></span><br><span class="line">ps.isBoolean(<span class="number">2</span>,<span class="keyword">true</span>);</span><br><span class="line">ps.setInt(<span class="number">3</span>,<span class="number">18</span>);</span><br><span class="line">ps.executeUpdate();</span><br><span class="line"> </span><br><span class="line">第二次插入</span><br><span class="line">ps.setString(<span class="number">1</span>,<span class="string">"LaoCheng"</span>);     <span class="comment">//此处的1表示name中的?，而LaoYe表示name的值，下面同理</span></span><br><span class="line">ps.isBoolean(<span class="number">2</span>,<span class="keyword">false</span>);</span><br><span class="line">ps.setInt(<span class="number">3</span>,<span class="number">18</span>);</span><br><span class="line">ps.executeUpdate();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//结论：可以看出除了值，几乎是重复的，所以视情况可以循环插入，提高开发效率</span></span><br></pre></td></tr></table></figure>
<ul>
<li>作为 Statement 的子类，PreparedStatement 继承了 Statement 的所有功能。同时，三种方法 execute、                                       executeQuery 和 executeUpdate 已被更改以使之不再需要参数。</li>
</ul>
<p>preparestatement预防SQL注入的原因：</p>
<p>  因为sql语句是预编译的，而且<strong>语句中使用了占位符，规定了sql语句的结构。用户可以设置”?”的值，但是不能改变sql语句的结构</strong>，因此想在sql语句后面加上如“or 1=1”实现sql注入是行不通的。</p>
<h3 id="ResultSet接口"><a href="#ResultSet接口" class="headerlink" title="ResultSet接口"></a>ResultSet接口</h3><p>结果集对象。该对象包含访问查询结果的方法，ResultSet可以通过列索引或列名或得数据。</p>
<p>　循环输出数据库信息：</p>
<p>　　while(rs.next()){<br>　　　　System.out.println(rs.getString(1));<br>　　　　System.out.println(rs.getString(2));<br>　　　　System.out.println(rs.getString(3));<br>　　　　System.out.println(rs.getString(4));<br>}</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/16/jvm/JVM概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/16/jvm/JVM概述/" class="post-title-link" itemprop="url">JVM概述</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-16 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-16T12:12:57+08:00">2019-05-16 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-25 01:21:12" itemprop="dateModified" datetime="2019-10-25T01:21:12+08:00">2019-10-25</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-25T01:21:12+08:00" content="2019-10-25">
                2019-10-25 01:21:12
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/16/jvm/JVM概述/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/16/jvm/JVM概述/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="内存区域-运行时数据区"><a href="#内存区域-运行时数据区" class="headerlink" title="内存区域(运行时数据区)"></a>内存区域(运行时数据区)</h2><h3 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h3><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>存储着方法出口，局部变量表、动态链接、操作数栈</p>
<p>局部变量表存储的是方法里面的变量<br>操作数栈的作用就是变量和常量或变量和变量之间的计算，</p>
<h5 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h5><h5 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h5><p>主要用于方法内对变量与变量之间的计算，用于计算</p>
<h5 id="方法出口"><a href="#方法出口" class="headerlink" title="方法出口"></a>方法出口</h5><h5 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h5><p>主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>介绍<br>当前线程所执行的字节码的行号指示器</p>
<p>作用：<br>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</p>
<p>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</p>
<h3 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a>线程共享</h3><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。    </p>
<h5 id="新生区"><a href="#新生区" class="headerlink" title="新生区"></a>新生区</h5><h6 id="eden-80"><a href="#eden-80" class="headerlink" title="eden 80%"></a>eden 80%</h6><h6 id="from-survivor-10"><a href="#from-survivor-10" class="headerlink" title="from survivor 10%"></a>from survivor 10%</h6><h6 id="to-survivor-10"><a href="#to-survivor-10" class="headerlink" title="to survivor 10%"></a>to survivor 10%</h6><h5 id="老年区"><a href="#老年区" class="headerlink" title="老年区"></a>老年区</h5><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</p>
<h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>包装类和String：<br>是存在常量池还是堆中的问题</p>
<h6 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h6><p>####### 文本字符串</p>
<p>####### final常量池</p>
<p>####### 基本数据类型</p>
<h6 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h6><p>####### 类和结构的完全限定名</p>
<p>####### 字段名称和描述符</p>
<p>####### 方法名称和描述符</p>
<h5 id="类信息"><a href="#类信息" class="headerlink" title="类信息"></a>类信息</h5><h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><h5 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h5><h3 id="直接内存-非运行时数据区"><a href="#直接内存-非运行时数据区" class="headerlink" title="直接内存(非运行时数据区)"></a>直接内存(非运行时数据区)</h3><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="堆空间基本结构"><a href="#堆空间基本结构" class="headerlink" title="堆空间基本结构"></a>堆空间基本结构</h3><h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><p>对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(“To”)，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)。<br>当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，经过这次GC后，Eden区和”From”区已经被清空。<br>这个时候，”From”和”To”会交换他们的角色，也就是新的”To”就是上次GC前的“From”，新的”From”就是上次GC前的”To”。<br>“To”区被填满之后，会将所有对象移动到年老代中。</p>
<h5 id="eden区"><a href="#eden区" class="headerlink" title="eden区"></a>eden区</h5><h5 id="from-survivor"><a href="#from-survivor" class="headerlink" title="from survivor"></a>from survivor</h5><h5 id="to-survivor"><a href="#to-survivor" class="headerlink" title="to survivor"></a>to survivor</h5><h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><h3 id="堆内存分配策略"><a href="#堆内存分配策略" class="headerlink" title="堆内存分配策略"></a>堆内存分配策略</h3><h4 id="对象优先在eden区"><a href="#对象优先在eden区" class="headerlink" title="对象优先在eden区"></a>对象优先在eden区</h4><p>mirror GC在新生代<br>Full/Major GC在老年区</p>
<h4 id="大对象直接进入老年区"><a href="#大对象直接进入老年区" class="headerlink" title="大对象直接进入老年区"></a>大对象直接进入老年区</h4><h4 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h4><h4 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h4><h3 id="判断对象死亡"><a href="#判断对象死亡" class="headerlink" title="判断对象死亡"></a>判断对象死亡</h3><h4 id="对象无效判断方法"><a href="#对象无效判断方法" class="headerlink" title="对象无效判断方法"></a>对象无效判断方法</h4><h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><p>难以解决对象相互引用问题</p>
<h5 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h5><p>通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p>
<h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h5><p>与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。<br>虚引用主要用来跟踪对象被垃圾回收的活动。</p>
<h4 id="判断废弃常量"><a href="#判断废弃常量" class="headerlink" title="判断废弃常量"></a>判断废弃常量</h4><p>假如在常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。</p>
<h4 id="判断无用的类"><a href="#判断无用的类" class="headerlink" title="判断无用的类"></a>判断无用的类</h4><p>方法区主要回收的是无用的类</p>
<h5 id="堆中不存在该类的任何实例"><a href="#堆中不存在该类的任何实例" class="headerlink" title="堆中不存在该类的任何实例"></a>堆中不存在该类的任何实例</h5><h5 id="加载该类的类加载器被回收"><a href="#加载该类的类加载器被回收" class="headerlink" title="加载该类的类加载器被回收"></a>加载该类的类加载器被回收</h5><h5 id="该类对应的java-lang-Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法"><a href="#该类对应的java-lang-Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法" class="headerlink" title="该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法"></a>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</h5><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标志-清除算法"><a href="#标志-清除算法" class="headerlink" title="标志-清除算法"></a>标志-清除算法</h4><h5 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h5><h5 id="空间问题"><a href="#空间问题" class="headerlink" title="空间问题"></a>空间问题</h5><p>产生大量的空间碎片</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>解决效率问题<br>分成两块，经过GC之后将存活的对象转移到另一块，该块被全部清除</p>
<h4 id="标志-整理算法"><a href="#标志-整理算法" class="headerlink" title="标志-整理算法"></a>标志-整理算法</h4><p>解决了空间碎片问题<br>与标记清除之后，把存活的对象移到一端，直接清理边界以外的对象</p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>单线程<br>垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ）</p>
<h5 id="新生代复制算法"><a href="#新生代复制算法" class="headerlink" title="新生代复制算法"></a>新生代复制算法</h5><h5 id="老年代标记-整理算法"><a href="#老年代标记-整理算法" class="headerlink" title="老年代标记-整理算法"></a>老年代标记-整理算法</h5><h4 id="Parnew收集器"><a href="#Parnew收集器" class="headerlink" title="Parnew收集器"></a>Parnew收集器</h4><p>GC线程多线程并发</p>
<h5 id="新生代复制算法-1"><a href="#新生代复制算法-1" class="headerlink" title="新生代复制算法"></a>新生代复制算法</h5><h5 id="老年代标记-整理算法-1"><a href="#老年代标记-整理算法-1" class="headerlink" title="老年代标记-整理算法"></a>老年代标记-整理算法</h5><h4 id="Paraller-Scavenge收集器"><a href="#Paraller-Scavenge收集器" class="headerlink" title="Paraller Scavenge收集器"></a>Paraller Scavenge收集器</h4><p>Paraller Scavenge和Parnew的区别：<br>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）</p>
<h5 id="新生代复制算法-2"><a href="#新生代复制算法-2" class="headerlink" title="新生代复制算法"></a>新生代复制算法</h5><h5 id="老年代标记-整理算法-2"><a href="#老年代标记-整理算法-2" class="headerlink" title="老年代标记-整理算法"></a>老年代标记-整理算法</h5><h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p>
<h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>是什么？<br>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器</p>
<p>CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。<br>CMS 收集器是一种 “标记-清除”算法实现的    </p>
<h5 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a>初始标记</h5><p> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</p>
<h5 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h5><p>同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。</p>
<p>因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</p>
<h5 id="重新标记"><a href="#重新标记" class="headerlink" title="重新标记"></a>重新标记</h5><p>重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</p>
<h5 id="并发清除"><a href="#并发清除" class="headerlink" title="并发清除"></a>并发清除</h5><p>开启用户线程，同时 GC 线程开始对为标记的区域做清扫。</p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>主要优点：并发收集、低停顿。</p>
<p>但是它有下面三个明显的缺点：<br>对 CPU 资源敏感；（需要多cpu）<br>无法处理浮动垃圾；<br>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</p>
<h4 id="G1算法"><a href="#G1算法" class="headerlink" title="G1算法"></a>G1算法</h4><p>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</p>
<p>特点：<br>1.并行与并发<br>2.分代收集<br>3.空间整合（整体看是标记-整理，局部是复制算法）<br>4.可预测停顿</p>
<h5 id="初始标记-1"><a href="#初始标记-1" class="headerlink" title="初始标记"></a>初始标记</h5><h5 id="并发标记-1"><a href="#并发标记-1" class="headerlink" title="并发标记"></a>并发标记</h5><h5 id="最终标记"><a href="#最终标记" class="headerlink" title="最终标记"></a>最终标记</h5><h5 id="筛选回收"><a href="#筛选回收" class="headerlink" title="筛选回收"></a>筛选回收</h5><h2 id="JDK监控和故障处理"><a href="#JDK监控和故障处理" class="headerlink" title="JDK监控和故障处理"></a>JDK监控和故障处理</h2><h2 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h2><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
<h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><p>每个 Class 文件的头四个字节称为魔数（Magic Number）,它的唯一作用是确定这个文件是否为一个能被虚拟机接收的 Class 文件。</p>
<h3 id="class文件版本"><a href="#class文件版本" class="headerlink" title="class文件版本"></a>class文件版本</h3><p>紧接着魔数的四个字节存储的是 Class 文件的版本号：第五和第六是次版本号，第七和第八是主版本号。</p>
<p>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><h4 id="字面量-1"><a href="#字面量-1" class="headerlink" title="字面量"></a>字面量</h4><p>字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等</p>
<h4 id="符号引用-1"><a href="#符号引用-1" class="headerlink" title="符号引用"></a>符号引用</h4><h5 id="类和接口的全限定名"><a href="#类和接口的全限定名" class="headerlink" title="类和接口的全限定名"></a>类和接口的全限定名</h5><h5 id="字段的名称和描述符"><a href="#字段的名称和描述符" class="headerlink" title="字段的名称和描述符"></a>字段的名称和描述符</h5><h5 id="方法的名称和描述符"><a href="#方法的名称和描述符" class="headerlink" title="方法的名称和描述符"></a>方法的名称和描述符</h5><h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final </p>
<h3 id="类索引"><a href="#类索引" class="headerlink" title="类索引"></a>类索引</h3><p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。</p>
<p>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按implents(如果这个类本身是接口的话则是extends) 后的接口顺序从左到右排列在接口索引集合中。</p>
<h4 id="当前类索引"><a href="#当前类索引" class="headerlink" title="当前类索引"></a>当前类索引</h4><h4 id="父类索引"><a href="#父类索引" class="headerlink" title="父类索引"></a>父类索引</h4><h4 id="接口索引集合"><a href="#接口索引集合" class="headerlink" title="接口索引集合"></a>接口索引集合</h4><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</p>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。</p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>Class 文件需要加载到虚拟机中之后才能运行和使用</p>
<p>系统加载 Class 类型的文件主要三步:加载-&gt;连接-&gt;初始化。        </p>
<p>连接过程又可分为三步:验证-&gt;准备-&gt;解析。</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段</p>
<p>这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</p>
<h4 id="通过全限定名加载字符流"><a href="#通过全限定名加载字符流" class="headerlink" title="通过全限定名加载字符流"></a>通过全限定名加载字符流</h4><h4 id="通过静态的字符流转换方法区运行时的数据结构"><a href="#通过静态的字符流转换方法区运行时的数据结构" class="headerlink" title="通过静态的字符流转换方法区运行时的数据结构"></a>通过静态的字符流转换方法区运行时的数据结构</h4><h4 id="在内存中生成一个代表该类的对象，作为方法区数据访问接口"><a href="#在内存中生成一个代表该类的对象，作为方法区数据访问接口" class="headerlink" title="在内存中生成一个代表该类的对象，作为方法区数据访问接口"></a>在内存中生成一个代表该类的对象，作为方法区数据访问接口</h4><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><h5 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h5><h5 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h5><h5 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h5><h5 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h5><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。</p>
<p>对于该阶段有以下几点需要注意：</p>
<p>1.这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。<br>2.这里所设置的初始值”通常情况”下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了public static int value=111 ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会复制）。特殊情况：比如给 value 变量加上了 fianl 关键字public static final int value=111 ，那么准备阶段 value 的值就被复制为 111。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。</p>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构造器 <clinit> ()方法的过程。</clinit></p>
<p>对于<clinit>（） 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <clinit>（） 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。</clinit></clinit></p>
<h4 id="五种情况必须对类初始化"><a href="#五种情况必须对类初始化" class="headerlink" title="五种情况必须对类初始化"></a>五种情况必须对类初始化</h4><p>1.当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。</p>
<p>2.使用 java.lang.reflect 包的方法对类进行反射调用时 ，如果类没初始化，需要触发其初始化。</p>
<p>3.初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</p>
<p>4.当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。</p>
<p>5.当使用 JDK1.7 的动态动态语言时，如果一个 MethodHandle 实例的最后解析结构为 REF_getStatic、REF_putStatic、REF_invokeStatic、的方法句柄，并且这个句柄没有初始化，则需要先触发器初始化。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>JVM 中内置了三个重要的ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader：</p>
<h3 id="BootstrapClassLoader"><a href="#BootstrapClassLoader" class="headerlink" title="BootstrapClassLoader"></a>BootstrapClassLoader</h3><p>1、BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由C++实现，负责加载 %JAVA_HOME%/lib目录下的jar包和类或者或被 -Xbootclasspath参数指定的路径中的所有类。</p>
<h3 id="ExtensionClassLoader"><a href="#ExtensionClassLoader" class="headerlink" title="ExtensionClassLoader"></a>ExtensionClassLoader</h3><p>2、ExtensionClassLoader(扩展类加载器) ：主要负责加载目录 %JRE_HOME%/lib/ext 目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。</p>
<h3 id="AppClassLoader"><a href="#AppClassLoader" class="headerlink" title="AppClassLoader"></a>AppClassLoader</h3><p>3、AppClassLoader(应用程序类加载器) :面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 双亲委派模型 。</p>
<p>即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。</p>
<p>当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。</p>
<h4 id="双亲委派的好处"><a href="#双亲委派的好处" class="headerlink" title="双亲委派的好处"></a>双亲委派的好处</h4><p>1.双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载<br>（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。）</p>
<p>2.如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.jpg" alt="Beny">
            
              <p class="site-author-name" itemprop="name">Beny</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">71</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/1105397915" title="1105397915 &rarr; 1105397915"><i class="fa fa-fw fa-qq"></i>1105397915</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/benyzheng" title="GitHub &rarr; https://github.com/benyzheng" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/zhengbeny@qq.com" title="zhengbeny@qq.com &rarr; zhengbeny@qq.com"><i class="fa fa-fw fa-envelope"></i>zhengbeny@qq.com</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Beny</span>

  

  
</div>








<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共193.4k字</span>
</div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/libs/jquery/index.js?v=2.1.3"></script>

  
  <script src="/libs/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/libs/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>



  

  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  
  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="/js/src/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: 'oaY0uDqkCsuX94AxTtnV6scO-gzGzoHsz',
    appKey: 'HKU5SJPAd8KyYqk6Q8fdArL5',
    placeholder: '写了评论, offer还会远吗? ----记得填写邮箱哦~如果可以填写你的网站互相参考就更好啦',
    avatar: 'retro',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn'
  });
  //增加以下六行代码去除 power by valine
    var infoEle = document.querySelector('#comments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0){
      infoEle.childNodes.forEach(function(item) {
        item.parentNode.removeChild(item);
      });
    }
</script>





  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  

  

  

  

<!-- 页面点击小红心 -->
<!-- <script type="text/javascript" src="/js/src/click.js"></script>-->
</body>
</html>
