<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/libs/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/libs/pace/pace-theme-flash.min.css?v=1.0.2">


















  
  
  
  

  
    
    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Monda:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|Monda:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext">
  






<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_small.ico?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.0',
    sidebar: {"position":"left","display":"hide","offset":12,"onmobile":true,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Beny&#39;s blog">
<meta property="og:url" content="https://benyzheng.github.io/page/7/index.html">
<meta property="og:site_name" content="Beny&#39;s blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Beny&#39;s blog">





  
  
  <link rel="canonical" href="https://benyzheng.github.io/page/7/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Beny's blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Beny's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Nothing worth having comes easy.</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">15</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">74</span></a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

<a href="https://github.com/bengzheng" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/java集合类/集合类之List/集合类之List/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/java集合类/集合类之List/集合类之List/" class="post-title-link" itemprop="url">集合类之List</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 23:54:22" itemprop="dateModified" datetime="2019-10-06T23:54:22+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T23:54:22+08:00" content="2019-10-06">
                2019-10-06 23:54:22
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/集合框架/" itemprop="url" rel="index"><span itemprop="name">集合框架</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/java集合类/集合类之List/集合类之List/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/java集合类/集合类之List/集合类之List/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="集合类之List"><a href="#集合类之List" class="headerlink" title="集合类之List"></a>集合类之List</h1><p>List接口扩展自Collection，定义一个允许重复的有序集合，从List接口中的方法来看，List接口主要是增加了面向位置的操作，允许在指定位置上操作元素，同时增加了一个能够双向遍历线性表的新列表迭代器ListIterator。List接口的两个重要的具体实现类，也是我们可能最常用的类，ArrayList和LinkedList。</p>
<p><img src="/2019/05/26/java集合类/集合类之List/集合类之List/集合框架体系图.jpg" alt="集合框架体系图"></p>
<h3 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1.ArrayList"></a>1.ArrayList</h3><p>它是用数组存储元素的，这个数组可以动态创建，如果元素个数超过了数组的容量，那么就创建一个更大的新数组（通过移位运算符&gt;&gt;1扩大1倍再加上自己原本的容量即扩充1.5倍），并将当前数组中的所有元素都复制到新数组中。假设第一次是集合没有任何元素，下面以插入一个元素为例看看源码的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、找到add()实现方法。</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="number">2</span>、此方法主要是确定将要创建的数组大小。</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<span class="comment">//取出两个较大的容量</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;<span class="comment">//记录了结构性改变的次数。结构性改变指的是那些修改了列表大小的操作，在迭代过程中可能会造成错误的结果。</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="number">3</span>、最后是创建数组，可以明显的看到先是确定了添加元素后的大小之后将元素复制到新数组中。</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//1.5倍扩容</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList遍历三种方法</p>
<p>1、通过迭代器Iterator()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator iter = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(iter.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、随机访问，通过索引值去遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = list.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) </span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(list.get(i));        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、for循环遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String str:list)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">　　 &#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList常见问题</p>
<p>1、ArrayList如何实现自动增加</p>
<p>当试图在arraylist中增加一个对象的时候，Java会去检查arraylist，以确保已存在的数组中有足够的容量来存储这个新的对象。如果没有足够容量的话，那么就会新建一个长度更长的数组，旧的数组就会使用Arrays.copyOf方法被复制到新的数组中去，现有的数组引用指向了新的数组。</p>
<p>2、当传递ArrayList到某个方法中，或者某个方法返回ArrayList，什么时候要考虑安全隐患？如何修复安全违规这个问题呢？</p>
<p>当array被当做参数传递到某个方法中，如果array在没有被复制的情况下直接被分配给了成员变量，那么就可能发生这种情况，即当原始的数组被调用的方法改变的时候，传递到这个方法中的数组也会改变。</p>
<p><img src="/2019/05/26/java集合类/集合类之List/集合类之List/arrayList安全隐患.png" alt="arrayList安全隐患"></p>
<p>3、什么情况下你会使用ArrayList？什么时候你会选择LinkedList？</p>
<p>多数情况下，当你遇到访问元素比插入或者是删除元素更加频繁的时候，你应该使用ArrayList。另外一方面，当你在某个特别的索引中，插入或者是删除元素更加频繁，或者你根本就不需要访问元素的时候，你会选择LinkedList。这里的主要原因是，在ArrayList中访问元素的最糟糕的时间复杂度是”1″，而在LinkedList中可能就是”n”了。在ArrayList中增加或者删除某个元素，通常会调用System.arraycopy方法，这是一种极为消耗资源的操作，因此，在频繁的插入或者是删除元素的情况下，LinkedList的性能会更加好一点。</p>
<p>System.arraycopy方法消耗资源原因：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</span><br><span class="line">代码解释:</span><br><span class="line">　　Object src : 原数组</span><br><span class="line">   int srcPos : 从元数据的起始位置开始</span><br><span class="line">　　Object dest : 目标数组</span><br><span class="line">　　int destPos : 目标数组的开始起始位置</span><br><span class="line">　　int length  : 要copy的数组的长度</span><br><span class="line"></span><br><span class="line">我们使用System.arraycopy进行转换(copy)</span><br><span class="line"></span><br><span class="line">System.arrayCopy(srcBytes,0,destBytes ,0,5)</span><br><span class="line">上面这段代码就是 : 创建一个一维空数组,数组的总长度为 12位,然后将srcBytes源数组中 从0位 到 第5位之间的数值 copy 到 destBytes目标数组中,在目标数组的第0位开始放置.</span><br><span class="line">那么这行代码的运行效果应该是 2,4,0,0,0,</span><br><span class="line"></span><br><span class="line">增加或者删除都要进行一次copy，消耗资源多。</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/java集合类/集合类之List/集合类之List/arraylist增加.jpg" alt="arraylist增加"></p>
<p><img src="/2019/05/26/java集合类/集合类之List/集合类之List/arraylist删除.jpg" alt="arraylist删除"></p>
<p>4、如何复制某个ArrayList到另一个ArrayList中去？写出你的代码？</p>
<p>下面就是把某个ArrayList复制到另一个ArrayList中去的几种技术：</p>
<ol>
<li>使用clone()方法，比如ArrayList newArray = oldArray.clone();</li>
<li>使用ArrayList构造方法，比如：ArrayList myObject = new ArrayList(myTempObject);</li>
<li>使用Collection的copy方法。</li>
</ol>
<p>注意1和2是浅拷贝(shallow copy)。</p>
<p>浅拷贝和深拷贝区别：</p>
<p>| 浅拷贝：只复制引用，另一处修改，你当下的对象也会修改。         </p>
<p>| 深拷贝：引用对象的值等信息，复制一份一样的。</p>
<p>浅拷贝—能复制变量，如果对象内还有对象，则只能复制对象的地址（指针指向同一个内存空间）</p>
<p>深拷贝—能复制变量，也能复制当前对象的内部对象</p>
<p>利用序列化实现深拷贝</p>
<p>把对象写到流里的过程是序列化过程（Serialization），而把对象从流中读出来的过程则叫做反序列化过程（Deserialization）。</p>
<p>在Java语言里深复制一个对象，常常可以先使对象实现Serializable接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。</p>
<h3 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2.LinkedList"></a>2.LinkedList</h3><p><img src="/2019/05/26/java集合类/集合类之List/集合类之List/LinkedList结构图.png" alt="LinkedList结构图"></p>
<p>1、继承了AbstractSequentialList抽象类：在遍历LinkedList的时候，官方更推荐使用顺序访问，也就是使用我们的迭代器。（因为LinkedList底层是通过一个双向链表来实现的）（虽然LinkedList也提供了get（int index）方法，但是底层的实现是：每次调用get（int index）方法的时候，都需要从链表的头部或者尾部进行遍历，每一的遍历时间复杂度是O(index)，而相对比ArrayList的底层实现，每次遍历的时间复杂度都是O(1)。所以不推荐通过get（int index）遍历LinkedList。</p>
<p>至于上面的说从链表的头部后尾部进行遍历：官方源码对遍历进行了优化：通过判断索引index更靠近链表的头部还是尾部来选择遍历的方向）（所以这里遍历LinkedList推荐使用迭代器）。</p>
<p>2、实现了List接口。（提供List接口中所有方法的实现）<br>实现了Cloneable接口，它支持克隆（浅克隆），底层实现：LinkedList节点并没有被克隆，只是通过Object的clone（）方法得到的Object对象强制转化为了LinkedList,然后把它内部的实例域都置空，然后把被拷贝的LinkedList节点中的每一个值都拷贝到clone中。</p>
<p>3、实现了Deque接口。实现了Deque所有的可选的操作。</p>
<p>4、实现了Serializable接口。表明它支持序列化。（和ArrayList一样，底层都提供了两个方法：readObject（ObjectInputStream o）、writeObject（ObjectOutputStream o），用于实现序列化，底层只序列化节点的个数和节点的值）</p>
<p>底层重要方法分析：</p>
<p><strong>addAll(int index, Collection）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先调用一下空的构造器。</span></span><br><span class="line"><span class="comment">//然后调用addAll(c)方法。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过调用addAll(int index, Collection&lt;? extends E&gt; c) 完成集合的添加。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//几乎所有的涉及到在指定位置添加或者删除或修改操作都需要判断传进来的参数是否合法。</span></span><br><span class="line"><span class="comment">// checkPositionIndex(index)方法就起这个作用。  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"><span class="comment">//先把集合转化为数组，然后为该数组添加一个新的引用（Objext[] a）。</span></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line"><span class="comment">//新建一个变量存储数组的长度。</span></span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line"><span class="comment">//如果待添加的集合为空，直接返回，无需进行后面的步骤。后面都是用来把集合中的元素添加到</span></span><br><span class="line"><span class="comment">//LinkedList中。</span></span><br><span class="line">        <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//Node&lt;E&gt; succ：指代待添加节点的位置。</span></span><br><span class="line"><span class="comment">//Node&lt;E&gt; pred：指代待添加节点的前一个节点。</span></span><br><span class="line"><span class="comment">//下面的代码是依据新添加的元素的位置分为两个分支：</span></span><br><span class="line"><span class="comment">//①新添加的元素的位置位于LinkedList最后一个元素的后面。</span></span><br><span class="line"><span class="comment">//新添加的元素的位置位于LinkedList中。</span></span><br><span class="line"><span class="comment">//如果index==size;说明此时需要添加LinkedList中的集合中的每一个元素都是在LinkedList</span></span><br><span class="line"><span class="comment">//最后面。所以把succ设置为空，pred指向尾节点。</span></span><br><span class="line"><span class="comment">//否则的话succ指向插入待插入位置的节点。这里用到了node（int index）方法，这个方法</span></span><br><span class="line"><span class="comment">//后面会详细分析，这里只需要知道该方法返回对应索引位置上的Node（节点）。pred指向succ节点的前一个节点。</span></span><br><span class="line">        Node&lt;E&gt; pred, succ;</span><br><span class="line">        <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">            succ = <span class="keyword">null</span>;</span><br><span class="line">            pred = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            succ = node(index);</span><br><span class="line">            pred = succ.prev;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//接着遍历数组中的每个元素。在每次遍历的时候，都新建一个节点，该节点的值存储数组a中遍历</span></span><br><span class="line"><span class="comment">//的值，该节点的prev用来存储pred节点，next设置为空。接着判断一下该节点的前一个节点是否为</span></span><br><span class="line"><span class="comment">//空，如果为空的话，则把当前节点设置为头节点。否则的话就把当前节点的前一个节点的next值</span></span><br><span class="line"><span class="comment">//设置为当前节点。最后把pred指向当前节点，以便后续新节点的添加。</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">            Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                first = newNode;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = newNode;</span><br><span class="line">            pred = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//这里仍然和上面一样，分两种情况对待：</span></span><br><span class="line"><span class="comment">//①当succ==null（也就是新添加的节点位于LinkedList集合的最后一个元素的后面），</span></span><br><span class="line"><span class="comment">//通过遍历上面的a的所有元素，此时pred指向的是LinkedList中的最后一个元素，所以把</span></span><br><span class="line"><span class="comment">//last指向pred指向的节点。</span></span><br><span class="line"><span class="comment">//当不为空的时候，表明在LinkedList集合中添加的元素，需要把pred的next指向succ上，</span></span><br><span class="line"><span class="comment">//succ的prev指向pred。</span></span><br><span class="line"><span class="comment">//最后把集合的大小设置为新的大小。</span></span><br><span class="line"><span class="comment">//modCount（修改的次数）自增。</span></span><br><span class="line">        <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = pred;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pred.next = succ;</span><br><span class="line">            succ.prev = pred;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size += numNew;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>虽然是增加一个集合的元素，但是modCount只增加了一次</p>
<p><strong>将LinkedList写入到流中。（也就是把LinkedList状态保存到流中）（序列化）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Write out any hidden serialization magic</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next)</span><br><span class="line">        s.writeObject(x.item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>从流中把LinkedList读取出来（读取流，拼装成LinkedList）（反序列化）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// Read in any hidden serialization magic</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size</span></span><br><span class="line">    <span class="keyword">int</span> size = s.readInt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        linkLast((E)s.readObject());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>LinkedList提供了两种迭代器，一种是返回Iterator，另一种返回ListIterator。</strong></p>
<p><strong>①返回ListIterator迭代器：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>②返回Iterator迭代器：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DescendingIterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/数据结构/1 算法的复杂度/算法复杂度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/数据结构/1 算法的复杂度/算法复杂度/" class="post-title-link" itemprop="url">算法复杂度</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 22:10:45" itemprop="dateModified" datetime="2019-10-06T22:10:45+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T22:10:45+08:00" content="2019-10-06">
                2019-10-06 22:10:45
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/数据结构/1 算法的复杂度/算法复杂度/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/数据结构/1 算法的复杂度/算法复杂度/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p>算法是对问题求解步骤的描述，通过有限序列的指令来实现</p>
<p>五大特征</p>
<ul>
<li>有穷性：有限步之后结束</li>
<li>确定性：不存在二义性</li>
<li>可行性</li>
<li>输入</li>
<li>输出</li>
</ul>
<h6 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h6><p>用来衡量算法随着问题规模增大，算法执行时间的增大的快慢</p>
<p>时间复杂度是问题规模的函数：T(n)</p>
<p>T(n)=O(f(n))，大O记法</p>
<p>计算方法： 算法时间增长最快的那个函数项，把它的系数改为1</p>
<h6 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h6><ul>
<li>用来衡量算法随问题规模增大，算法所需空间的增长的快慢</li>
<li>是问题规模的函数：S(n)=O(g(n))</li>
</ul>
<p>常见的时间复杂度大小关系</p>
<p>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n2)&lt;O(n3)&lt;O(2n)</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/数据结构/2 线性表/线性表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/数据结构/2 线性表/线性表/" class="post-title-link" itemprop="url">线性表</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 22:13:24" itemprop="dateModified" datetime="2019-10-06T22:13:24+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T22:13:24+08:00" content="2019-10-06">
                2019-10-06 22:13:24
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/数据结构/2 线性表/线性表/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/数据结构/2 线性表/线性表/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p>线性表是具有相同数据类型的n(n&gt;=0)个数据元素的有限序列</p>
<p>线性表的顺序存储是用一组<strong>地址连续</strong>的存储单元，依次存储线性表中的数据元素，顺序存储的线性表也叫顺序表</p>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/顺序表的存储结构.png" alt></p>
<p>静态建表：</p>
<ul>
<li>存储空间的起始位置</li>
<li>顺序表最大存储容量</li>
<li>顺序表当前的长度</li>
</ul>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/顺序表结构体.png" alt></p>
<p>数组是静态分配的（大小固定）</p>
<p>其实存储空间（数组）还可以动态分配，也就是存储数组的空间是在程序执行过程中通过动态分配语句来分配的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *data;<span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize,length;<span class="comment">//数组的最大容量和当前个数</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">动态分配语句</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 100</span></span><br><span class="line">SeqList L;</span><br><span class="line">L.data=(ElemType*)<span class="built_in">malloc</span>(sezeof(ElemType)*InitSize);</span><br></pre></td></tr></table></figure>
<p>动态分配并不是链式存储，同样还是属于顺序存储结构，只是分配的空间大小可以在运行时决定</p>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/顺序存储特点总结.png" alt></p>
<h5 id="顺序表的操作"><a href="#顺序表的操作" class="headerlink" title="顺序表的操作"></a>顺序表的操作</h5><h6 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在顺序表L的第i（1&lt;=i&lt;=L.length）个位置插入新元素e。如果i的输入不合法，则返回false,表示插入失败；否则，将顺序表的第i个元素以及其后的所有元素右移一个位置，腾出一个空位置插入新元素e，顺序表长度增加1，插入成功，返回true</span><br><span class="line"></span><br><span class="line">bool ListInsert(SqlList &amp;L,int i,ElemType e)&#123;</span><br><span class="line">	if(i&lt;1||i&gt;L.length+1)//判断i的范围是否有效</span><br><span class="line">	return false;</span><br><span class="line">	if(L.length&gt;=MaxSize)//当前的存储空间已满，不能插入</span><br><span class="line">		return false;</span><br><span class="line">	for(int j=L.length;j&gt;=i;j--)//将第i个元素及之后的元素后移</span><br><span class="line">		L.data[j]=L.data[j-1];</span><br><span class="line">	L.data[i-1]=e;</span><br><span class="line">	L.lengt++;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/顺序表插入复杂度.png" alt></p>
<h6 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">删除顺序表L中第i（1&lt;=i&lt;=L.length）个位置的元素，成功则返回true，并将被删除的元素用应用变量e返回；否则返回false</span><br><span class="line"></span><br><span class="line">bool ListDelete(SqList &amp;L,int i,ElemType &amp;e)&#123;</span><br><span class="line">	if(i&lt;1||i&gt;L.length+1)//判断i的范围是否有效</span><br><span class="line">		return false;</span><br><span class="line">	e=L.data[i-1];</span><br><span class="line">	for(int j=i;j&lt;L.length;j++)</span><br><span class="line">		L.data[j-1]=L.data[j];</span><br><span class="line">	L.length--;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/顺序表删除复杂度.png" alt></p>
<p>优点：</p>
<ul>
<li>存储密度大，不需要为表中元素之间的逻辑关系增加额外存储空间</li>
<li>随机存取：可以快速存取表中任一位置的元素</li>
</ul>
<p>缺点：</p>
<ul>
<li>插入和删除需要移动大量元素</li>
<li>对存储空间要求高，会产生存储空间的碎片</li>
</ul>
<h5 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h5><p> 线性表的链式存储是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立起数据元素之间的线性关系，每个链表结点，除了存放元素自身的信息之外，还需要存放一个指向其后继的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;<span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure>
<p>通常用“头指针”来标识一个单链表，例如LinkList L，那么头指针L代表一个单链表</p>
<p>单链表第一个结点之前附加一个结点，称为头结点，头结点的数据域可以不设任何信息，也可以记录表长等相关信息。头结点的指针域指向线性表的第一个元素结点。</p>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/头指针.png" alt></p>
<h5 id="单链表操作"><a href="#单链表操作" class="headerlink" title="单链表操作"></a>单链表操作</h5><h6 id="头插法建立单链表"><a href="#头插法建立单链表" class="headerlink" title="头插法建立单链表"></a>头插法建立单链表</h6><p>建立新的结点分配内存空间，将新结点插入当前链表的表头</p>
<p> <img src="/2019/05/26/数据结构/2 线性表/线性表/头插法建立链表.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认有空的头结点</span></span><br><span class="line"><span class="function">LinkList <span class="title">CreatList1</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">	<span class="keyword">int</span> x;<span class="comment">//存储插入结点的数据的值</span></span><br><span class="line">	L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建头结点</span></span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;<span class="comment">//初始化为空链表</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);<span class="comment">//输入结点的值</span></span><br><span class="line">	<span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;<span class="comment">//输入9999表示结束</span></span><br><span class="line">		s=(LNode*)<span class="built_in">malloc</span>(sizeif(LNode));<span class="comment">//创建新结点</span></span><br><span class="line">		s-&gt;data=x;<span class="comment">//对新结点的数据域赋值</span></span><br><span class="line">		s-&gt;next=L-&gt;next;<span class="comment">//新结点的后继指向第一个结点</span></span><br><span class="line">		L-&gt;next=s;<span class="comment">//头结点的后继指向新结点</span></span><br><span class="line">        sanf(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="尾插法建立单链表"><a href="#尾插法建立单链表" class="headerlink" title="尾插法建立单链表"></a>尾插法建立单链表</h6><p>建立新的结点分配内存空间，将新的结点插入到当前链表的表尾</p>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/尾插法建立链表.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">CreatList2</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x;<span class="comment">//存储插入结点的数据的值</span></span><br><span class="line">	L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建头结点</span></span><br><span class="line">    LNode *s,*r=L;<span class="comment">//r为表尾指针，指向表尾</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);<span class="comment">//输入结点的值</span></span><br><span class="line">	<span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;<span class="comment">//输入9999表示结束</span></span><br><span class="line">		s=(LNode*)<span class="built_in">malloc</span>(sizeif(LNode));<span class="comment">//创建新结点</span></span><br><span class="line">		s-&gt;data=x;<span class="comment">//对新结点的数据域赋值</span></span><br><span class="line">		r-&gt;next=s;</span><br><span class="line">        r=s;</span><br><span class="line">        sanf(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">	&#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="按序号查找结点"><a href="#按序号查找结点" class="headerlink" title="按序号查找结点"></a>按序号查找结点</h6><p>在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">GEtElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">1</span>;<span class="comment">//计数，初始为1</span></span><br><span class="line">	LNode *p=L-&gt;next;<span class="comment">//第一个结点指针赋给p</span></span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">return</span> L;<span class="comment">//若i等于0，返回头结点</span></span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;j&lt;i)&#123;<span class="comment">//从第一个结点开始找，查找第i个结点</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按值查找结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">Locate</span><span class="params">(LinkList L,ElemType e)</span></span>&#123;</span><br><span class="line">	LNode *p=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=e)&#123;<span class="comment">//从第一个结点开始找</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="插入新结点"><a href="#插入新结点" class="headerlink" title="插入新结点"></a>插入新结点</h6><p>插入操作是将值为x的新结点插入到单链表的第i个位置上。先检查插入位置和合法性，然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点</p>
<p>算法思路：</p>
<ol>
<li>取指向插入位置的前驱结点的指针p=GetElem(L,i-1);</li>
<li>取新结点<em>s的指针域指向 </em>p的后继结点s-&gt;next=p-&gt;next</li>
<li>令结点<em>p的指针域指向新插入的结点 </em>s p-&gt;next=s;</li>
</ol>
<h6 id="删除一个结点"><a href="#删除一个结点" class="headerlink" title="删除一个结点"></a>删除一个结点</h6><p>删除操作是将单链表的第i个结点删除，先检查删除位置的合法性，然后查找表中第i-1个结点，即被删除结点的前驱结点，再将其删除</p>
<p>算法思路：</p>
<ol>
<li>取指向删除位置的前驱结点的指针 p=GetElem(L,i-1);</li>
<li>取指向删除位置的指针 q=p-&gt;next;</li>
<li>p指向结点的后继指向被删除结点的后继 p-&gt;next=q-&gt;next</li>
</ol>
<h5 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">    structLNode *node;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span><span class="comment">//前驱和后继指针</span></span><br><span class="line">&#125;DNode,*DLinkList;</span><br></pre></td></tr></table></figure>
<h6 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h6><ol>
<li>s-&gt;next=p-&gt;next</li>
<li>p-next-&gt;prior=s</li>
<li>s-&gt;prior=p</li>
<li>p-&gt;next=s</li>
</ol>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/双链表插入.png" alt></p>
<h6 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h6><ol>
<li>p-&gt;next=q-&gt;next</li>
<li>q-&gt;next-&gt;prior=p</li>
<li>free(q)</li>
</ol>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/双链表删除.png" alt></p>
<h5 id="循环链表-amp-静态链表"><a href="#循环链表-amp-静态链表" class="headerlink" title="循环链表&amp;静态链表"></a>循环链表&amp;静态链表</h5><p>循环单链表：循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环</p>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/循环单链表结构.png" alt></p>
<p>循环单链表的判空条件不是头结点的后继指针是否为空，而是它是否等于头指针</p>
<p>循环双链表</p>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/循环双链表结构.png" alt></p>
<p>静态链表</p>
<p>使用数组来描述线性表的链式存储结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50<span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType<span class="comment">//静态链表的数据类型假定为int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType data;<span class="comment">//数据域，存储数据元素</span></span><br><span class="line">	<span class="keyword">int</span> next;<span class="comment">//指针域，下一个元素的数组下标</span></span><br><span class="line">&#125;SLinkList[MaxSize];</span><br></pre></td></tr></table></figure>
<p>数组第一个元素不存储数据，它的指针域存储第一个元素所在的数组下标。</p>
<p>链表最后一个元素的指针域值为-1</p>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/静态链表结构.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/数据结构/3 栈和队列/栈和队列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/数据结构/3 栈和队列/栈和队列/" class="post-title-link" itemprop="url">栈和队列</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 22:14:39" itemprop="dateModified" datetime="2019-10-06T22:14:39+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T22:14:39+08:00" content="2019-10-06">
                2019-10-06 22:14:39
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/数据结构/3 栈和队列/栈和队列/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/数据结构/3 栈和队列/栈和队列/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>只允许在一端进行插入或删除操作的线性表</p>
<p>栈顶：栈中允许进行插入和删除的哪一端</p>
<p>栈底：固定的，不允许进行插入和删除的另一端</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	Elemtype data[MaxSize];<span class="comment">//存放栈中的元素</span></span><br><span class="line">	<span class="keyword">int</span> top;<span class="comment">//栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>
<ul>
<li>top值不能超过MaxSize</li>
<li>空栈的判定条件通常定为top==-1，满栈的判定条件通常为top==MaxSize-1，栈中数据元素个数为top+1</li>
</ul>
<h5 id="顺序栈的操作"><a href="#顺序栈的操作" class="headerlink" title="顺序栈的操作"></a>顺序栈的操作</h5><h6 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.data[++S.top]=x; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S.data[S.top--];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="获取栈顶元素"><a href="#获取栈顶元素" class="headerlink" title="获取栈顶元素"></a>获取栈顶元素</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h5><p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/共享栈.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype data[MaxSize];<span class="comment">//存放栈中的元素</span></span><br><span class="line">    <span class="keyword">int</span> top1;<span class="comment">//栈1栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> top2;<span class="comment">//栈2栈顶指针</span></span><br><span class="line">&#125;SqDoubleStack;</span><br></pre></td></tr></table></figure>
<h6 id="进栈-1"><a href="#进栈-1" class="headerlink" title="进栈"></a>进栈</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqDoubleStack &amp;S,ElemType x,<span class="keyword">int</span> stackNum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top1+<span class="number">1</span>==S.top2) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//栈满</span></span><br><span class="line">    <span class="keyword">if</span>(stackNum==<span class="number">1</span>) 			</span><br><span class="line">        S.data[++S.top1]=x;<span class="comment">//栈1有元素进栈</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stackNum==<span class="number">2</span>) S.data[--S.top2]=x;<span class="comment">//栈2有元素进栈</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h5><p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/链式栈结构.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">    Elemtype data;<span class="comment">//存放栈中的元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">next</span>//栈顶指针</span></span><br><span class="line"><span class="class">&#125;<span class="title">SNode</span>,*<span class="title">SLink</span>//链栈结点</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class"><span class="title">typedef</span> <span class="title">struct</span> <span class="title">LinkStack</span>&#123;</span></span><br><span class="line">	SLink top;<span class="comment">//栈顶指针</span></span><br><span class="line">	<span class="keyword">int</span> count;<span class="comment">//链栈结点数</span></span><br><span class="line">&#125;LinkStack</span><br></pre></td></tr></table></figure>
<ul>
<li>链栈没有栈满的情况</li>
<li>链栈空为top==null</li>
</ul>
<h6 id="进栈-2"><a href="#进栈-2" class="headerlink" title="进栈"></a>进栈</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(LinkStack *S,ElemType x)</span></span>&#123;</span><br><span class="line">    SLink p=(SLink)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SNode));<span class="comment">//给新元素分配空间</span></span><br><span class="line">    p-&gt;data=x;<span class="comment">//新元素的值</span></span><br><span class="line">    p-next=S-&gt;top;<span class="comment">//p的后继指向栈顶元素</span></span><br><span class="line">    S-&gt;top=p;<span class="comment">//栈顶指针指向新的元素</span></span><br><span class="line">    S-&gt;count++;<span class="comment">//栈中元素个数加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/链式栈进栈.png" alt></p>
<h6 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(LinkStack *S,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S-&gt;top-&gt;data;<span class="comment">//栈顶元素值</span></span><br><span class="line">    SLink p=S-&gt;top;<span class="comment">//辅助指针</span></span><br><span class="line">    S-&gt;top=S-&gt;top-&gt;next;<span class="comment">//栈顶指针后移</span></span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//释放被删除数据的存储空间</span></span><br><span class="line">    S-&gt;count--;<span class="comment">//栈中元素个数减一</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/链式栈出栈.png" alt></p>
<h5 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h5><h6 id="括号配对"><a href="#括号配对" class="headerlink" title="括号配对"></a>括号配对</h6><p>假设有两种括号，一种圆的()，一种方的[]，嵌套的顺序是任意的</p>
<p>算法思路：</p>
<p>若是左括号，入栈；若是右括号，出栈一个左括号判断是否与之匹配；检验到字符串尾，还要检查栈是否为空。只有栈空整个字符串才是括号匹配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> s;</span><br><span class="line">    InitStack(s);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);<span class="comment">//字符串长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> a=str[i];</span><br><span class="line">        <span class="keyword">switch</span>(a)&#123;</span><br><span class="line">        	<span class="keyword">case</span> <span class="string">'('</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'['</span>;</span><br><span class="line">                Push(s,a);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">')'</span>;</span><br><span class="line">                <span class="keyword">if</span>(Pop(s)!=<span class="string">'('</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//出栈顶，如果不匹配直接返回不合法</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">']'</span>;</span><br><span class="line">                <span class="keyword">if</span>(Pop(s)!=<span class="string">']'</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Empty(s)) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//匹配完所有括号最后要求栈中为空</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h6><p>从左到右，先乘除后加减，右括号先算括号</p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/表达式.png" alt></p>
<p>后缀表达式做法：</p>
<p>规则：从左到右扫描表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈然后跟这个符号进行运算，最后将结果进栈，直到最终获得结果</p>
<p> 如何将中缀表达式转换成后缀表达式（计算机也是用到栈取转换，下面是手动方法）</p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/中缀转后缀.png" alt></p>
<h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><p>递归最重要的是递归式和递归边界</p>
<p>使用递归求解n的阶乘</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//递归边界</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> n*F(n<span class="number">-1</span>);<span class="comment">//递归式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求斐波拉契数列的第n项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Fib(n<span class="number">-1</span>)+Fib(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/斐波拉契数列递归.png" alt></p>
<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>队列是只允许在一端进行插入，而在另一端进行删除的线性表</p>
<p>队头（Front）：允许删除的一端，队首</p>
<p>队尾（Rear）：允许插入的一端</p>
<h6 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h6><p>用数组实现队列，可以将队首放在数组下标为0的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];<span class="comment">//存放队列的元素</span></span><br><span class="line">    <span class="keyword">int</span> front,rear;<span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/队列假溢出.png" alt></p>
<h6 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h6><p>入队：rear=(rear+1)%MaxSize</p>
<p>出队：front=(front+1)%MaxSize</p>
<p>判断队列是空是满</p>
<ul>
<li>设置标志位flag，当flag=0且rear等于front时为队列空，当flag=1且rear等于front时为队列满（入队时flag等于1，出队时flag等于0）</li>
<li><strong>把front==rear仅作为队空的判定条件</strong>。当队列满的时候，令数组中仍然保留一个空余单元。认为这种情况就是队列满了</li>
</ul>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/循环队列队满判断.png" alt></p>
<p>队满关系</p>
<p>(rear+1)%MaxSize==front</p>
<p>队列中元素个数</p>
<p>(rear-front+MaxSize)%MaxSize</p>
<h6 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front) <span class="keyword">return</span> flase;<span class="comment">//队满</span></span><br><span class="line">    Q.data[Q.rear]=x;</span><br><span class="line">    Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//队空，报错</span></span><br><span class="line">	x=Q.data[Q.front];</span><br><span class="line">    Q.front=(Q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h5><p>队列的链式存储结构，其实就是线性表的单链表，只不过需要加点限制，只能表尾插入元素，表头删除元素</p>
<p>分别设置队头指针和队尾指针，队头指针指向头结点，队尾指针指向队尾结点</p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/链式队列.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//链式队列结点</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//链式队列</span></span><br><span class="line">    LinkNode *front,*rear;<span class="comment">//队头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>
<h6 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">    s=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=s;</span><br><span class="line">    Q.rear=s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/链式队列入队.png" alt></p>
<h6 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h6><p>出队就是头结点的后继结点出队，然后将头结点的后继改为它后面的结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//空队</span></span><br><span class="line">    p=Q.front-&gt;next;</span><br><span class="line">    x=p-&gt;data;</span><br><span class="line">    Q.front-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p) Q.rear=Q.front;<span class="comment">//若原队列中只有一个结点，删除后变空</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/链式队列出队.png" alt></p>
<h5 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h5><p>双端队列是指允许两端都可以进行入队和出队操作的队列</p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/双端队列结构.png" alt></p>
<h5 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h5><p>对于二维数组，两种映射方法：按行优先和按列优先</p>
<p>行优先</p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/行优先.png" alt></p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/行优先计算.png" alt></p>
<p>列优先</p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/列优先.png" alt></p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/列优先计算.png" alt></p>
<h6 id="矩阵的压缩存储"><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h6><p>对称矩阵</p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/对角矩阵.png" alt></p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/对角矩阵计算.png" alt></p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/对角矩阵计算2.png" alt></p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/对角矩阵计算3.png" alt></p>
<p>三角矩阵</p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/三角矩阵.png" alt></p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/三角矩阵计算.png" alt></p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/三角矩阵计算1.png" alt></p>
<p>三对角矩阵</p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/三对角矩阵.png" alt></p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/三对角矩阵2.png" alt></p>
<p>稀疏矩阵</p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/稀疏矩阵.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/数据结构/4 树和二叉树/树与二叉树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/" class="post-title-link" itemprop="url">树与二叉树</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 22:21:52" itemprop="dateModified" datetime="2019-10-06T22:21:52+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T22:21:52+08:00" content="2019-10-06">
                2019-10-06 22:21:52
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h3><p>一对多的树形结构</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树的结构定义.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树结点相关概念.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树结点相关概念2.png" alt></p>
<h5 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h5><ul>
<li>树中的结点等于所有结点的度数加1</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树的性质1.png" alt></p>
<ul>
<li>度为m的树中第i层上至多有m<sup>i-1</sup>个结点（i&gt;=1）</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树的性质2.png" alt></p>
<ul>
<li><p>高度为h的m叉树至多有（m<sup>h</sup>-1)/(m-1)个结点</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树的性质3.png" alt></p>
</li>
<li><p>具有n个结点的m叉树的最小高度为取上整[log<sub>m</sub>(n(m-1)+1)]</p>
</li>
</ul>
<p>解上一个方程的h即可</p>
<h5 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h5><h6 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h6><p>双亲表示法：用一组连续的存储空间存储树的结点，同时在每个结点中，用一个变量存储该结点的双亲结点在数组中的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//结点数据</span></span><br><span class="line">    <span class="keyword">int</span> parent;<span class="comment">//该结点双亲在数组的下标</span></span><br><span class="line">&#125;TNode;<span class="comment">//结点的数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    TNode nodes[MaxSize];<span class="comment">//结点数组</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//结点的数量</span></span><br><span class="line">&#125;Tree;<span class="comment">//结点双亲表示结构</span></span><br></pre></td></tr></table></figure>
<p>双亲表示法可以根据parent找到该结点的双亲结点，时间复杂度为O(1)。但如果找到某节点的孩子结点就需要遍历</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/顺序存储结构.png" alt></p>
<h6 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h6><p>孩子表示法：把每个结点的孩子结点排列起来存储成一个单链表。所以n个结点就有n个链表；如果时叶子结点，那这个结点的孩子单链表就是空的；然后n个单链表的头指针又存储在一个顺序表（数组）中。</p>
<p>需要设计两种结合结构类型：</p>
<ul>
<li>孩子链表的结点</li>
<li>每个孩子链表的表头结点（存在数组中）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> child;<span class="comment">//该孩子在表头数组的下标</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CNode</span> *<span class="title">next</span>;</span><span class="comment">//指向该结点的下一个孩子结点</span></span><br><span class="line">&#125;CNode,*Child;<span class="comment">//孩子结点数据结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype data;<span class="comment">//结点数据域</span></span><br><span class="line">    Child firstchild;<span class="comment">//指向该结点的第一个孩子结点</span></span><br><span class="line">&#125;TNode<span class="comment">//孩子结点的数据类型</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    TNode nodes[MaxSize];<span class="comment">//结点数据域</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//树中结点个数</span></span><br><span class="line">&#125;Tree;<span class="comment">//树的孩子表示结构</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/链式存储结构.png" alt></p>
<p>孩子兄弟表示法：要存储孩子结点和兄弟结点，就是设置两个指针，分别指向该结点的第一个孩子结点和该结点的兄弟结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//该结点的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">rightsib</span>//指向该结点的第一个孩子结点和该结点的右兄弟结点</span></span><br><span class="line"><span class="class">&#125;<span class="title">CSNode</span>;</span><span class="comment">//孩子兄弟结点数据类型</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/链式存储结构2.png" alt></p>
<h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><p>每个结点最多有两颗子树</p>
<p>左右子树有顺序</p>
<p>五种基本形态</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树五种形态.png" alt></p>
<h6 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/斜树.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/满二叉树.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/完全二叉树.png" alt></p>
<h5 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h5><ul>
<li>非空二叉树上叶子结点等于度为2的结点数加1</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树性质1.png" alt></p>
<ul>
<li>非空二叉树上第K层上至多有2<sup>k-1</sup>个结点（k&gt;=1）</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树性质2.png" alt></p>
<ul>
<li>高度为H的二叉树至多有2<sup>H</sup>-1个结点（H&gt;=1）</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树性质3.png" alt></p>
<ul>
<li>具有N个(N&gt;0)结点的完全二叉树的高度为上取整[log<sub>2</sub>(N+1)]或下取整[log<sub>2</sub>N]+1</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树性质4.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树性质5.png" alt></p>
<h5 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h5><h6 id="顺序存储结构-1"><a href="#顺序存储结构-1" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h6><p>二叉树的顺序存储结构就是用一组地址连续的存储单元依次自上而下，自左而右存储完全二叉树上的结点元素</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树顺序存储.png" alt></p>
<h6 id="链式存储结构-1"><a href="#链式存储结构-1" class="headerlink" title="链式存储结构"></a>链式存储结构</h6><p>二叉树每个结点最多两个孩子，所以设计二叉树的结点结构时考虑两个指针指向该结点的两个孩子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//指向该结点的左右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTNode;<span class="comment">//二叉树结点结构</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树链式存储结构.png" alt></p>
<h5 id="二叉树遍历-递归"><a href="#二叉树遍历-递归" class="headerlink" title="二叉树遍历(递归)"></a>二叉树遍历(递归)</h5><p>二叉树的遍历是指按某种次序依次访问树中的每个结点，使得每个结点均被访问一次，而且仅被访问一次</p>
<h6 id="递归先序遍历"><a href="#递归先序遍历" class="headerlink" title="递归先序遍历"></a>递归先序遍历</h6><p>操作过程：</p>
<ul>
<li>访问根结点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data)<span class="comment">//根节点</span></span><br><span class="line">        PreOrder(T-&gt;lchild);<span class="comment">//左子树</span></span><br><span class="line">        PreOrder(T-&gt;rchild);<span class="comment">//右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="递归中序遍历"><a href="#递归中序遍历" class="headerlink" title="递归中序遍历"></a>递归中序遍历</h6><p>操作过程：</p>
<ul>
<li>中序遍历左子树</li>
<li>访问根节点</li>
<li>中序遍历右子树</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="递归后序遍历"><a href="#递归后序遍历" class="headerlink" title="递归后序遍历"></a>递归后序遍历</h6><p>操作过程：</p>
<ul>
<li>后序遍历左子树</li>
<li>后序遍历右子树</li>
<li>访问根节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        PostOrder(T-&gt;lchild);</span><br><span class="line">        PostOrder(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉树遍历-非递归"><a href="#二叉树遍历-非递归" class="headerlink" title="二叉树遍历(非递归)"></a>二叉树遍历(非递归)</h5><h6 id="非递归先序遍历"><a href="#非递归先序遍历" class="headerlink" title="非递归先序遍历"></a>非递归先序遍历</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree b)</span></span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    BitTree p=b;<span class="comment">//工作指针p</span></span><br><span class="line">    <span class="keyword">while</span>(p || !IsEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,p-&gt;data);<span class="comment">//先序先遍历结点</span></span><br><span class="line">            Push(S,p);<span class="comment">//进栈保存</span></span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!IsEmpty(S))&#123;</span><br><span class="line">            p=Pop(S);</span><br><span class="line">            p=p-rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="非递归中序遍历"><a href="#非递归中序遍历" class="headerlink" title="非递归中序遍历"></a>非递归中序遍历</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree b)</span></span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    BitTree p=b;<span class="comment">//工作指针p</span></span><br><span class="line">    <span class="keyword">while</span>(p || !IsEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            Push(S,p);<span class="comment">//进栈保存</span></span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p=Pop(S);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,p-&gt;data);</span><br><span class="line">        p=p-rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="非递归后序遍历"><a href="#非递归后序遍历" class="headerlink" title="非递归后序遍历"></a>非递归后序遍历</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/非递归后续遍历.png" alt></p>
<h6 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h6><p>操作过程：</p>
<p>若树为空，则什么都不做直接返回；</p>
<p>否则从树的第一层开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问</p>
<p>出队-&gt;访问-&gt;左右孩子入队</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree b)</span></span>&#123;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q,b);<span class="comment">//根节点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,p);<span class="comment">//队头元素出队</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q,p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q,p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h5><p>二叉链表表示的二叉树存在大量空指针</p>
<p>N个结点的二叉树，每个结点都有指向左右孩子的结点指针，所以一共有2N个指针，而N个结点的二叉树一共有N-1个分支，也就是说存在2N-(N-1)=N+1个空指针。</p>
<p>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/线索二叉树.png" alt></p>
<p>对二叉树以某种次序遍历使其变为线索二叉树的过程叫做线索化。</p>
<p>如何区分指针是指向左孩子还是前驱，右孩子还是后继？</p>
<p>在二叉链表结点的结构基础上增加两个标志位ltag和rtag</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,*ThreadTree;<span class="comment">//线索链表</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/线索二叉树结构.png" alt></p>
<ul>
<li>ltag==0表示lchild指向该结点左孩子</li>
<li>ltag==1表示rchild指向该结点前驱</li>
<li>rtag==0表示rchild指向该结点右孩子</li>
<li>rtag==1表示指向该结点后继</li>
</ul>
<h6 id="构造线索二叉树"><a href="#构造线索二叉树" class="headerlink" title="构造线索二叉树"></a>构造线索二叉树</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/构造线索二叉树.png" alt></p>
<h6 id="遍历线索二叉树"><a href="#遍历线索二叉树" class="headerlink" title="遍历线索二叉树"></a>遍历线索二叉树</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/遍历线索二叉树.png" alt></p>
<h5 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h5><p>概念：</p>
<p>权：树中结点相关的数值</p>
<p>路径长度：从树中某个结点到另一个结点之间的分支数目（经过的边数）</p>
<p>带权路径长度：从树的根节点到任意结点的路径长度（经过的边数）与该结点上权值的乘积称为该结点的带权路径长度</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树的带权路径长度.png" alt></p>
<p>哈夫曼树：含有N个带权叶子结点的二叉树中，带有带权路径长度（WPL）最小的二叉树，也成为最优二叉树。</p>
<h6 id="设计哈夫曼树"><a href="#设计哈夫曼树" class="headerlink" title="设计哈夫曼树"></a>设计哈夫曼树</h6><ul>
<li>将这N个结点分别作为N颗仅含一个结点的二叉树，构成森林F</li>
<li>构造一个新结点，并从F中选取两颗根节点权值最小的树作为新结点的左右子树，并且将新结点的权值置为左右子树上根节点的权值之和</li>
<li>从F中删除刚才选出的两棵树，同时将新得到的树加入F中</li>
<li>重复步骤2和3，直至F中只剩下一棵树为止</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/构造哈夫曼树.png" alt></p>
<h6 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h6><p>左子树为0，右子树为1</p>
<p>哈夫曼编码性质</p>
<ul>
<li>哈夫曼编码是前缀编码</li>
<li>哈夫曼编码是最优前缀编码</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/哈夫曼编码.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/哈夫曼编码2.png" alt></p>
<h5 id="二叉树、树和森林"><a href="#二叉树、树和森林" class="headerlink" title="二叉树、树和森林"></a>二叉树、树和森林</h5><h6 id="树转化成二叉树"><a href="#树转化成二叉树" class="headerlink" title="树转化成二叉树"></a>树转化成二叉树</h6><p>用到一个孩子兄弟表示法（回归本章树的链式存储）</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树转二叉树1.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树转二叉树2.png" alt></p>
<h6 id="二叉树转树"><a href="#二叉树转树" class="headerlink" title="二叉树转树"></a>二叉树转树</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树转树.png" alt></p>
<h6 id="森林转二叉树"><a href="#森林转二叉树" class="headerlink" title="森林转二叉树"></a>森林转二叉树</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/森林转二叉树.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/森林转二叉树2.png" alt></p>
<h6 id="二叉树转森林"><a href="#二叉树转森林" class="headerlink" title="二叉树转森林"></a>二叉树转森林</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树转森林.png" alt></p>
<h6 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h6><p>树的先序遍历</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树的先序遍历.png" alt></p>
<p>树的后序遍历</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树的后序遍历.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树与二叉树先序后序遍历比较.png" alt></p>
<h6 id="森林遍历"><a href="#森林遍历" class="headerlink" title="森林遍历"></a>森林遍历</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/森林先序后序遍历.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/数据库/Redis/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/数据库/Redis/Redis/" class="post-title-link" itemprop="url">Redis</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 23:43:15" itemprop="dateModified" datetime="2019-10-06T23:43:15+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T23:43:15+08:00" content="2019-10-06">
                2019-10-06 23:43:15
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/数据库/Redis/Redis/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/数据库/Redis/Redis/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p>NoSQL = not only SQL</p>
<p>非关系型数据库</p>
<p>为什么需要NoSQL</p>
<ul>
<li>High Performance - 高并发读写</li>
<li>Huge Storage - 海量数据的高效率存储和访问</li>
<li>HIgh Scalability&amp;&amp;High Availability - 高可扩展性和高可用性</li>
</ul>
<p>NoSQL数据库的四大分类</p>
<ul>
<li>键值对(key-value)存储</li>
<li>列存储</li>
<li>文档数据库</li>
<li>图形数据库</li>
</ul>
<p><img src="/2019/05/26/数据库/Redis/Redis/NoSQL四种类型比较.png" alt></p>
<p>NoSQL的特点：</p>
<ul>
<li>易扩展</li>
<li>灵活的数据模型</li>
<li>大数据量</li>
<li>高可用</li>
</ul>
<h3 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h3><p>支持的键值数据类型：</p>
<ul>
<li>字符串类型</li>
<li>散列类型</li>
<li>列表类型</li>
<li>集合类型</li>
<li>有序集合类型</li>
</ul>
<p>读每秒11万次，写每秒8万次</p>
<p>Redis应用场景：</p>
<ul>
<li>缓存</li>
<li>任务队列</li>
<li>应用排行榜</li>
<li>网站访问统计</li>
<li>数据过期处理</li>
<li>分布式集群架构中的session分离</li>
</ul>
<h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><p>Jedis是Redis官方首选的java客户端开发包</p>
<h3 id="Redis的数据结构"><a href="#Redis的数据结构" class="headerlink" title="Redis的数据结构"></a>Redis的数据结构</h3><ul>
<li>字符串（String）</li>
<li>哈希（hash）</li>
<li>字符串列表（list）</li>
<li>字符串集合（set）</li>
<li>有序字符串集合（sorted set）</li>
</ul>
<h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><p>需要持久化的原因：Redis将数据存在内存中，容易丢失数据，需要将数据存进硬盘，称为持久化</p>
<p>两种持久化的方式</p>
<ul>
<li>RDB方式</li>
<li>AOF方式</li>
</ul>
<p>持久化的四种方式：</p>
<p>RDB方式：默认支持、不需要进行配置，在指定的时间间隔内，将内存中的数据集快照写入硬盘</p>
<p>AOF方式：以日记的方式记录服务器处理的每一个操作，当重启时，会读取文件进行重建数据库，保证启动时数据库中的数据的完整</p>
<p>无持久化：通过日志禁止数据库持久化的功能</p>
<p>同时使用RDB方式和AOF方式</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/数据结构/5 图/图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/数据结构/5 图/图/" class="post-title-link" itemprop="url">图</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 22:22:43" itemprop="dateModified" datetime="2019-10-06T22:22:43+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T22:22:43+08:00" content="2019-10-06">
                2019-10-06 22:22:43
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/数据结构/5 图/图/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/数据结构/5 图/图/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>图G由顶点集V和边集E组成，记为G=(V,E)</p>
<p><img src="/2019/05/26/数据结构/5 图/图/1 图的概念1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/2 图的概念2.png" alt></p>
<h6 id="简单图和多重图"><a href="#简单图和多重图" class="headerlink" title="简单图和多重图"></a>简单图和多重图</h6><p>简单图</p>
<ul>
<li>不存在顶点到自身的边</li>
<li>同一条边不重复出现</li>
</ul>
<p>多重图</p>
<p>若图G中某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联</p>
<p><img src="/2019/05/26/数据结构/5 图/图/3 简单图和多重图.png" alt></p>
<h6 id="完全图"><a href="#完全图" class="headerlink" title="完全图"></a>完全图</h6><p>无向完全图：如果任意两个顶点之间都存在边</p>
<p>有向完全图：如果任意两个顶点之间都存在方向相反的两条弧</p>
<p><img src="/2019/05/26/数据结构/5 图/图/4 完全图.png" alt></p>
<h6 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h6><p><img src="/2019/05/26/数据结构/5 图/图/5 子图.png" alt></p>
<h6 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h6><p><img src="/2019/05/26/数据结构/5 图/图/6 连通图.png" alt></p>
<p>强连通</p>
<p><img src="/2019/05/26/数据结构/5 图/图/7 强连通分量.png" alt></p>
<h6 id="连通图的生成树"><a href="#连通图的生成树" class="headerlink" title="连通图的生成树"></a>连通图的生成树</h6><p><img src="/2019/05/26/数据结构/5 图/图/8 连通图生成树.png" alt></p>
<h6 id="度"><a href="#度" class="headerlink" title="度"></a>度</h6><p><img src="/2019/05/26/数据结构/5 图/图/9 度.png" alt></p>
<h6 id="权和网"><a href="#权和网" class="headerlink" title="权和网"></a>权和网</h6><p><img src="/2019/05/26/数据结构/5 图/图/10 权和网.png" alt></p>
<h6 id="基本概念总结"><a href="#基本概念总结" class="headerlink" title="基本概念总结"></a>基本概念总结</h6><p><img src="/2019/05/26/数据结构/5 图/图/11 基本概念总结.png" alt></p>
<h5 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h5><ul>
<li>邻接矩阵(顺序存储)</li>
<li>邻接表(链式存储)<ul>
<li>十字链表(有向图)</li>
<li>邻接多重表(无向图)</li>
</ul>
</li>
</ul>
<h6 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h6><p>顶点：用一维数组来存储</p>
<p>边或弧：用二维数组来存储</p>
<p>二维数组就是一维数组的扩展，相当于一维数组中每个元素也是一维数组，二维数组也叫做邻接矩阵</p>
<p>无向图的邻接矩阵</p>
<p><img src="/2019/05/26/数据结构/5 图/图/12 无向图邻接矩阵.png" alt></p>
<p>有向图的邻接矩阵</p>
<p><img src="/2019/05/26/数据结构/5 图/图/13 有向图邻接矩阵.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/14 矩阵数据结构.png" alt></p>
<h6 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h6><p>对于稀疏图(E远小于V)，顺序存储结构存在预先分配内存可能浪费的问题</p>
<p>无向图邻接表</p>
<p><img src="/2019/05/26/数据结构/5 图/图/15 无向图邻接表.png" alt></p>
<p>有向图邻接表</p>
<p><img src="/2019/05/26/数据结构/5 图/图/16 有向图邻接表.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/17 邻接表问题.png" alt></p>
<h6 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h6><p>十字链表是针对有向图的存储方式，对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点</p>
<p><img src="/2019/05/26/数据结构/5 图/图/18 十字链表.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/19 十字链表实例.png" alt></p>
<p>十字链表数据结构</p>
<p><img src="/2019/05/26/数据结构/5 图/图/20 十字链表结构.png" alt></p>
<h6 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h6><p><img src="/2019/05/26/数据结构/5 图/图/21 设计邻接多重表.png" alt></p>
<p>边表结构</p>
<p><img src="/2019/05/26/数据结构/5 图/图/22 边表结构.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/23 邻接多重表实例.png" alt></p>
<h5 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h5><p>图的遍历：从图中某一个顶点出发遍历图中其余的顶点，且使每一个顶点仅访问一次，这个过程叫做图的遍历</p>
<p>图中顶点没有特殊性，可能存在沿着某条路径搜索后回到原起点，而有些顶点没有访问到。</p>
<p>解决办法：设置一个访问数组，记录遍历过程中访问过的顶点。</p>
<h6 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历(BFS)"></a>广度优先遍历(BFS)</h6><p><img src="/2019/05/26/数据结构/5 图/图/24 广度优先遍历.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/25 广度优先代码.png" alt></p>
<p>BFS算法实例</p>
<p><img src="/2019/05/26/数据结构/5 图/图/26 广度优先遍历实例.png" alt></p>
<p>BFS空间复杂度</p>
<p>BFS需要借助一个队列，n个顶点均需要入队一次，所以最坏情况下n个顶点在队列，那么则需要O(|V|)的空间复杂度</p>
<p>BFS时间复杂度</p>
<ol>
<li>邻接表：每个顶点入队一次，时间复杂度为O(|V|)，对于每个顶点，搜索它的邻接点，就需要访问这个顶点的所有边，所以时间复杂度为O(|E|)。所以总的时间复杂度为<strong>O(|V|+|E|)</strong>。</li>
<li>邻接矩阵：每个顶点入队一次，时间复杂度为O(|V|)，对于每个顶点，搜索它的邻接点，需要遍历一遍矩阵，所以时间复杂度为O(|V|)，所以总的时间复杂度为<strong>O(|V|<sup>2</sup>)</strong>。</li>
</ol>
<p>BFS应用</p>
<p>BFS解决单源非带权图最短路径问题：按照距离由近到远来遍历图中每个顶点</p>
<p><img src="/2019/05/26/数据结构/5 图/图/27 广度优先应用.png" alt></p>
<p>广度优先生成树</p>
<p><img src="/2019/05/26/数据结构/5 图/图/28 广度优先生成树.png" alt></p>
<h6 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历(DFS)"></a>深度优先遍历(DFS)</h6><p>深度优先遍历（DFS：Depth-First-Serch）：深度优先遍历类似于树的先序遍历算法</p>
<p>遍历过程：首先访问图中某一起始顶点v，然后由v出发，访问与v邻接且未被访问的任一顶点w1，再访问与w1邻接且未被访问的任一顶点w2，。。。。重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直到图中所有顶点均被访问过为止。</p>
<p><img src="/2019/05/26/数据结构/5 图/图/29 深度优先遍历过程.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/30 深度优先遍历代码.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/31 深度优先遍历实例.png" alt></p>
<p>深度优先复杂度</p>
<p>空间复杂度：</p>
<p>由于DFS是一个递归算法，递归是一个需要工作栈来辅助工作，最多需要图中所有顶点进栈，所以空间复杂度为O(|V|)</p>
<p>时间复杂度：</p>
<ol>
<li>邻接表：遍历过程的主要操作是对顶点遍历它的邻接点，由于通过访问边表来查找邻接点，所以时间复杂度为O(|E|)，访问访问顶点时间为O(|V|)，所以总的时间复杂度为<strong>O(|V|+|E|)</strong>。</li>
<li>邻接矩阵：查找每个顶点的邻接点时间复杂度为O(|V|)，对每个顶点都进行查找，所以总的时间复杂度<strong>O(|V|<sup>2</sup>)</strong>。</li>
</ol>
<p>深度优先生成树</p>
<p><img src="/2019/05/26/数据结构/5 图/图/32 深度优先生成树.png" alt></p>
<h5 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h5><h6 id="最小生成树-Prim、Kruskal"><a href="#最小生成树-Prim、Kruskal" class="headerlink" title="最小生成树(Prim、Kruskal)"></a>最小生成树(Prim、Kruskal)</h6><p>连通图的生成树，是一个极小的连通子图。包含图中全部的顶点，但只有足以构成一棵树的n-1条边</p>
<p><img src="/2019/05/26/数据结构/5 图/图/33 生成树不唯一.png" alt></p>
<ul>
<li>普里姆(Prim)算法</li>
<li>克鲁斯卡尔(Kruskal)算法</li>
</ul>
<p>普里姆算法</p>
<p><img src="/2019/05/26/数据结构/5 图/图/34 普利姆算法思路.png" alt></p>
<p>初始化</p>
<p><img src="/2019/05/26/数据结构/5 图/图/35 普利姆算法代码0.png" alt></p>
<p>i=1</p>
<p><img src="/2019/05/26/数据结构/5 图/图/35 普利姆算法代码1.png" alt></p>
<p>i=2</p>
<p><img src="/2019/05/26/数据结构/5 图/图/36 普利姆算法代码2-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/37 普利姆算法代码2-2.png" alt></p>
<p>i=3</p>
<p><img src="/2019/05/26/数据结构/5 图/图/38 普利姆算法代码3-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/39 普利姆算法代码3-2.png" alt></p>
<p>i=4</p>
<p><img src="/2019/05/26/数据结构/5 图/图/40 普利姆算法代码4-1.png" alt></p>
<p>i=5</p>
<p><img src="/2019/05/26/数据结构/5 图/图/41 普利姆算法代码5.png" alt></p>
<p>i=6</p>
<p><img src="/2019/05/26/数据结构/5 图/图/42 普利姆算法代码6.png" alt></p>
<p>Prim算法时间复杂度</p>
<p><img src="/2019/05/26/数据结构/5 图/图/43 普利姆算法复杂度.png" alt></p>
<p>克鲁斯卡尔算法(Kruskal)</p>
<p><img src="/2019/05/26/数据结构/5 图/图/44 克鲁斯卡尔算法思路.png" alt></p>
<p>并查集</p>
<p><img src="/2019/05/26/数据结构/5 图/图/45 并查集.png" alt></p>
<p>算法思路</p>
<p>初始化，将边权值进行排序</p>
<p><img src="/2019/05/26/数据结构/5 图/图/46 克鲁斯算法代码初始化.png" alt></p>
<p>第一次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/47 克鲁斯算法过程1-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/48 克鲁斯算法过程1-2.png" alt></p>
<p>第二次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/49 克鲁斯算法过程2-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/50 克鲁斯算法过程2-2.png" alt></p>
<p>第三次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/51 克鲁斯算法过程3-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/52 克鲁斯算法过程3-2.png" alt></p>
<p>第四次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/53 克鲁斯算法过程4-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/54 克鲁斯算法过程4-2.png" alt></p>
<p>第五次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/55 克鲁斯算法过程5.png" alt></p>
<p>第六次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/56 克鲁斯算法过程6-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/57 克鲁斯算法过程6-2.png" alt></p>
<p>第七次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/58 克鲁斯算法过程7-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/59 克鲁斯算法过程7-2.png" alt></p>
<p>4-6之后的边循环都不进行操作了，已经形成六条边(n-1)，形成最小生成树</p>
<p>克鲁斯卡尔算法复杂度</p>
<p><img src="/2019/05/26/数据结构/5 图/图/60 克鲁斯算法复杂度.png" alt></p>
<h6 id="最短路径-Dijkstra、floyd"><a href="#最短路径-Dijkstra、floyd" class="headerlink" title="最短路径(Dijkstra、floyd)"></a>最短路径(Dijkstra、floyd)</h6><p><img src="/2019/05/26/数据结构/5 图/图/61 最短路径.png" alt></p>
<ul>
<li>迪杰斯特拉算法：一个源点到其余顶点的最短路径</li>
<li>弗洛伊德算法：所有顶点到所有顶点的最短路径</li>
</ul>
<p>迪杰斯特拉算法思路：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/62 迪杰斯特拉算法思路.png" alt></p>
<p>迪杰斯特拉算法实例</p>
<p>第一次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/63 迪杰斯特拉算法实例1-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/64 迪杰斯特拉算法实例1-2.png" alt></p>
<p>第二次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/65 迪杰斯特拉算法实例2.png" alt></p>
<p>第三次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/66 迪杰斯特拉算法实例3.png" alt></p>
<p>第四次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/67 迪杰斯特拉算法实例4.png" alt></p>
<p>第五次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/68 迪杰斯特拉算法实例5.png" alt></p>
<p>迪杰斯特拉算法代码</p>
<p><img src="/2019/05/26/数据结构/5 图/图/69 迪杰斯特拉算法代码1-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/70 迪杰斯特拉算法代码1-2.png" alt></p>
<p>迪杰斯特拉复杂度</p>
<p><img src="/2019/05/26/数据结构/5 图/图/71 迪杰斯特拉算法复杂度.png" alt></p>
<p>弗洛伊德算法</p>
<p>弗洛伊德算法是求图中任意一对顶点间的最短路径的算法</p>
<p>算法思想：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/72 佛洛依德算法思路.png" alt></p>
<p>佛洛依德算法实例</p>
<p>初始化</p>
<p><img src="/2019/05/26/数据结构/5 图/图/73 佛洛依德算法实例初始化.png" alt></p>
<p>第一次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/74 佛洛依德算法实例1.png" alt></p>
<p>第二次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/75 弗洛依德算法实例2.png" alt></p>
<p>第三次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/76 弗洛依德算法实例3.png" alt></p>
<p>第四次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/77 弗洛依德算法实例4.png" alt></p>
<p>弗洛伊德算法代码和复杂度</p>
<p><img src="/2019/05/26/数据结构/5 图/图/78 弗洛依德算法实例5.png" alt></p>
<h6 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h6><p>AOV网</p>
<p><img src="/2019/05/26/数据结构/5 图/图/79 AOV网.png" alt></p>
<p>拓扑排序算法思路</p>
<p><img src="/2019/05/26/数据结构/5 图/图/80 拓扑排序算法思路.png" alt></p>
<p>第一轮：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/81 拓扑排序算法过程1.png" alt></p>
<p>第二轮：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/82 拓扑排序算法过程2.png" alt></p>
<p>第三轮：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/83 拓扑排序算法过程3.png" alt></p>
<p>第四轮：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/84 拓扑排序算法过程4.png" alt></p>
<p>第五轮：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/85 拓扑排序算法过程5.png" alt></p>
<p>第六轮：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/86 拓扑排序算法过程6.png" alt></p>
<p>第七轮：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/87 拓扑排序算法过程7.png" alt></p>
<p>拓扑排序算法代码</p>
<p><img src="/2019/05/26/数据结构/5 图/图/88 拓扑排序算法代码.png" alt></p>
<p>拓扑排序算法复杂度</p>
<p><img src="/2019/05/26/数据结构/5 图/图/89 拓扑排序算法复杂度.png" alt></p>
<p>拓扑排序规律</p>
<p><img src="/2019/05/26/数据结构/5 图/图/90 拓扑排序算法规律.png" alt></p>
<h6 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h6><p>AOE网</p>
<p><img src="/2019/05/26/数据结构/5 图/图/91 AOE网.png" alt></p>
<p>关键路径</p>
<p><img src="/2019/05/26/数据结构/5 图/图/92 关键路径.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/93 关键路径规律.png" alt></p>
<p>寻找关键路径步骤</p>
<p><img src="/2019/05/26/数据结构/5 图/图/94 关键路径步骤1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/95 关键路径步骤2.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/96 关键路径步骤3.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/数据库/数据库之事务和锁机制/数据库之事务和锁机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/数据库/数据库之事务和锁机制/数据库之事务和锁机制/" class="post-title-link" itemprop="url">数据库之事务和锁机制</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 23:42:01" itemprop="dateModified" datetime="2019-10-06T23:42:01+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T23:42:01+08:00" content="2019-10-06">
                2019-10-06 23:42:01
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/数据库/数据库之事务和锁机制/数据库之事务和锁机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/数据库/数据库之事务和锁机制/数据库之事务和锁机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据库之事务和锁机制"><a href="#数据库之事务和锁机制" class="headerlink" title="数据库之事务和锁机制"></a>数据库之事务和锁机制</h1><p><img src="/2019/05/26/数据库/数据库之事务和锁机制/数据库之事务和锁机制/事务思维导图.png" alt></p>
<h3 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h3><p>事务的概念：事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元，要么全部执行，要么全部不执行。</p>
<p>1、原子性（Atomicity）</p>
<p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，如果操作失败则不能对数据库有任何影响，任何一项操作都会导致整个事务的失败，同时其它已经被执行的操作都将被撤销并回滚，只有所有的操作全部成功，整个事务才算是成功完成。</p>
<p>2、一致性（Consistency）</p>
<p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<p>3、隔离性（lsolation）</p>
<p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>
<p>4、持久性（durability）</p>
<p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<p>例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>
<h3 id="事务并发引起的问题"><a href="#事务并发引起的问题" class="headerlink" title="事务并发引起的问题"></a>事务并发引起的问题</h3><p>1、脏读（dirty read）</p>
<p>　　当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。</p>
<p>例如：用户A向用户B转账100元</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> money=money+<span class="number">100</span> <span class="keyword">where</span> <span class="keyword">name</span>=’B’;  (此时A通知B)</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> money=money - <span class="number">100</span> <span class="keyword">where</span> <span class="keyword">name</span>=’A’;</span><br><span class="line">以上两条sql语句为转账事务</span><br></pre></td></tr></table></figure>
<p>转账是一个事务，通知查看是一个事务。</p>
<p>当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（<strong>此时即发生了脏读</strong>）</p>
<p>而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚</p>
<p>那么当B以后再次查看账户时就会发现钱其实并没有转。</p>
<p>脏读就是一个事务读取了另一个事务未提交的脏数据</p>
<p>2、不可重复读（unrepeatable reading）</p>
<p>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p>
<p>例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。</p>
<p>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</p>
<p>在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就产生矛盾。</p>
<p>3、幻读（Phantom read）</p>
<p>幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p>
<p>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p>
<h3 id="事务的四种隔离级别"><a href="#事务的四种隔离级别" class="headerlink" title="事务的四种隔离级别"></a>事务的四种隔离级别</h3><ul>
<li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</li>
<li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</li>
<li>Read committed (读已提交)：可避免脏读的发生。</li>
<li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</li>
</ul>
<p>以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别。级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。</p>
<p>隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效。</p>
<p>对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。</p>
<p>### </p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/数据结构/7 排序/排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/数据结构/7 排序/排序/" class="post-title-link" itemprop="url">排序</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-23 14:04:58" itemprop="dateModified" datetime="2019-10-23T14:04:58+08:00">2019-10-23</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-23T14:04:58+08:00" content="2019-10-23">
                2019-10-23 14:04:58
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/数据结构/7 排序/排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/数据结构/7 排序/排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>排序就是将原本无序的序列重新排列成有序的序列</p>
<p>排序的稳定性</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/1 排序稳定性.png" alt></p>
<p>内部排序：指的是待排序记录全部存放在计算机内存中进行排序的过程</p>
<p>外部排序：指的是待排序的记录的数量很大，以致内存一次不能容纳全部记录，在排序过程中尚需要对外存进行访问的排序过程</p>
<p>内部排序分类</p>
<ul>
<li>插入类：将无序子序列中的一个或几个记录插入到有序序列中，从而增加记录的有序子序列的长度，包括直接插入排序、折半插入排序、希尔排序</li>
<li>交换类：通过交换无序序列中的记录从而得到其中关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度，包括冒泡排序和快速排序</li>
<li>选择类：从记录的无序子序列中选择关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加有序子序列的长度，包括简单选择排序、树形选择排序、堆排序</li>
<li><p>归并类：通过归并两个或两个以上的记录有序子序列，逐步增加记录有序序列的长度，包括2路归并排序</p>
</li>
<li><p>分配类：是唯一一类不需要关键字之间的比较的排序方法，排序时主要利用分配和收集两种基本操作完成。基数排序是主要的分配类排序</p>
</li>
</ul>
<h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><h6 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h6><p><img src="/2019/05/26/数据结构/7 排序/排序/2 直接插入排序代码.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 插入排序;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接插入排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入需要排序的数字"</span>);</span><br><span class="line">		System.out.println(<span class="string">"01 02 03 04 05 06 07 08 09 10"</span>);</span><br><span class="line">		<span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>];</span><br><span class="line">		<span class="keyword">while</span>(i&lt;<span class="number">11</span>) &#123;</span><br><span class="line">			array[i] = sc.nextInt();</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		InsertSort(array);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>;a&lt;<span class="number">11</span>;a++)</span><br><span class="line">			System.out.print(array[a]+<span class="string">","</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> array[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i,j;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;array.length;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(array[i]&lt;array[i-<span class="number">1</span>]) &#123;</span><br><span class="line">				array[<span class="number">0</span>]=array[i];</span><br><span class="line">				<span class="keyword">for</span>(j=i-<span class="number">1</span>;array[j]&gt;array[<span class="number">0</span>];j--) &#123;</span><br><span class="line">					array[j+<span class="number">1</span>] = array[j];</span><br><span class="line">				&#125;</span><br><span class="line">				array[j+<span class="number">1</span>] = array[<span class="number">0</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空间时间复杂度</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/3 直接插入排序时间复杂度.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/4 直接插入排序时间复杂度2.png" alt></p>
<p>时间复杂度最好O(n)，最坏O(n<sup>2</sup>)</p>
<p>直接插入排序是<strong>稳定</strong>的</p>
<h6 id="折半查找排序"><a href="#折半查找排序" class="headerlink" title="折半查找排序"></a>折半查找排序</h6><p><img src="/2019/05/26/数据结构/7 排序/排序/5 折半插入排序.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/6 折半插入排序例子.png" alt></p>
<p>折半排序代码</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/7 折半插入排序代码.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 插入排序;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 	折半插入排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 11053</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryInsertSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入需要排序的数字"</span>);</span><br><span class="line">		System.out.println(<span class="string">"01 02 03 04 05 06 07 08 09 10"</span>);</span><br><span class="line">		<span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>];</span><br><span class="line">		<span class="keyword">while</span>(i&lt;<span class="number">11</span>) &#123;</span><br><span class="line">			array[i] = sc.nextInt();</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		BinaryInsertSort(array);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>;a&lt;<span class="number">11</span>;a++)</span><br><span class="line">			System.out.print(array[a]+<span class="string">","</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BinaryInsertSort</span><span class="params">(<span class="keyword">int</span> array[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i,j,mid,low,high;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;array.length;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(array[i]&lt;array[i-<span class="number">1</span>]) &#123;</span><br><span class="line">				array[<span class="number">0</span>] = array[i];</span><br><span class="line">				low = <span class="number">1</span>;</span><br><span class="line">				high = i-<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">while</span>(low&lt;=high) &#123;</span><br><span class="line">					mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">					<span class="keyword">if</span>(array[mid]&gt;array[<span class="number">0</span>]) high = mid-<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">else</span> low = mid+<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span>(j=i-<span class="number">1</span>;j&gt;=high+<span class="number">1</span>;j--)</span><br><span class="line">					array[j+<span class="number">1</span>] = array[j];</span><br><span class="line">				array[high+<span class="number">1</span>] = array[<span class="number">0</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/8 折半插入排序时间复杂度.png" alt></p>
<p>时间复杂度O(n<sup>2</sup>)</p>
<p>折半插入排序是<strong>稳定</strong>的</p>
<h6 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h6><p><img src="/2019/05/26/数据结构/7 排序/排序/9 希尔排序.png" alt></p>
<p>希尔排序过程</p>
<p>第一趟：10个元素取增量10/2=5</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/10 希尔排序第一趟.png" alt></p>
<p>第二趟：5/2向下取整=2</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/11 希尔排序第二趟.png" alt></p>
<p>第三趟：最后增量为1</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/12 希尔排序第三趟.png" alt></p>
<p>希尔排序的时间复杂度</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/13 希尔排序时间复杂度.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/14 希尔排序稳定性.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 插入排序;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  希尔排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 11053</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入需要排序的数字"</span>);</span><br><span class="line">		System.out.println(<span class="string">"01 02 03 04 05 06 07 08 09 10"</span>);</span><br><span class="line">		<span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>];</span><br><span class="line">		<span class="keyword">while</span>(i&lt;<span class="number">11</span>) &#123;</span><br><span class="line">			array[i] = sc.nextInt();</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		ShellSort(array);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>;a&lt;<span class="number">11</span>;a++)</span><br><span class="line">			System.out.print(array[a]+<span class="string">","</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> array[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> d,i,j;</span><br><span class="line">		<span class="keyword">for</span>(d=array.length/<span class="number">2</span>;d&gt;=<span class="number">1</span>;d=d/<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(i=d+<span class="number">1</span>;i&lt;=array.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(array[i]&lt;array[i-d]) &#123;</span><br><span class="line">					array[<span class="number">0</span>] = array[i];</span><br><span class="line">					<span class="keyword">for</span>(j=i-d;j&gt;<span class="number">0</span>&amp;&amp;array[j]&gt;array[<span class="number">0</span>];j-=d) &#123;</span><br><span class="line">						array[j+d] = array[j];</span><br><span class="line">					&#125;</span><br><span class="line">					array[j+d] = array[<span class="number">0</span>];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度最好<strong>O(n<sup>1.3</sup>)，最坏O(n<sup>2</sup>)</strong>.</p>
<p>希尔排序<strong>不稳定</strong></p>
<h5 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h5><p>交换类排序：根据序列中两个元素关键字的比较结果来交换它两在序列中的位置</p>
<h6 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h6><p><img src="/2019/05/26/数据结构/7 排序/排序/15 冒泡排序.png" alt></p>
<p>冒泡排序代码</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/16 冒泡排序代码.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 交换排序;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  冒泡排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 11053</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入需要排序的数字"</span>);</span><br><span class="line">		System.out.println(<span class="string">"01 02 03 04 05 06 07 08 09 10"</span>);</span><br><span class="line">		<span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>];</span><br><span class="line">		<span class="keyword">while</span>(i&lt;<span class="number">11</span>) &#123;</span><br><span class="line">			array[i] = sc.nextInt();</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		BubbleSort(array);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>;a&lt;<span class="number">11</span>;a++)</span><br><span class="line">			System.out.print(array[a]+<span class="string">","</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> array[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i,j,temp;</span><br><span class="line">		<span class="keyword">boolean</span> flag;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;array.length;i++) &#123;</span><br><span class="line">			flag=<span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">for</span>(j=array.length-<span class="number">1</span>;j&gt;i;j--) &#123;</span><br><span class="line">				<span class="keyword">if</span>(array[j-<span class="number">1</span>]&gt;array[j]) &#123;</span><br><span class="line">					temp = array[j];</span><br><span class="line">					array[j] = array[j-<span class="number">1</span>];</span><br><span class="line">					array[j-<span class="number">1</span>] = temp;</span><br><span class="line">					flag = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag==<span class="keyword">false</span>) <span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序时间复杂度<strong>最好O(n)，最坏O(n<sup>2</sup>)</strong>.</p>
<p>冒泡排序<strong>稳定</strong>.</p>
<h6 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h6><p>快速排序是一种基于分治法的排序方法</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/17 快速排序.png" alt></p>
<p>快速排序代码</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/18 快速排序代码1.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/19 快速排序代码2.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/20 快速排序最坏时间复杂度.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/21 快速排序最坏时间复杂度2.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/22 快速排序空间复杂度.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 交换排序;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 11053</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入需要排序的数字"</span>);</span><br><span class="line">		System.out.println(<span class="string">"01 02 03 04 05 06 07 08 09 10"</span>);</span><br><span class="line">		<span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>];</span><br><span class="line">		<span class="keyword">while</span>(i&lt;<span class="number">11</span>) &#123;</span><br><span class="line">			array[i] = sc.nextInt();</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		QuickSort(array,<span class="number">1</span>,array.length-<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>;a&lt;<span class="number">11</span>;a++)</span><br><span class="line">			System.out.print(array[a]+<span class="string">","</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(low&lt;high) &#123;</span><br><span class="line">			<span class="keyword">int</span> pivotloc = Partition(array,low,high);</span><br><span class="line">			QuickSort(array,low,pivotloc-<span class="number">1</span>);</span><br><span class="line">			QuickSort(array,pivotloc+<span class="number">1</span>,high);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> pivot = array[low];</span><br><span class="line">		<span class="keyword">while</span>(low&lt;high) &#123;</span><br><span class="line">			<span class="keyword">while</span>(low&lt;high&amp;&amp;array[high]&gt;=pivot) high--;</span><br><span class="line">			array[low] = array[high];</span><br><span class="line">			<span class="keyword">while</span>(low&lt;high&amp;&amp;array[low]&lt;=pivot) low++;</span><br><span class="line">			array[high] = array[low];</span><br><span class="line">		&#125;</span><br><span class="line">		array[low] = pivot;</span><br><span class="line">		<span class="keyword">return</span> low;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快速排序时间复杂度最好<strong>O(nlogn)，最坏O(n<sup>2</sup>)</strong>.</p>
<p>序列越乱序，效率越高；序列越有序，效率越低</p>
<p>空间复杂度最好<strong>O(logn)，最坏O(n)</strong>.</p>
<p>快速排序<strong>不稳定</strong>.</p>
<h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><p><img src="/2019/05/26/数据结构/7 排序/排序/23 选择排序.png" alt></p>
<h6 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h6><p><img src="/2019/05/26/数据结构/7 排序/排序/24 选择排序代码.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/25 选择排序稳定性.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 选择排序;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单选择排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入需要排序的数字"</span>);</span><br><span class="line">		System.out.println(<span class="string">"01 02 03 04 05 06 07 08 09 10"</span>);</span><br><span class="line">		<span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>];</span><br><span class="line">		<span class="keyword">while</span>(i&lt;<span class="number">11</span>) &#123;</span><br><span class="line">			array[i] = sc.nextInt();</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		SelectSort(array);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>;a&lt;<span class="number">11</span>;a++)</span><br><span class="line">			System.out.print(array[a]+<span class="string">","</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> array[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i,j,min;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;array.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">			min = i;</span><br><span class="line">			<span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;array.length;j++) </span><br><span class="line">				<span class="keyword">if</span>(array[min]&gt;array[j]) min = j;</span><br><span class="line">			<span class="keyword">if</span>(min!=i) &#123;</span><br><span class="line">				array[<span class="number">0</span>] = array[min];</span><br><span class="line">				array[min] = array[i];</span><br><span class="line">				array[i] = array[<span class="number">0</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单选择排序时间复杂度O(n<sup>2</sup>)</p>
<p>不稳定，交换会打破顺序</p>
<h6 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h6><p>堆的定义</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/26 堆排序.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/27 堆排序形成.png" alt></p>
<p>大顶堆过程</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/28 大顶堆排序1.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/29 大顶堆排序2.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/30 大顶堆排序3.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/31 大顶堆排序4.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/32 大顶堆排序5.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/33 大顶堆排序6.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/34 大顶堆排序7.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/35 大顶堆排序8.png" alt></p>
<p>堆排序算法</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/36 堆排序算法思路.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/37 堆排序算法.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/38 堆排序算法2.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/39 堆排序时间复杂度.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/40 堆排序时间复杂度2.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/41 堆排序时间复杂度3.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/42 堆排序时间复杂度4.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/43 堆排序时间复杂度5.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 选择排序;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入需要排序的数字"</span>);</span><br><span class="line">		System.out.println(<span class="string">"01 02 03 04 05 06 07 08 09 10"</span>);</span><br><span class="line">		<span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>];</span><br><span class="line">		<span class="keyword">while</span>(i&lt;<span class="number">11</span>) &#123;</span><br><span class="line">			array[i] = sc.nextInt();</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		HeadSort(array);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>;a&lt;<span class="number">11</span>;a++)</span><br><span class="line">			System.out.print(array[a]+<span class="string">","</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeadSort</span><span class="params">(<span class="keyword">int</span> array[])</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = array.length-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		BuildMaxHead(array, len);</span><br><span class="line">		<span class="keyword">for</span>(i=len;i&gt;<span class="number">0</span>;i--) &#123;</span><br><span class="line">			Swap(array,<span class="number">1</span>,i);</span><br><span class="line">			HeadAjust(array,<span class="number">1</span>,i-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BuildMaxHead</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//len=10</span></span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i=len/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">			HeadAjust(array,i,len);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">HeadAjust</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> k,<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		array[<span class="number">0</span>] = array[k];</span><br><span class="line">		<span class="keyword">for</span>(i=k*<span class="number">2</span>;i&lt;=len;i=i*<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;len&amp;&amp;array[i]&lt;array[i+<span class="number">1</span>])</span><br><span class="line">				i++;</span><br><span class="line">			<span class="keyword">if</span>(array[i]&lt;array[<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				array[k] = array[i];</span><br><span class="line">				k=i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		array[k] = array[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> top,<span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">		array[<span class="number">0</span>] = array[top];</span><br><span class="line">		array[top] = array[bottom];</span><br><span class="line">		array[bottom] = array[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆排序时间复杂度<strong>O(nlog<sub>2</sub>n)，空间复杂度O(1)</strong>。</p>
<p>堆排序<strong>不稳定</strong>.</p>
<h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><p><img src="/2019/05/26/数据结构/7 排序/排序/44 归并排序.png" alt></p>
<p>归并排序代码</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/45 归并排序代码.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/46 归并排序代码2.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/47 归并排序时间复杂度.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/49 归并排序空间复杂度.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 归并排序;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  归并排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 11053</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入需要排序的数字"</span>);</span><br><span class="line">		System.out.println(<span class="string">"01 02 03 04 05 06 07 08 09 10"</span>);</span><br><span class="line">		<span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>];</span><br><span class="line">		<span class="keyword">while</span>(i&lt;<span class="number">11</span>) &#123;</span><br><span class="line">			array[i] = sc.nextInt();</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		MergeSort(array,<span class="number">1</span>,array.length-<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">1</span>;a&lt;<span class="number">11</span>;a++)</span><br><span class="line">			System.out.print(array[a]+<span class="string">","</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> mid;</span><br><span class="line">		<span class="keyword">if</span>(low&lt;high) &#123;</span><br><span class="line">			mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">			MergeSort(array,low,mid);</span><br><span class="line">			MergeSort(array,mid+<span class="number">1</span>,high);</span><br><span class="line">			Merge(array,low,mid,high);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> array[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i,j,k;</span><br><span class="line">		<span class="keyword">int</span> len = array.length;</span><br><span class="line">		<span class="keyword">int</span> temp[] = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">		<span class="keyword">for</span>(k=low;k&lt;=high;k++)</span><br><span class="line">			temp[k] = array[k];</span><br><span class="line">		<span class="keyword">for</span>(i=low,j=mid+<span class="number">1</span>,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(temp[i]&lt;temp[j])</span><br><span class="line">				array[k]=temp[i++];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				array[k]=temp[j++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;=mid) array[k++]=temp[i++];</span><br><span class="line">		<span class="keyword">while</span>(j&lt;=high) array[k++]=temp[j++];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度O(nlogn),空间复杂度O(n)</p>
<p>归并排序稳定</p>
<h5 id="非比较排序"><a href="#非比较排序" class="headerlink" title="非比较排序"></a>非比较排序</h5><h6 id="基数排序-桶排序"><a href="#基数排序-桶排序" class="headerlink" title="基数排序(桶排序)"></a>基数排序(桶排序)</h6><p><img src="/2019/05/26/数据结构/7 排序/排序/50 基数排序.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/51 基数排序1.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/52 基数排序2.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/53 基数排序3.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/54 基数排序4.png" alt></p>
<p>MSD</p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/55 基数排序5.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/56 基数排序6.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/57 基数排序7.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/58 基数排序8.png" alt></p>
<p><img src="/2019/05/26/数据结构/7 排序/排序/59 各排序算法复杂度总结.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/数据库/数据库之索引/数据库之索引/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/数据库/数据库之索引/数据库之索引/" class="post-title-link" itemprop="url">数据库之索引</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 23:44:39" itemprop="dateModified" datetime="2019-10-06T23:44:39+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T23:44:39+08:00" content="2019-10-06">
                2019-10-06 23:44:39
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/数据库/数据库之索引/数据库之索引/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/数据库/数据库之索引/数据库之索引/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据库之索引"><a href="#数据库之索引" class="headerlink" title="数据库之索引"></a>数据库之索引</h1><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>在创建表的时候添加索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable(  </span><br><span class="line">    <span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,   </span><br><span class="line">    username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">    <span class="keyword">INDEX</span> [indexName] (username(<span class="keyword">length</span>))  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在创建表以后添加索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> my_table <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span>] <span class="keyword">INDEX</span> index_name(column_name);</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> my_table(column_name);</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>1、索引需要占用磁盘空间，因此在创建索引时要考虑到磁盘空间是否足够</p>
<p>2、创建索引时需要对表加锁，因此实际操作中需要在业务空闲期间进行</p>
<h3 id="根据索引进行查询"><a href="#根据索引进行查询" class="headerlink" title="根据索引进行查询"></a>根据索引进行查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">具体查询：</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_1=column_2;(为column_1建立了索引)</span><br><span class="line"></span><br><span class="line">或者模糊查询</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_1 <span class="keyword">LIKE</span> <span class="string">'%三'</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_1 <span class="keyword">LIKE</span> <span class="string">'三%'</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_1 <span class="keyword">LIKE</span> <span class="string">'%三%'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_1 <span class="keyword">LIKE</span> <span class="string">'_好_'</span></span><br><span class="line"> </span><br><span class="line">如果要表示在字符串中既有A又有B，那么查询语句为：</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_1 <span class="keyword">LIKE</span> <span class="string">'%A%'</span> <span class="keyword">AND</span> column_1 <span class="keyword">LIKE</span> <span class="string">'%B%'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_1 <span class="keyword">LIKE</span> <span class="string">'[张李王]三'</span>;  //表示column_1中有匹配张三、李</span><br><span class="line">三、王三的都可以</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_1 <span class="keyword">LIKE</span> <span class="string">'[^张李王]三'</span>;  //表示column_1中有匹配除了张</span><br><span class="line">三、李三、王三的其他三都可以</span><br><span class="line"></span><br><span class="line">//在模糊查询中，%表示任意0个或多个字符；_表示任意单个字符（有且仅有），通常用来限制字符串长度;[]表示</span><br><span class="line">其中的某一个字符；[^]表示除了其中的字符的所有字符</span><br><span class="line"> </span><br><span class="line">或者在全文索引中模糊查询</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(<span class="keyword">content</span>) AGAINST(<span class="string">'word1'</span>,<span class="string">'word2'</span>,...);</span><br></pre></td></tr></table></figure>
<p>删除索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> my_index <span class="keyword">ON</span> tablename；</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name;</span><br></pre></td></tr></table></figure>
<p>查看表中的索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> tablename</span><br></pre></td></tr></table></figure>
<p>查看查询语句查询索引的情况</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//<span class="keyword">explain</span> 加查询语句</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_1=<span class="string">'123'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h3><p>优点：</p>
<ul>
<li>可以快速检索，加快检索速度</li>
<li>根据索引分组和排序，可以加快分组和排序</li>
</ul>
<p>缺点：</p>
<ul>
<li>索引本身也是表，会占据存储空间</li>
<li>索引表的创建和维护需要时间，随数据量增大而增大</li>
<li>降低数据表的修改操作（删除、添加、修改）的效率，因为在修改数据表的同时也要修改索引表</li>
</ul>
<h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>常见的索引类型有：主键索引、唯一索引、普通索引、全文索引、组合索引</p>
<p>1、主键索引：即主索引，根据主键pk_clolum（length）建立索引，<strong>不允许重复，不允许空值</strong>；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span> pk_index(<span class="string">'col'</span>)；</span><br></pre></td></tr></table></figure>
<p>2、唯一索引：用来建立索引的列的值必须是<strong>唯一的，允许空值</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> index_name(<span class="string">'col'</span>)；</span><br></pre></td></tr></table></figure>
<p>3、普通索引：用表中的普通列构建的索引，没有任何限制</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name(<span class="string">'col'</span>)；</span><br></pre></td></tr></table></figure>
<p>4、全文索引：用大文本对象的列构建的索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> FULLTEXT <span class="keyword">INDEX</span> ft_index(<span class="string">'col'</span>)；</span><br></pre></td></tr></table></figure>
<p>5、组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name(<span class="string">'col1'</span>,<span class="string">'col2'</span>,<span class="string">'col3'</span>)；</span><br></pre></td></tr></table></figure>
<p>遵循“<strong>最左前缀</strong>”原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引<strong>相当于建立了col1,col1col2,col1col2col3三个索引</strong>，而col2或者col3是不能使用索引的。</p>
<p>在使用组合索引的时候可能因为列名长度过长而导致索引的key太大，导致效率降低，在允许的情况下，可以只取col1和col2的前几个字符作为索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name(col1(<span class="number">4</span>),col2（<span class="number">3</span>))；</span><br></pre></td></tr></table></figure>
<p>表示使用col1的前4个字符和col2的前3个字符作为索引。</p>
<h3 id="索引的选取类型"><a href="#索引的选取类型" class="headerlink" title="索引的选取类型"></a>索引的选取类型</h3><p>1、越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快</p>
<p>2、简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂</p>
<p>3、尽量避免NULL：应该指定列为NOT nuLL,在MySQL中， 含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂</p>
<h3 id="什么场景不适合创建索引"><a href="#什么场景不适合创建索引" class="headerlink" title="什么场景不适合创建索引"></a>什么场景不适合创建索引</h3><p>1、很少使用查询或者只是作为参考的列，因为这些列很少用到，添加索引只会增加开销和维护成本</p>
<p>2、很少数据集的列也不应该加索引，例如班级的同学的性别，只有男或女，利用索引相当于全表搜索，没意义</p>
<p>3、当修改性能远远大于检索性能时，因为修改性能和检索性能互相矛盾</p>
<p>4、不会出现在where条件中的字段不该建立索引</p>
<h3 id="什么的字段适合索引"><a href="#什么的字段适合索引" class="headerlink" title="什么的字段适合索引"></a>什么的字段适合索引</h3><p>1、表的主键和外键必须有索引，外键唯一，且经常查询</p>
<p>2、数据量比较多的超过300需要索引</p>
<p>3、经常需要和其他表进行连接查询的字段应该建立索引</p>
<p>4、经常出现在where子句中的字段，加快判断速度</p>
<p>5、经常用到排序的列上，因为索引已经排序</p>
<p>6、经常用在范围内搜索的列上创建索引，因为索引已经排序，指定范围是连续（B+树）</p>
<h3 id="MySQL索引的底层原理"><a href="#MySQL索引的底层原理" class="headerlink" title="MySQL索引的底层原理"></a>MySQL索引的底层原理</h3><p>索引是帮助MySQL高效获取数据的数据结构</p>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/索引方式思路图.png" alt></p>
<p>上图展示的是一种可能的索引方式</p>
<p>左边是数据表，一共有两列14条记录，最左边是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上并不一定物理相邻），但实际数据库系统几乎没有使用二叉查找树或其进化品种<a href="https://link.jianshu.com/?t=http%3A%2F%2Fen.wikipedia.org%2Fwiki%2FRed-black_tree" target="_blank" rel="noopener">红黑树</a>（red-black tree）实现</p>
<p>目前大部分数据库系统及文件系统都采用B Tree或其变种B+Tree作为索引结构，MySQL普遍使用B+树实现索引</p>
<p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的</p>
<p><strong>MyISAM和InnoDB对索引和数据的存储在磁盘上是如何体现的</strong></p>
<p>role表使用的存储引擎是MyISAM，而user使用的是InnoDB：</p>
<ol>
<li>role表有三个文件，对应如下：</li>
</ol>
<ul>
<li>role.frm：表结构文件</li>
<li>role.MYD：数据文件（MyISAM Data）</li>
<li>role.MYI：索引文件（MyISAM Index）</li>
</ul>
<ol start="2">
<li>user表有两个文件，对应如下：</li>
</ol>
<ul>
<li>user.frm：表结构文件</li>
<li>user.ibd：索引和数据文件（InnoDB Data）</li>
</ul>
<p>由于两种引擎对索引和数据的存储方式的不同，我们也称MyISAM的索引为非聚集索引，InnoDB的索引为聚集索引。</p>
<p><strong>MyISAM索引实现</strong></p>
<p>MyISAM引擎使用B+Tree作为索引结构，叶节点data域存放数据记录的地址</p>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/MyISAM索引实现.png" alt></p>
<p>设Col1为主键，上图是一个MyISAM表的主索引（Primary key）示例。<br>可以看出MyISAM的索引文件仅仅保存数据记录的地址。<br>在MyISAM中，主索引和辅索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅索引的key可以重复（为什么没有区别，是因为SQL语句中where子句可以使用的是其他字段来作为条件，如clo2&gt;…之类的语句，所以主索引和辅助索引在MyISAM没有区别）<br>如果我们在Col2上建立一个辅索引，则此索引的结构如下图所示：</p>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/MyISAM辅助索引图.png" alt></p>
<p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分</p>
<p><strong>InnoDB索引实现</strong></p>
<ul>
<li>MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址</li>
<li>而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引</li>
</ul>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/InnoDB主索引.png" alt></p>
<p>与MyISAM的区别两点：</p>
<p>一、因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有）</p>
<p>如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键</p>
<p>如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形</p>
<p>二、InnoDB的辅索引data域存储相应记录主键的值而不是地址。</p>
<p>InnoDB的所有辅助索引都引用主键作为data域</p>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/InnoDB辅助索引图.png" alt></p>
<h3 id="索引存在但未使用情况（索引失效、索引优化）"><a href="#索引存在但未使用情况（索引失效、索引优化）" class="headerlink" title="索引存在但未使用情况（索引失效、索引优化）"></a>索引存在但未使用情况（索引失效、索引优化）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_test_a1234 <span class="keyword">ON</span> <span class="keyword">test</span>(a1,a2,a3,a4);//创建联合索引来说明索引失效的一下情况</span><br></pre></td></tr></table></figure>
<p>1.字符串为使用引号，导致索引失效（不能在索引列上干任何操作(计算,函数,类型转换) ）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span>  a1 = a1;//可以查到数据，数据库自动转换类型，但索引失效</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 = <span class="string">'a1'</span>;</span><br></pre></td></tr></table></figure>
<p>2、索引最左原则使用不当，导致索引失效（where子句后面的顺序无关，只要用到就可以）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 = <span class="string">'a1'</span> <span class="keyword">and</span> a2 = <span class="string">'a2'</span> <span class="keyword">and</span> a3 = <span class="string">'a3'</span> <span class="keyword">and</span> a4 = <span class="string">'a4'</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a4= <span class="string">'a4'</span> <span class="keyword">and</span> a3 = <span class="string">'a3'</span> <span class="keyword">and</span> a2 = <span class="string">'a2'</span> <span class="keyword">and</span> a1= <span class="string">'a1'</span>;</span><br><span class="line">以上两个查询中，where条件中的索引位置是相反的，但是执行结果是一致的，这个是由mysql优化器来处理的，因</span><br><span class="line">为两个查询中都出现了联合索引a1,a2，a3,a4，MySQL优化器底层会进行优化处理。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 = <span class="string">'a1'</span> <span class="keyword">and</span> a3 = <span class="string">'a3'</span> <span class="keyword">and</span> a4 = <span class="string">'a4'</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a4= <span class="string">'a4'</span> <span class="keyword">and</span> a3 = <span class="string">'a3'</span> <span class="keyword">and</span> a1= <span class="string">'a1'</span>;</span><br><span class="line">以上两个查询只用到一个索引a1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 = <span class="string">'a1'</span> <span class="keyword">and</span> a2 = <span class="string">'a2'</span>  <span class="keyword">and</span> a4 = <span class="string">'a4'</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a4= <span class="string">'a4'</span> <span class="keyword">and</span> a2 = <span class="string">'a2'</span> <span class="keyword">and</span> a1= <span class="string">'a1'</span>;</span><br><span class="line">以上两个查询用到两个索引</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a2 = <span class="string">'a2'</span> <span class="keyword">and</span> a3 = <span class="string">'a3'</span> <span class="keyword">and</span> a4 = <span class="string">'a4'</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a4= <span class="string">'a4'</span> <span class="keyword">and</span> a3 = <span class="string">'a3'</span> <span class="keyword">and</span> a2 = <span class="string">'a2'</span></span><br><span class="line">以上两个查询未使用索引</span><br></pre></td></tr></table></figure>
<p>3、范围查找导致索引失效（存储引擎不能使用索引中范围条件右边的列）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select * from test where a1 = &apos;a1&apos; and a2 = &apos;a2&apos; and a3 &gt;&apos;a3&apos; and a4 = &apos;a4&apos;;</span><br><span class="line">以上用到a1、a2、a3，3个索引，因为a3右边是a4，导致a4的索引不可用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select * from test where a1 = &apos;a1&apos; and a2 = &apos;a2&apos; and a4 &gt;&apos;a4&apos; and a3= &apos;a3&apos;;</span><br><span class="line">以上用到a1、a2、a3、a4，4个索引，因为a4后面已经没有索引了，不影响</span><br></pre></td></tr></table></figure>
<p>4、order by使用不当，导致索引失效</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 = <span class="string">'a1'</span> <span class="keyword">and</span> a2 = <span class="string">'a2'</span> <span class="keyword">and</span> a4 = <span class="string">'a4'</span> <span class="keyword">order</span> <span class="keyword">by</span> a3</span><br><span class="line"><span class="keyword">explain</span>语句显示两个索引，严格来说以上用到两个索引查询，三个索引排序</span><br><span class="line">因为查找的<span class="keyword">where</span>条件中跳过了a3,违背了索引的最左原则，导致索引a4失效</span><br><span class="line">严格意义上来说，以上查询使用了<span class="number">3</span>个索引，a3并未用于查找，但是在排序中使用到了，只是为统计到<span class="keyword">explain</span>中，即</span><br><span class="line">满足索引的两大功能：查找和排序</span><br></pre></td></tr></table></figure>
<p>以下排序中，索引使用不当，导致产生了文件内排序，影响性能</p>
<p>a2之后a3断开，导致a4索引失效，mysql 为了将结果展现出来，进行了内部排序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 =<span class="string">'a1'</span> <span class="keyword">and</span> a2 = <span class="string">'a2'</span>  <span class="keyword">order</span> <span class="keyword">by</span> a4;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/索引失效oderby1.png" alt></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 =<span class="string">'a1'</span> <span class="keyword">and</span> a5 = <span class="string">'a5'</span>  <span class="keyword">order</span> <span class="keyword">by</span> a2,a3;</span><br><span class="line">使用到a1一个索引</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 =<span class="string">'a1'</span> <span class="keyword">and</span> a5= <span class="string">'a5'</span>  <span class="keyword">order</span> <span class="keyword">by</span> a3,a2;</span><br><span class="line">使用到a1索引，并且产生文件内排序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 =<span class="string">'a1'</span> <span class="keyword">and</span> a2 = <span class="string">'a2'</span>  <span class="keyword">order</span> <span class="keyword">by</span> a2,a3;</span><br><span class="line">使用到a1、a2两个索引，没有产生文件内排序</span><br><span class="line"></span><br><span class="line">原文：https://blog.csdn.net/weixin_39539399/article/details/80842750</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/索引失效oderby2.png" alt></p>
<p>5、group by使用不当导致索引失效</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 =<span class="string">'a1'</span><span class="keyword">and</span> a4 = <span class="string">'a4'</span> <span class="keyword">group</span> <span class="keyword">by</span> a2，a3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 =<span class="string">'a1'</span><span class="keyword">and</span> a4 = <span class="string">'a4'</span> <span class="keyword">group</span> <span class="keyword">by</span> a3，a2;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/索引失效groupby.png" alt></p>
<p>分组之前必排序，group by 表面上是分组，但是对索引的使用和order by 的使用大致相同，所以group by后面如果索引错乱，会产生临时表，导致mysql内部进行排序</p>
<p>6、通配符like的使用不当导致索引失效（like以通配符开头(“%abc…”) ）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 <span class="keyword">like</span> <span class="string">'%a'</span>;索引失效</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>  * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 <span class="keyword">like</span> <span class="string">'a%'</span>;索引不失效</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>  a1 <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 <span class="keyword">like</span> <span class="string">'%a'</span>;覆盖索引，解决最左匹配不当的索引失效问题</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>  * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 <span class="keyword">like</span> <span class="string">'c%'</span>;索引失效</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>  * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 <span class="keyword">like</span> <span class="string">'%c'</span>;索引失效</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>  * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> a1 <span class="keyword">like</span> <span class="string">'abc%'</span>;索引不失效</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/索引失效通配符like.png" alt></p>
<p>6、MYSQL 中!=,&lt;&gt;导致索引失效（is null, is not null 也无法使用索引）</p>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/索引失效等号.png" alt></p>
<p>尽量使用覆盖索引(只访问索引的查询),减少select *，可以解决索引失效的以上问题</p>
<p>7、少用or,用它来连接时索引会失效</p>
<p>关于or导致的索引失效，是有存在这种情况的，即or的左右边的查询条件，有一个列没有加索引，那么另一个列的索引会失效。要想使得索引生效，需要保证or两边的列都有索引，且一个列是主键。</p>
<p>小总结</p>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/索引总结1.png" alt></p>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/索引总结2.png" alt></p>
<p><img src="/2019/05/26/数据库/数据库之索引/数据库之索引/索引总结3.png" alt></p>
<p>索引的底层原理其实没有我总结那么简单，水平有限，B+B-树随缘再总结</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.jpg" alt="Beny">
            
              <p class="site-author-name" itemprop="name">Beny</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">74</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">16</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/1105397915" title="1105397915 &rarr; 1105397915"><i class="fa fa-fw fa-qq"></i>1105397915</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/benyzheng" title="GitHub &rarr; https://github.com/benyzheng" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/zhengbeny@qq.com" title="zhengbeny@qq.com &rarr; zhengbeny@qq.com"><i class="fa fa-fw fa-envelope"></i>zhengbeny@qq.com</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Beny</span>

  

  
</div>








<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共199.1k字</span>
</div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/libs/jquery/index.js?v=2.1.3"></script>

  
  <script src="/libs/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/libs/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>



  

  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  
  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="/js/src/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: 'oaY0uDqkCsuX94AxTtnV6scO-gzGzoHsz',
    appKey: 'HKU5SJPAd8KyYqk6Q8fdArL5',
    placeholder: '写了评论, offer还会远吗? ----记得填写邮箱哦~如果可以填写你的网站互相参考就更好啦',
    avatar: 'retro',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn'
  });
  //增加以下六行代码去除 power by valine
    var infoEle = document.querySelector('#comments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0){
      infoEle.childNodes.forEach(function(item) {
        item.parentNode.removeChild(item);
      });
    }
</script>





  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  

  

  

  

<!-- 页面点击小红心 -->
<!-- <script type="text/javascript" src="/js/src/click.js"></script>-->
</body>
</html>
