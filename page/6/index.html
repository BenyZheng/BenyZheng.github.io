<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/libs/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/libs/pace/pace-theme-flash.min.css?v=1.0.2">


















  
  
  
  

  
    
    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Monda:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|Monda:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext">
  






<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_small.ico?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.0',
    sidebar: {"position":"left","display":"hide","offset":12,"onmobile":true,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Beny&#39;s blog">
<meta property="og:url" content="https://benyzheng.github.io/page/6/index.html">
<meta property="og:site_name" content="Beny&#39;s blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Beny&#39;s blog">





  
  
  <link rel="canonical" href="https://benyzheng.github.io/page/6/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Beny's blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Beny's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Nothing worth having comes easy.</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签<span class="badge">14</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">64</span></a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

<a href="https://github.com/bengzheng" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/java集合类/集合类之SET/集合类之SET/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/java集合类/集合类之SET/集合类之SET/" class="post-title-link" itemprop="url">集合类之SET</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 23:55:57" itemprop="dateModified" datetime="2019-10-06T23:55:57+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T23:55:57+08:00" content="2019-10-06">
                2019-10-06 23:55:57
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/集合框架/" itemprop="url" rel="index"><span itemprop="name">集合框架</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/java集合类/集合类之SET/集合类之SET/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/java集合类/集合类之SET/集合类之SET/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="集合类之SET"><a href="#集合类之SET" class="headerlink" title="集合类之SET"></a>集合类之SET</h1><p>set集合可以存储多个对象，但并不会记住元素的存储顺序，也不允许集合中有重复元素(不同的set集合有不同的判断方法)。</p>
<h3 id="1-HashSet"><a href="#1-HashSet" class="headerlink" title="1.HashSet"></a>1.HashSet</h3><p>HashSet按照Hash算法存储集合中的元素，具有很好的存取和查找性能。当向HashSet中添加一些元素时，HashSet会根据该对象的HashCode()方法来得到该对象的HashCode值，然后根据这些HashCode的值来决定元素的位置。(HashSet的底层原理是HashMap)</p>
<p>HashSet的特点：1.存储顺序和添加的顺序不同</p>
<p>　　　　　　　　2.HashSet不是同步的，如果多个线程同时访问一个HashSet，假设有两个或更多的线程修改了                集合中的值，则必须通过代码使线程同步。</p>
<p>　　　　　　　　3.HastSet允许集合中的元素为null。</p>
<p>​                   4.非线程安全</p>
<p>在Hashset集合中，<strong>判断两个元素相同的标准是：两个对象通过equals()方法相等，且HashCode()方法的返回值也相等。</strong>如果有两个元素通过equals()方法比较相等，而HashCode()的返回值不同，HashSet会将这两个对象保存在不同的地方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;  </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;  </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5024744406713321676L</span>;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 底层使用HashMap来保存HashSet中所有元素。  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 默认的无参构造器，构造一个空的HashSet。 </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;();  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 构造一个包含指定collection中的元素的新set。 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 实际底层使用默认的加载因子0.75和足以包含指定 </span></span><br><span class="line"><span class="comment">     * collection中所有元素的初始容量来创建一个HashMap。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c 其中的元素将存放在此set中的collection。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));  </span><br><span class="line">    addAll(c);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 以指定的initialCapacity和loadFactor构造一个空的HashSet。 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 实际底层以相应的参数构造一个空的HashMap。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 初始容量。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadFactor 加载因子。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;  </span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(initialCapacity, loadFactor);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 以指定的initialCapacity构造一个空的HashSet。 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 初始容量。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;  </span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(initialCapacity);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 </span></span><br><span class="line"><span class="comment">     * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity 初始容量。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadFactor 加载因子。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dummy 标记。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;  </span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。 </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * 底层实际调用底层HashMap的keySet来返回所有的key。 </span></span><br><span class="line"><span class="comment">     * 可见HashSet中的元素，只是存放在了底层HashMap的key上， </span></span><br><span class="line"><span class="comment">     * value使用一个static final的Object对象标识。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对此set中元素进行迭代的Iterator。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回此set中的元素的数量（set的容量）。 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 此set中的元素的数量（set的容量）。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> map.size();  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 如果此set不包含任何元素，则返回true。 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果此set不包含任何元素，则返回true。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> map.isEmpty();  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 如果此set包含指定元素，则返回true。 </span></span><br><span class="line"><span class="comment">     * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e)) </span></span><br><span class="line"><span class="comment">     * 的e元素时，返回true。 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的containsKey判断是否包含指定key。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 在此set中的存在已得到测试的元素。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果此set包含指定元素，则返回true。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 如果此set中尚未包含指定元素，则添加指定元素。 </span></span><br><span class="line"><span class="comment">     * 更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2)) </span></span><br><span class="line"><span class="comment">     * 的元素e2，则向此set 添加指定的元素e。 </span></span><br><span class="line"><span class="comment">     * 如果此set已包含该元素，则该调用不更改set并返回false。 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 底层实际将将该元素作为key放入HashMap。 </span></span><br><span class="line"><span class="comment">     * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key </span></span><br><span class="line"><span class="comment">     * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）， </span></span><br><span class="line"><span class="comment">     * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， </span></span><br><span class="line"><span class="comment">     * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， </span></span><br><span class="line"><span class="comment">     * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 将添加到此set中的元素。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果此set尚未包含指定元素，则返回true。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 如果指定元素存在于此set中，则将其移除。 </span></span><br><span class="line"><span class="comment">     * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e， </span></span><br><span class="line"><span class="comment">     * 则将其移除。如果此set已包含该元素，则返回true </span></span><br><span class="line"><span class="comment">     * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的remove方法删除指定Entry。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 如果存在于此set中则需要将其移除的对象。 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果set包含指定元素，则返回true。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 从此set中移除所有元素。此调用返回后，该set将为空。 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的clear方法清空Entry中所有元素。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    map.clear();  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) <span class="keyword">super</span>.clone();  </span><br><span class="line">            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();  </span><br><span class="line">            <span class="keyword">return</span> newSet;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashSet所有方法都直接在HashMap上运用，了解HashMap自然可以了解HashSet。</p>
<p>其中需要了解一下HashSet的加载因子和容量：</p>
<p>在HashSet中我们new对象的时候会创建一个<strong>初始默认容量是16</strong>的HashSet集合；其中默认的一个值loadFactor：<br> 加载因子：0.75<br> 加载因子是数组的长度的百分比；16*0.75 = 12；<br> 意思就是数组中的桶数达到12个时数组就要扩容；（复制），扩容到原来的2倍；<br> 0.75是一个折中的数据；是增删改查的最优速度；<br> new的时候可以直接初始化数组长度和loadFactor（加载因子）来改变加载因子；</p>
<p>注意：</p>
<ul>
<li>对于HashSet中保存的对象，主要要正确重写equals方法和hashCode方法，以保证放入Set对象的唯一性</li>
<li>虽说是Set是对于重复的元素不放入，<strong>倒不如直接说是底层的Map直接把原值替代了</strong></li>
<li>HashSet没有提供get()方法，愿意是同HashMap一样，Set内部是无序的，只能通过迭代的方式获得</li>
</ul>
<h3 id="2-LinkedHashSet"><a href="#2-LinkedHashSet" class="headerlink" title="2.LinkedHashSet"></a>2.LinkedHashSet</h3><p>LinkedHashSet是继承自HashSet，底层实现是LinkedHashMap。并且其初始化时直接<code>super(......)</code></p>
<p>查看了LinkedHashMap的构造方法后，发现其因为继承自HashMap，所以其底层实现也是HashMap!!!，然后发现了LinkedHashMap调用父类构造方法初始化时，还顺便设置了变量<code>accessOrder = false</code>，看上面得源码可以知道，这是给了迭代器一个参数，<strong>false代表迭代时使用插入得顺序</strong></p>
<h3 id="3-TreeSet"><a href="#3-TreeSet" class="headerlink" title="3.TreeSet"></a>3.TreeSet</h3><p>1、TreeSet(树集)是一个有序集合，可以按照任何顺序将元素插入该集合，当对该集合进行迭代时，各个值将自动以排序后的顺序出现。TreeSet中的元素按照升序排列，缺省是按照自然顺序进行排序，意味着TreeSet中的元素要实现Comparable接口，或者有一个自定义的比较器Comparator。</p>
<p>2、TreeSet底层使用的是TreeMap，TreeMap的底层实现是红黑树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public TreeSet()</span><br><span class="line">&#123;</span><br><span class="line">       this(new TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>　　1、TreeSet的排列顺序必须是全局顺序，也就是说任何两个元素都是必须可比的，同时只有当他们比较相同时才返回0。</p>
<p>　　2、如果树集包含了n个元素，那么平均需要进行log2n次比较，才能找到新元素的正确位置。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/数据库/数据库之事务和锁机制/数据库之事务和锁机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/数据库/数据库之事务和锁机制/数据库之事务和锁机制/" class="post-title-link" itemprop="url">数据库之事务和锁机制</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 23:42:01" itemprop="dateModified" datetime="2019-10-06T23:42:01+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T23:42:01+08:00" content="2019-10-06">
                2019-10-06 23:42:01
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/数据库/数据库之事务和锁机制/数据库之事务和锁机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/数据库/数据库之事务和锁机制/数据库之事务和锁机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据库之事务和锁机制"><a href="#数据库之事务和锁机制" class="headerlink" title="数据库之事务和锁机制"></a>数据库之事务和锁机制</h1><p><img src="/2019/05/26/数据库/数据库之事务和锁机制/数据库之事务和锁机制/事务思维导图.png" alt></p>
<h3 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h3><p>事务的概念：事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元，要么全部执行，要么全部不执行。</p>
<p>1、原子性（Atomicity）</p>
<p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，如果操作失败则不能对数据库有任何影响，任何一项操作都会导致整个事务的失败，同时其它已经被执行的操作都将被撤销并回滚，只有所有的操作全部成功，整个事务才算是成功完成。</p>
<p>2、一致性（Consistency）</p>
<p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<p>3、隔离性（lsolation）</p>
<p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>
<p>4、持久性（durability）</p>
<p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<p>例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>
<h3 id="事务并发引起的问题"><a href="#事务并发引起的问题" class="headerlink" title="事务并发引起的问题"></a>事务并发引起的问题</h3><p>1、脏读（dirty read）</p>
<p>　　当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。</p>
<p>例如：用户A向用户B转账100元</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> money=money+<span class="number">100</span> <span class="keyword">where</span> <span class="keyword">name</span>=’B’;  (此时A通知B)</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> money=money - <span class="number">100</span> <span class="keyword">where</span> <span class="keyword">name</span>=’A’;</span><br><span class="line">以上两条sql语句为转账事务</span><br></pre></td></tr></table></figure>
<p>转账是一个事务，通知查看是一个事务。</p>
<p>当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（<strong>此时即发生了脏读</strong>）</p>
<p>而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚</p>
<p>那么当B以后再次查看账户时就会发现钱其实并没有转。</p>
<p>脏读就是一个事务读取了另一个事务未提交的脏数据</p>
<p>2、不可重复读（unrepeatable reading）</p>
<p>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p>
<p>例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。</p>
<p>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</p>
<p>在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就产生矛盾。</p>
<p>3、幻读（Phantom read）</p>
<p>幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p>
<p>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p>
<h3 id="事务的四种隔离级别"><a href="#事务的四种隔离级别" class="headerlink" title="事务的四种隔离级别"></a>事务的四种隔离级别</h3><ul>
<li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</li>
<li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</li>
<li>Read committed (读已提交)：可避免脏读的发生。</li>
<li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</li>
</ul>
<p>以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别。级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。</p>
<p>隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效。</p>
<p>对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。</p>
<p>### </p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/数据库/Redis/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/数据库/Redis/Redis/" class="post-title-link" itemprop="url">Redis</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 23:43:15" itemprop="dateModified" datetime="2019-10-06T23:43:15+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T23:43:15+08:00" content="2019-10-06">
                2019-10-06 23:43:15
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/数据库/Redis/Redis/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/数据库/Redis/Redis/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p>NoSQL = not only SQL</p>
<p>非关系型数据库</p>
<p>为什么需要NoSQL</p>
<ul>
<li>High Performance - 高并发读写</li>
<li>Huge Storage - 海量数据的高效率存储和访问</li>
<li>HIgh Scalability&amp;&amp;High Availability - 高可扩展性和高可用性</li>
</ul>
<p>NoSQL数据库的四大分类</p>
<ul>
<li>键值对(key-value)存储</li>
<li>列存储</li>
<li>文档数据库</li>
<li>图形数据库</li>
</ul>
<p><img src="/2019/05/26/数据库/Redis/Redis/NoSQL四种类型比较.png" alt></p>
<p>NoSQL的特点：</p>
<ul>
<li>易扩展</li>
<li>灵活的数据模型</li>
<li>大数据量</li>
<li>高可用</li>
</ul>
<h3 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h3><p>支持的键值数据类型：</p>
<ul>
<li>字符串类型</li>
<li>散列类型</li>
<li>列表类型</li>
<li>集合类型</li>
<li>有序集合类型</li>
</ul>
<p>读每秒11万次，写每秒8万次</p>
<p>Redis应用场景：</p>
<ul>
<li>缓存</li>
<li>任务队列</li>
<li>应用排行榜</li>
<li>网站访问统计</li>
<li>数据过期处理</li>
<li>分布式集群架构中的session分离</li>
</ul>
<h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><p>Jedis是Redis官方首选的java客户端开发包</p>
<h3 id="Redis的数据结构"><a href="#Redis的数据结构" class="headerlink" title="Redis的数据结构"></a>Redis的数据结构</h3><ul>
<li>字符串（String）</li>
<li>哈希（hash）</li>
<li>字符串列表（list）</li>
<li>字符串集合（set）</li>
<li>有序字符串集合（sorted set）</li>
</ul>
<h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><p>需要持久化的原因：Redis将数据存在内存中，容易丢失数据，需要将数据存进硬盘，称为持久化</p>
<p>两种持久化的方式</p>
<ul>
<li>RDB方式</li>
<li>AOF方式</li>
</ul>
<p>持久化的四种方式：</p>
<p>RDB方式：默认支持、不需要进行配置，在指定的时间间隔内，将内存中的数据集快照写入硬盘</p>
<p>AOF方式：以日记的方式记录服务器处理的每一个操作，当重启时，会读取文件进行重建数据库，保证启动时数据库中的数据的完整</p>
<p>无持久化：通过日志禁止数据库持久化的功能</p>
<p>同时使用RDB方式和AOF方式</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/数据库/数据库之基础知识/数据库之基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/数据库/数据库之基础知识/数据库之基础知识/" class="post-title-link" itemprop="url">数据库之基础知识</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 22:33:39" itemprop="dateModified" datetime="2019-10-06T22:33:39+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T22:33:39+08:00" content="2019-10-06">
                2019-10-06 22:33:39
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/数据库/数据库之基础知识/数据库之基础知识/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/数据库/数据库之基础知识/数据库之基础知识/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据库之基础知识"><a href="#数据库之基础知识" class="headerlink" title="数据库之基础知识"></a>数据库之基础知识</h1><h3 id="命令行操作MySQL"><a href="#命令行操作MySQL" class="headerlink" title="命令行操作MySQL"></a>命令行操作MySQL</h3><p>DOS命令</p>
<p><code>盘符+冒号</code> 切换逻辑盘 如：<code>d:</code><br><code>dir</code> 显示目录和文件列表<br><code>cd 目录名</code> 进入目录<br><code>cd ../</code> 进入上一级目录<br><code>cd ./</code> 进入当前目录<br><code>cd /</code> 进入根目录<br><code>exit</code> 退出命令行</p>
<p>连接数据库</p>
<p>语法：mysql -h主机名 -u用户名 -p密码<br>如：mysql -hlocalhost -uroot -proot<br>注意：当提示符变成 mysql&gt; 说明我们已经进入mysql命令行模式，只能使用sql指令<br>sql指令都需要以分号 ; 结束<br>quit 退出mysql</p>
<p>exit 退出命令行</p>
<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><p>创建数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库名</span><br></pre></td></tr></table></figure>
<p>显示数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">database</span>；显示服务器上的所有的数据库列表破</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">database</span> <span class="keyword">like</span> <span class="string">'%a%'</span>; like 子命令，显示所有名字里带a的数据库名</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span> <span class="keyword">like</span> <span class="string">'___'</span>; like 子命令，显示数据库名是三个字符的所有数据库名</span><br><span class="line">% 匹配0个或者多个任意字符</span><br><span class="line">_ 下划线，匹配任意一个字符</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">database</span> 数据库名; 查看建立数据库的语句</span><br></pre></td></tr></table></figure>
<p>修改数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> 数据库名 <span class="keyword">charset</span>=gbk; 修改指定的数据库的字符集，只能修改数据的字符集，数据库名不能修改。</span><br></pre></td></tr></table></figure>
<p>删除数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> 数据库名; 删除指定的数据库</span><br></pre></td></tr></table></figure>
<p>MySQL里面的三个数据库mysql、information_schema、performance_schema是系统默认自带的，不可删除，删了需重装MySQL</p>
<h3 id="数据库操作-1"><a href="#数据库操作-1" class="headerlink" title="数据库操作"></a>数据库操作</h3><p>创建数据表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(<span class="keyword">id</span> <span class="built_in">int</span>,username <span class="built_in">varchar</span>(<span class="number">30</span>),<span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">30</span>));</span><br></pre></td></tr></table></figure>
<p>查看表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>; 查看所有的数据表</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名; 查看数据表的建表语句</span><br><span class="line">desc 表名; 查看数据表的结构</span><br></pre></td></tr></table></figure>
<p>删除表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名; 查看数据表的结构</span><br></pre></td></tr></table></figure>
<p>修改表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">engine</span>=<span class="keyword">innodb</span>; 可以修改默认引擎</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">charset</span>=gbk; 可以修改字符集</span><br><span class="line"><span class="keyword">rename</span> <span class="keyword">table</span> 表名 <span class="keyword">to</span> 另一个表名; 可以修改表名</span><br></pre></td></tr></table></figure>
<h3 id="字段操作"><a href="#字段操作" class="headerlink" title="字段操作"></a>字段操作</h3><p>增加新字段</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">add</span> <span class="keyword">column</span> gender <span class="built_in">varchar</span>(<span class="number">2</span>);</span><br><span class="line">在student数据表中新增gender字段</span><br></pre></td></tr></table></figure>
<p>修改字段的类型和属性</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">modify</span> <span class="keyword">column</span> gender <span class="built_in">varchar</span>(<span class="number">10</span>);</span><br><span class="line">修改student数据表中gender字段数据类型</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">modify</span> <span class="keyword">column</span> gender <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">after</span> 另一个字段;</span><br><span class="line">修改student数据表中gender字段数据类型，并且在数据表中排在 “另一个字段” 后面</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">modify</span> <span class="keyword">column</span> gender <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">first</span>;</span><br><span class="line">修改student数据表中gender字段数据类型，并且在数据表中排在第一位</span><br></pre></td></tr></table></figure>
<p>修改字段的名字和定义</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">change</span> <span class="keyword">column</span> gender sex <span class="built_in">varchar</span>(<span class="number">2</span>);</span><br><span class="line">把student数据表中gender字段名字改为sex，数据类型改为varchar(2);</span><br></pre></td></tr></table></figure>
<p>删除字段</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">drop</span> <span class="keyword">column</span> gender;</span><br><span class="line">删除student数据表中的gender字段;</span><br></pre></td></tr></table></figure>
<h3 id="记录操作"><a href="#记录操作" class="headerlink" title="记录操作"></a>记录操作</h3><p>新增记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(字段列表) <span class="keyword">values</span> (值的列表);</span><br><span class="line">例子：</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(username) <span class="keyword">values</span>(<span class="string">'中文'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(<span class="keyword">id</span>,username,age) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'中文'</span>,<span class="number">20</span>);</span><br><span class="line">批量新增：</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(<span class="keyword">id</span>,username,age) <span class="keyword">values</span> (<span class="number">3</span>,<span class="string">'张三'</span>,<span class="number">18</span>),(<span class="number">4</span>,<span class="string">'李四'</span>,<span class="number">20</span>),(<span class="number">5</span>,<span class="string">'刘五'</span>,<span class="number">22</span>);</span><br><span class="line">值的个数与数据表中的字段个数一样时，可以省略字段列表</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'中文'</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>查询记录</p>
<p>完整语句：<br>select [字段列表] [from子句] [inner join子句] [where子句] [group by子句] [having子句] [order by子句] [limit子句];</p>
<p>一般使用：</p>
<p>select [字段列表] [from子句] [where子句] [order by子句] [limit子句];</p>
<p>[where子句] 用于过滤数据，只取出满足条件的记录</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where age &gt;= 20; 查询出 age &gt;= 20的记录</span><br></pre></td></tr></table></figure>
<p>[order by子句] 用于对查询出的数据进行排序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> age &gt;= <span class="number">20</span> <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>; 年龄升序排列</span><br></pre></td></tr></table></figure>
<p>asc升序排列 （从小到大）、desc 降序排序 （从大到小）</p>
<p>[limit子句] 用于限制输出数据的条数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">limit n; 提取前 n 条数据</span><br><span class="line">limit m,n; 从 第 m 条开始提取 n 条数据**（m 从 0 开始）**</span><br><span class="line">select * from student where age &gt;= 20 order by age asc limit 2; 查询出 age &gt;= 20的记录年龄，升序排列，提取前 2 条</span><br></pre></td></tr></table></figure>
<p>修改记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段名<span class="number">1</span>=新的值<span class="number">1</span>,字段名<span class="number">2</span>=新的值<span class="number">2</span>,字段名n=新的值n <span class="keyword">where</span> 子句;</span><br><span class="line">例子：</span><br><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> age=<span class="number">25</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>删除记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 子句;</span><br><span class="line">例子：</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<h3 id="mysql中常用数据类型"><a href="#mysql中常用数据类型" class="headerlink" title="mysql中常用数据类型"></a>mysql中常用数据类型</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>INT(size)</td>
<td>4字节整数类型，-2147483648 到 2147483647 常规。0 到 4294967295 无符号*。在括号中规定最大位数，默认是11。</td>
</tr>
<tr>
<td>BIGINT(size)</td>
<td>8字节整数类型，-9223372036854775808 到 9223372036854775807 常规。0 到 18446744073709551615 无符号*。在括号中规定最大位数。默认是20。</td>
</tr>
<tr>
<td>FLOAT(size,d)</td>
<td>字节浮点数，带有浮动小数点的小数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。</td>
</tr>
<tr>
<td>CHAR(size)</td>
<td>保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。</td>
</tr>
<tr>
<td>VARCHAR(size)</td>
<td>保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。注释：如果值的长度大于 255，则被转换为 TEXT 类型。</td>
</tr>
<tr>
<td>TEXT</td>
<td>存放最大长度为 65,535 个字符的字符串。</td>
</tr>
<tr>
<td>DATE()</td>
<td>日期。格式：YYYY-MM-DD 注释：支持的范围是从 ‘1000-01-01’ 到 ‘9999-12-31’</td>
</tr>
<tr>
<td>DATETIME()</td>
<td>*日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS 注释：支持的范围是从 ‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td>
</tr>
<tr>
<td>TIMESTAMP()</td>
<td>*时间戳。TIMESTAMP 值使用 Unix 纪元(‘1970-01-01 00:00:00’ UTC) 至今的描述来存储。格式：YYYY-MM-DD HH:MM:SS 注释：支持的范围是从 ‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-09 03:14:07’ UTC</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/数据结构/1 算法的复杂度/算法复杂度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/数据结构/1 算法的复杂度/算法复杂度/" class="post-title-link" itemprop="url">算法复杂度</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 22:10:45" itemprop="dateModified" datetime="2019-10-06T22:10:45+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T22:10:45+08:00" content="2019-10-06">
                2019-10-06 22:10:45
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/数据结构/1 算法的复杂度/算法复杂度/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/数据结构/1 算法的复杂度/算法复杂度/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p>算法是对问题求解步骤的描述，通过有限序列的指令来实现</p>
<p>五大特征</p>
<ul>
<li>有穷性：有限步之后结束</li>
<li>确定性：不存在二义性</li>
<li>可行性</li>
<li>输入</li>
<li>输出</li>
</ul>
<h6 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h6><p>用来衡量算法随着问题规模增大，算法执行时间的增大的快慢</p>
<p>时间复杂度是问题规模的函数：T(n)</p>
<p>T(n)=O(f(n))，大O记法</p>
<p>计算方法： 算法时间增长最快的那个函数项，把它的系数改为1</p>
<h6 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h6><ul>
<li>用来衡量算法随问题规模增大，算法所需空间的增长的快慢</li>
<li>是问题规模的函数：S(n)=O(g(n))</li>
</ul>
<p>常见的时间复杂度大小关系</p>
<p>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n2)&lt;O(n3)&lt;O(2n)</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/数据结构/3 栈和队列/栈和队列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/数据结构/3 栈和队列/栈和队列/" class="post-title-link" itemprop="url">栈和队列</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 22:14:39" itemprop="dateModified" datetime="2019-10-06T22:14:39+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T22:14:39+08:00" content="2019-10-06">
                2019-10-06 22:14:39
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/数据结构/3 栈和队列/栈和队列/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/数据结构/3 栈和队列/栈和队列/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>只允许在一端进行插入或删除操作的线性表</p>
<p>栈顶：栈中允许进行插入和删除的哪一端</p>
<p>栈底：固定的，不允许进行插入和删除的另一端</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	Elemtype data[MaxSize];<span class="comment">//存放栈中的元素</span></span><br><span class="line">	<span class="keyword">int</span> top;<span class="comment">//栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>
<ul>
<li>top值不能超过MaxSize</li>
<li>空栈的判定条件通常定为top==-1，满栈的判定条件通常为top==MaxSize-1，栈中数据元素个数为top+1</li>
</ul>
<h5 id="顺序栈的操作"><a href="#顺序栈的操作" class="headerlink" title="顺序栈的操作"></a>顺序栈的操作</h5><h6 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.top==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.data[++S.top]=x; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S.data[S.top--];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="获取栈顶元素"><a href="#获取栈顶元素" class="headerlink" title="获取栈顶元素"></a>获取栈顶元素</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h5><p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/共享栈.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype data[MaxSize];<span class="comment">//存放栈中的元素</span></span><br><span class="line">    <span class="keyword">int</span> top1;<span class="comment">//栈1栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> top2;<span class="comment">//栈2栈顶指针</span></span><br><span class="line">&#125;SqDoubleStack;</span><br></pre></td></tr></table></figure>
<h6 id="进栈-1"><a href="#进栈-1" class="headerlink" title="进栈"></a>进栈</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqDoubleStack &amp;S,ElemType x,<span class="keyword">int</span> stackNum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top1+<span class="number">1</span>==S.top2) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//栈满</span></span><br><span class="line">    <span class="keyword">if</span>(stackNum==<span class="number">1</span>) 			</span><br><span class="line">        S.data[++S.top1]=x;<span class="comment">//栈1有元素进栈</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stackNum==<span class="number">2</span>) S.data[--S.top2]=x;<span class="comment">//栈2有元素进栈</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h5><p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/链式栈结构.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">    Elemtype data;<span class="comment">//存放栈中的元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">next</span>//栈顶指针</span></span><br><span class="line"><span class="class">&#125;<span class="title">SNode</span>,*<span class="title">SLink</span>//链栈结点</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class"><span class="title">typedef</span> <span class="title">struct</span> <span class="title">LinkStack</span>&#123;</span></span><br><span class="line">	SLink top;<span class="comment">//栈顶指针</span></span><br><span class="line">	<span class="keyword">int</span> count;<span class="comment">//链栈结点数</span></span><br><span class="line">&#125;LinkStack</span><br></pre></td></tr></table></figure>
<ul>
<li>链栈没有栈满的情况</li>
<li>链栈空为top==null</li>
</ul>
<h6 id="进栈-2"><a href="#进栈-2" class="headerlink" title="进栈"></a>进栈</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(LinkStack *S,ElemType x)</span></span>&#123;</span><br><span class="line">    SLink p=(SLink)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SNode));<span class="comment">//给新元素分配空间</span></span><br><span class="line">    p-&gt;data=x;<span class="comment">//新元素的值</span></span><br><span class="line">    p-next=S-&gt;top;<span class="comment">//p的后继指向栈顶元素</span></span><br><span class="line">    S-&gt;top=p;<span class="comment">//栈顶指针指向新的元素</span></span><br><span class="line">    S-&gt;count++;<span class="comment">//栈中元素个数加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/链式栈进栈.png" alt></p>
<h6 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(LinkStack *S,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x=S-&gt;top-&gt;data;<span class="comment">//栈顶元素值</span></span><br><span class="line">    SLink p=S-&gt;top;<span class="comment">//辅助指针</span></span><br><span class="line">    S-&gt;top=S-&gt;top-&gt;next;<span class="comment">//栈顶指针后移</span></span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//释放被删除数据的存储空间</span></span><br><span class="line">    S-&gt;count--;<span class="comment">//栈中元素个数减一</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/链式栈出栈.png" alt></p>
<h5 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h5><h6 id="括号配对"><a href="#括号配对" class="headerlink" title="括号配对"></a>括号配对</h6><p>假设有两种括号，一种圆的()，一种方的[]，嵌套的顺序是任意的</p>
<p>算法思路：</p>
<p>若是左括号，入栈；若是右括号，出栈一个左括号判断是否与之匹配；检验到字符串尾，还要检查栈是否为空。只有栈空整个字符串才是括号匹配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span> s;</span><br><span class="line">    InitStack(s);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);<span class="comment">//字符串长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> a=str[i];</span><br><span class="line">        <span class="keyword">switch</span>(a)&#123;</span><br><span class="line">        	<span class="keyword">case</span> <span class="string">'('</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'['</span>;</span><br><span class="line">                Push(s,a);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">')'</span>;</span><br><span class="line">                <span class="keyword">if</span>(Pop(s)!=<span class="string">'('</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//出栈顶，如果不匹配直接返回不合法</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">']'</span>;</span><br><span class="line">                <span class="keyword">if</span>(Pop(s)!=<span class="string">']'</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Empty(s)) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//匹配完所有括号最后要求栈中为空</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h6><p>从左到右，先乘除后加减，右括号先算括号</p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/表达式.png" alt></p>
<p>后缀表达式做法：</p>
<p>规则：从左到右扫描表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈然后跟这个符号进行运算，最后将结果进栈，直到最终获得结果</p>
<p> 如何将中缀表达式转换成后缀表达式（计算机也是用到栈取转换，下面是手动方法）</p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/中缀转后缀.png" alt></p>
<h6 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h6><p>递归最重要的是递归式和递归边界</p>
<p>使用递归求解n的阶乘</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//递归边界</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> n*F(n<span class="number">-1</span>);<span class="comment">//递归式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求斐波拉契数列的第n项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Fib(n<span class="number">-1</span>)+Fib(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/斐波拉契数列递归.png" alt></p>
<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>队列是只允许在一端进行插入，而在另一端进行删除的线性表</p>
<p>队头（Front）：允许删除的一端，队首</p>
<p>队尾（Rear）：允许插入的一端</p>
<h6 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h6><p>用数组实现队列，可以将队首放在数组下标为0的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];<span class="comment">//存放队列的元素</span></span><br><span class="line">    <span class="keyword">int</span> front,rear;<span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/队列假溢出.png" alt></p>
<h6 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h6><p>入队：rear=(rear+1)%MaxSize</p>
<p>出队：front=(front+1)%MaxSize</p>
<p>判断队列是空是满</p>
<ul>
<li>设置标志位flag，当flag=0且rear等于front时为队列空，当flag=1且rear等于front时为队列满（入队时flag等于1，出队时flag等于0）</li>
<li><strong>把front==rear仅作为队空的判定条件</strong>。当队列满的时候，令数组中仍然保留一个空余单元。认为这种情况就是队列满了</li>
</ul>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/循环队列队满判断.png" alt></p>
<p>队满关系</p>
<p>(rear+1)%MaxSize==front</p>
<p>队列中元素个数</p>
<p>(rear-front+MaxSize)%MaxSize</p>
<h6 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front) <span class="keyword">return</span> flase;<span class="comment">//队满</span></span><br><span class="line">    Q.data[Q.rear]=x;</span><br><span class="line">    Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//队空，报错</span></span><br><span class="line">	x=Q.data[Q.front];</span><br><span class="line">    Q.front=(Q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h5><p>队列的链式存储结构，其实就是线性表的单链表，只不过需要加点限制，只能表尾插入元素，表头删除元素</p>
<p>分别设置队头指针和队尾指针，队头指针指向头结点，队尾指针指向队尾结点</p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/链式队列.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//链式队列结点</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//链式队列</span></span><br><span class="line">    LinkNode *front,*rear;<span class="comment">//队头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>
<h6 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">    s=(LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=s;</span><br><span class="line">    Q.rear=s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/链式队列入队.png" alt></p>
<h6 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h6><p>出队就是头结点的后继结点出队，然后将头结点的后继改为它后面的结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//空队</span></span><br><span class="line">    p=Q.front-&gt;next;</span><br><span class="line">    x=p-&gt;data;</span><br><span class="line">    Q.front-&gt;next=p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==p) Q.rear=Q.front;<span class="comment">//若原队列中只有一个结点，删除后变空</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/链式队列出队.png" alt></p>
<h5 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h5><p>双端队列是指允许两端都可以进行入队和出队操作的队列</p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/双端队列结构.png" alt></p>
<h5 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h5><p>对于二维数组，两种映射方法：按行优先和按列优先</p>
<p>行优先</p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/行优先.png" alt></p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/行优先计算.png" alt></p>
<p>列优先</p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/列优先.png" alt></p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/列优先计算.png" alt></p>
<h6 id="矩阵的压缩存储"><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h6><p>对称矩阵</p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/对角矩阵.png" alt></p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/对角矩阵计算.png" alt></p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/对角矩阵计算2.png" alt></p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/对角矩阵计算3.png" alt></p>
<p>三角矩阵</p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/三角矩阵.png" alt></p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/三角矩阵计算.png" alt></p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/三角矩阵计算1.png" alt></p>
<p>三对角矩阵</p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/三对角矩阵.png" alt></p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/三对角矩阵2.png" alt></p>
<p>稀疏矩阵</p>
<p><img src="/2019/05/26/数据结构/3 栈和队列/栈和队列/稀疏矩阵.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/数据结构/2 线性表/线性表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/数据结构/2 线性表/线性表/" class="post-title-link" itemprop="url">线性表</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 22:13:24" itemprop="dateModified" datetime="2019-10-06T22:13:24+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T22:13:24+08:00" content="2019-10-06">
                2019-10-06 22:13:24
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/数据结构/2 线性表/线性表/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/数据结构/2 线性表/线性表/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p>线性表是具有相同数据类型的n(n&gt;=0)个数据元素的有限序列</p>
<p>线性表的顺序存储是用一组<strong>地址连续</strong>的存储单元，依次存储线性表中的数据元素，顺序存储的线性表也叫顺序表</p>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/顺序表的存储结构.png" alt></p>
<p>静态建表：</p>
<ul>
<li>存储空间的起始位置</li>
<li>顺序表最大存储容量</li>
<li>顺序表当前的长度</li>
</ul>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/顺序表结构体.png" alt></p>
<p>数组是静态分配的（大小固定）</p>
<p>其实存储空间（数组）还可以动态分配，也就是存储数组的空间是在程序执行过程中通过动态分配语句来分配的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Elemtype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *data;<span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize,length;<span class="comment">//数组的最大容量和当前个数</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">动态分配语句</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 100</span></span><br><span class="line">SeqList L;</span><br><span class="line">L.data=(ElemType*)<span class="built_in">malloc</span>(sezeof(ElemType)*InitSize);</span><br></pre></td></tr></table></figure>
<p>动态分配并不是链式存储，同样还是属于顺序存储结构，只是分配的空间大小可以在运行时决定</p>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/顺序存储特点总结.png" alt></p>
<h5 id="顺序表的操作"><a href="#顺序表的操作" class="headerlink" title="顺序表的操作"></a>顺序表的操作</h5><h6 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在顺序表L的第i（1&lt;=i&lt;=L.length）个位置插入新元素e。如果i的输入不合法，则返回false,表示插入失败；否则，将顺序表的第i个元素以及其后的所有元素右移一个位置，腾出一个空位置插入新元素e，顺序表长度增加1，插入成功，返回true</span><br><span class="line"></span><br><span class="line">bool ListInsert(SqlList &amp;L,int i,ElemType e)&#123;</span><br><span class="line">	if(i&lt;1||i&gt;L.length+1)//判断i的范围是否有效</span><br><span class="line">	return false;</span><br><span class="line">	if(L.length&gt;=MaxSize)//当前的存储空间已满，不能插入</span><br><span class="line">		return false;</span><br><span class="line">	for(int j=L.length;j&gt;=i;j--)//将第i个元素及之后的元素后移</span><br><span class="line">		L.data[j]=L.data[j-1];</span><br><span class="line">	L.data[i-1]=e;</span><br><span class="line">	L.lengt++;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/顺序表插入复杂度.png" alt></p>
<h6 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">删除顺序表L中第i（1&lt;=i&lt;=L.length）个位置的元素，成功则返回true，并将被删除的元素用应用变量e返回；否则返回false</span><br><span class="line"></span><br><span class="line">bool ListDelete(SqList &amp;L,int i,ElemType &amp;e)&#123;</span><br><span class="line">	if(i&lt;1||i&gt;L.length+1)//判断i的范围是否有效</span><br><span class="line">		return false;</span><br><span class="line">	e=L.data[i-1];</span><br><span class="line">	for(int j=i;j&lt;L.length;j++)</span><br><span class="line">		L.data[j-1]=L.data[j];</span><br><span class="line">	L.length--;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/顺序表删除复杂度.png" alt></p>
<p>优点：</p>
<ul>
<li>存储密度大，不需要为表中元素之间的逻辑关系增加额外存储空间</li>
<li>随机存取：可以快速存取表中任一位置的元素</li>
</ul>
<p>缺点：</p>
<ul>
<li>插入和删除需要移动大量元素</li>
<li>对存储空间要求高，会产生存储空间的碎片</li>
</ul>
<h5 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h5><p> 线性表的链式存储是指通过一组任意的存储单元来存储线性表中的数据元素。为了建立起数据元素之间的线性关系，每个链表结点，除了存放元素自身的信息之外，还需要存放一个指向其后继的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;<span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure>
<p>通常用“头指针”来标识一个单链表，例如LinkList L，那么头指针L代表一个单链表</p>
<p>单链表第一个结点之前附加一个结点，称为头结点，头结点的数据域可以不设任何信息，也可以记录表长等相关信息。头结点的指针域指向线性表的第一个元素结点。</p>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/头指针.png" alt></p>
<h5 id="单链表操作"><a href="#单链表操作" class="headerlink" title="单链表操作"></a>单链表操作</h5><h6 id="头插法建立单链表"><a href="#头插法建立单链表" class="headerlink" title="头插法建立单链表"></a>头插法建立单链表</h6><p>建立新的结点分配内存空间，将新结点插入当前链表的表头</p>
<p> <img src="/2019/05/26/数据结构/2 线性表/线性表/头插法建立链表.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认有空的头结点</span></span><br><span class="line"><span class="function">LinkList <span class="title">CreatList1</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">	<span class="keyword">int</span> x;<span class="comment">//存储插入结点的数据的值</span></span><br><span class="line">	L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建头结点</span></span><br><span class="line">	L-&gt;next=<span class="literal">NULL</span>;<span class="comment">//初始化为空链表</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);<span class="comment">//输入结点的值</span></span><br><span class="line">	<span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;<span class="comment">//输入9999表示结束</span></span><br><span class="line">		s=(LNode*)<span class="built_in">malloc</span>(sizeif(LNode));<span class="comment">//创建新结点</span></span><br><span class="line">		s-&gt;data=x;<span class="comment">//对新结点的数据域赋值</span></span><br><span class="line">		s-&gt;next=L-&gt;next;<span class="comment">//新结点的后继指向第一个结点</span></span><br><span class="line">		L-&gt;next=s;<span class="comment">//头结点的后继指向新结点</span></span><br><span class="line">        sanf(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="尾插法建立单链表"><a href="#尾插法建立单链表" class="headerlink" title="尾插法建立单链表"></a>尾插法建立单链表</h6><p>建立新的结点分配内存空间，将新的结点插入到当前链表的表尾</p>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/尾插法建立链表.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">CreatList2</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x;<span class="comment">//存储插入结点的数据的值</span></span><br><span class="line">	L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建头结点</span></span><br><span class="line">    LNode *s,*r=L;<span class="comment">//r为表尾指针，指向表尾</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);<span class="comment">//输入结点的值</span></span><br><span class="line">	<span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;<span class="comment">//输入9999表示结束</span></span><br><span class="line">		s=(LNode*)<span class="built_in">malloc</span>(sizeif(LNode));<span class="comment">//创建新结点</span></span><br><span class="line">		s-&gt;data=x;<span class="comment">//对新结点的数据域赋值</span></span><br><span class="line">		r-&gt;next=s;</span><br><span class="line">        r=s;</span><br><span class="line">        sanf(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">	&#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="按序号查找结点"><a href="#按序号查找结点" class="headerlink" title="按序号查找结点"></a>按序号查找结点</h6><p>在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">GEtElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">1</span>;<span class="comment">//计数，初始为1</span></span><br><span class="line">	LNode *p=L-&gt;next;<span class="comment">//第一个结点指针赋给p</span></span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">return</span> L;<span class="comment">//若i等于0，返回头结点</span></span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;j&lt;i)&#123;<span class="comment">//从第一个结点开始找，查找第i个结点</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按值查找结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">Locate</span><span class="params">(LinkList L,ElemType e)</span></span>&#123;</span><br><span class="line">	LNode *p=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;data!=e)&#123;<span class="comment">//从第一个结点开始找</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="插入新结点"><a href="#插入新结点" class="headerlink" title="插入新结点"></a>插入新结点</h6><p>插入操作是将值为x的新结点插入到单链表的第i个位置上。先检查插入位置和合法性，然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点</p>
<p>算法思路：</p>
<ol>
<li>取指向插入位置的前驱结点的指针p=GetElem(L,i-1);</li>
<li>取新结点<em>s的指针域指向 </em>p的后继结点s-&gt;next=p-&gt;next</li>
<li>令结点<em>p的指针域指向新插入的结点 </em>s p-&gt;next=s;</li>
</ol>
<h6 id="删除一个结点"><a href="#删除一个结点" class="headerlink" title="删除一个结点"></a>删除一个结点</h6><p>删除操作是将单链表的第i个结点删除，先检查删除位置的合法性，然后查找表中第i-1个结点，即被删除结点的前驱结点，再将其删除</p>
<p>算法思路：</p>
<ol>
<li>取指向删除位置的前驱结点的指针 p=GetElem(L,i-1);</li>
<li>取指向删除位置的指针 q=p-&gt;next;</li>
<li>p指向结点的后继指向被删除结点的后继 p-&gt;next=q-&gt;next</li>
</ol>
<h5 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">    structLNode *node;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span><span class="comment">//前驱和后继指针</span></span><br><span class="line">&#125;DNode,*DLinkList;</span><br></pre></td></tr></table></figure>
<h6 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h6><ol>
<li>s-&gt;next=p-&gt;next</li>
<li>p-next-&gt;prior=s</li>
<li>s-&gt;prior=p</li>
<li>p-&gt;next=s</li>
</ol>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/双链表插入.png" alt></p>
<h6 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h6><ol>
<li>p-&gt;next=q-&gt;next</li>
<li>q-&gt;next-&gt;prior=p</li>
<li>free(q)</li>
</ol>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/双链表删除.png" alt></p>
<h5 id="循环链表-amp-静态链表"><a href="#循环链表-amp-静态链表" class="headerlink" title="循环链表&amp;静态链表"></a>循环链表&amp;静态链表</h5><p>循环单链表：循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环</p>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/循环单链表结构.png" alt></p>
<p>循环单链表的判空条件不是头结点的后继指针是否为空，而是它是否等于头指针</p>
<p>循环双链表</p>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/循环双链表结构.png" alt></p>
<p>静态链表</p>
<p>使用数组来描述线性表的链式存储结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50<span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType<span class="comment">//静态链表的数据类型假定为int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	ElemType data;<span class="comment">//数据域，存储数据元素</span></span><br><span class="line">	<span class="keyword">int</span> next;<span class="comment">//指针域，下一个元素的数组下标</span></span><br><span class="line">&#125;SLinkList[MaxSize];</span><br></pre></td></tr></table></figure>
<p>数组第一个元素不存储数据，它的指针域存储第一个元素所在的数组下标。</p>
<p>链表最后一个元素的指针域值为-1</p>
<p><img src="/2019/05/26/数据结构/2 线性表/线性表/静态链表结构.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/数据结构/5 图/图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/数据结构/5 图/图/" class="post-title-link" itemprop="url">图</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 22:22:43" itemprop="dateModified" datetime="2019-10-06T22:22:43+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T22:22:43+08:00" content="2019-10-06">
                2019-10-06 22:22:43
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/数据结构/5 图/图/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/数据结构/5 图/图/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>图G由顶点集V和边集E组成，记为G=(V,E)</p>
<p><img src="/2019/05/26/数据结构/5 图/图/1 图的概念1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/2 图的概念2.png" alt></p>
<h6 id="简单图和多重图"><a href="#简单图和多重图" class="headerlink" title="简单图和多重图"></a>简单图和多重图</h6><p>简单图</p>
<ul>
<li>不存在顶点到自身的边</li>
<li>同一条边不重复出现</li>
</ul>
<p>多重图</p>
<p>若图G中某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联</p>
<p><img src="/2019/05/26/数据结构/5 图/图/3 简单图和多重图.png" alt></p>
<h6 id="完全图"><a href="#完全图" class="headerlink" title="完全图"></a>完全图</h6><p>无向完全图：如果任意两个顶点之间都存在边</p>
<p>有向完全图：如果任意两个顶点之间都存在方向相反的两条弧</p>
<p><img src="/2019/05/26/数据结构/5 图/图/4 完全图.png" alt></p>
<h6 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h6><p><img src="/2019/05/26/数据结构/5 图/图/5 子图.png" alt></p>
<h6 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h6><p><img src="/2019/05/26/数据结构/5 图/图/6 连通图.png" alt></p>
<p>强连通</p>
<p><img src="/2019/05/26/数据结构/5 图/图/7 强连通分量.png" alt></p>
<h6 id="连通图的生成树"><a href="#连通图的生成树" class="headerlink" title="连通图的生成树"></a>连通图的生成树</h6><p><img src="/2019/05/26/数据结构/5 图/图/8 连通图生成树.png" alt></p>
<h6 id="度"><a href="#度" class="headerlink" title="度"></a>度</h6><p><img src="/2019/05/26/数据结构/5 图/图/9 度.png" alt></p>
<h6 id="权和网"><a href="#权和网" class="headerlink" title="权和网"></a>权和网</h6><p><img src="/2019/05/26/数据结构/5 图/图/10 权和网.png" alt></p>
<h6 id="基本概念总结"><a href="#基本概念总结" class="headerlink" title="基本概念总结"></a>基本概念总结</h6><p><img src="/2019/05/26/数据结构/5 图/图/11 基本概念总结.png" alt></p>
<h5 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h5><ul>
<li>邻接矩阵(顺序存储)</li>
<li>邻接表(链式存储)<ul>
<li>十字链表(有向图)</li>
<li>邻接多重表(无向图)</li>
</ul>
</li>
</ul>
<h6 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h6><p>顶点：用一维数组来存储</p>
<p>边或弧：用二维数组来存储</p>
<p>二维数组就是一维数组的扩展，相当于一维数组中每个元素也是一维数组，二维数组也叫做邻接矩阵</p>
<p>无向图的邻接矩阵</p>
<p><img src="/2019/05/26/数据结构/5 图/图/12 无向图邻接矩阵.png" alt></p>
<p>有向图的邻接矩阵</p>
<p><img src="/2019/05/26/数据结构/5 图/图/13 有向图邻接矩阵.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/14 矩阵数据结构.png" alt></p>
<h6 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h6><p>对于稀疏图(E远小于V)，顺序存储结构存在预先分配内存可能浪费的问题</p>
<p>无向图邻接表</p>
<p><img src="/2019/05/26/数据结构/5 图/图/15 无向图邻接表.png" alt></p>
<p>有向图邻接表</p>
<p><img src="/2019/05/26/数据结构/5 图/图/16 有向图邻接表.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/17 邻接表问题.png" alt></p>
<h6 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h6><p>十字链表是针对有向图的存储方式，对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点</p>
<p><img src="/2019/05/26/数据结构/5 图/图/18 十字链表.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/19 十字链表实例.png" alt></p>
<p>十字链表数据结构</p>
<p><img src="/2019/05/26/数据结构/5 图/图/20 十字链表结构.png" alt></p>
<h6 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h6><p><img src="/2019/05/26/数据结构/5 图/图/21 设计邻接多重表.png" alt></p>
<p>边表结构</p>
<p><img src="/2019/05/26/数据结构/5 图/图/22 边表结构.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/23 邻接多重表实例.png" alt></p>
<h5 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h5><p>图的遍历：从图中某一个顶点出发遍历图中其余的顶点，且使每一个顶点仅访问一次，这个过程叫做图的遍历</p>
<p>图中顶点没有特殊性，可能存在沿着某条路径搜索后回到原起点，而有些顶点没有访问到。</p>
<p>解决办法：设置一个访问数组，记录遍历过程中访问过的顶点。</p>
<h6 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历(BFS)"></a>广度优先遍历(BFS)</h6><p><img src="/2019/05/26/数据结构/5 图/图/24 广度优先遍历.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/25 广度优先代码.png" alt></p>
<p>BFS算法实例</p>
<p><img src="/2019/05/26/数据结构/5 图/图/26 广度优先遍历实例.png" alt></p>
<p>BFS空间复杂度</p>
<p>BFS需要借助一个队列，n个顶点均需要入队一次，所以最坏情况下n个顶点在队列，那么则需要O(|V|)的空间复杂度</p>
<p>BFS时间复杂度</p>
<ol>
<li>邻接表：每个顶点入队一次，时间复杂度为O(|V|)，对于每个顶点，搜索它的邻接点，就需要访问这个顶点的所有边，所以时间复杂度为O(|E|)。所以总的时间复杂度为<strong>O(|V|+|E|)</strong>。</li>
<li>邻接矩阵：每个顶点入队一次，时间复杂度为O(|V|)，对于每个顶点，搜索它的邻接点，需要遍历一遍矩阵，所以时间复杂度为O(|V|)，所以总的时间复杂度为<strong>O(|V|<sup>2</sup>)</strong>。</li>
</ol>
<p>BFS应用</p>
<p>BFS解决单源非带权图最短路径问题：按照距离由近到远来遍历图中每个顶点</p>
<p><img src="/2019/05/26/数据结构/5 图/图/27 广度优先应用.png" alt></p>
<p>广度优先生成树</p>
<p><img src="/2019/05/26/数据结构/5 图/图/28 广度优先生成树.png" alt></p>
<h6 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历(DFS)"></a>深度优先遍历(DFS)</h6><p>深度优先遍历（DFS：Depth-First-Serch）：深度优先遍历类似于树的先序遍历算法</p>
<p>遍历过程：首先访问图中某一起始顶点v，然后由v出发，访问与v邻接且未被访问的任一顶点w1，再访问与w1邻接且未被访问的任一顶点w2，。。。。重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直到图中所有顶点均被访问过为止。</p>
<p><img src="/2019/05/26/数据结构/5 图/图/29 深度优先遍历过程.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/30 深度优先遍历代码.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/31 深度优先遍历实例.png" alt></p>
<p>深度优先复杂度</p>
<p>空间复杂度：</p>
<p>由于DFS是一个递归算法，递归是一个需要工作栈来辅助工作，最多需要图中所有顶点进栈，所以空间复杂度为O(|V|)</p>
<p>时间复杂度：</p>
<ol>
<li>邻接表：遍历过程的主要操作是对顶点遍历它的邻接点，由于通过访问边表来查找邻接点，所以时间复杂度为O(|E|)，访问访问顶点时间为O(|V|)，所以总的时间复杂度为<strong>O(|V|+|E|)</strong>。</li>
<li>邻接矩阵：查找每个顶点的邻接点时间复杂度为O(|V|)，对每个顶点都进行查找，所以总的时间复杂度<strong>O(|V|<sup>2</sup>)</strong>。</li>
</ol>
<p>深度优先生成树</p>
<p><img src="/2019/05/26/数据结构/5 图/图/32 深度优先生成树.png" alt></p>
<h5 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h5><h6 id="最小生成树-Prim、Kruskal"><a href="#最小生成树-Prim、Kruskal" class="headerlink" title="最小生成树(Prim、Kruskal)"></a>最小生成树(Prim、Kruskal)</h6><p>连通图的生成树，是一个极小的连通子图。包含图中全部的顶点，但只有足以构成一棵树的n-1条边</p>
<p><img src="/2019/05/26/数据结构/5 图/图/33 生成树不唯一.png" alt></p>
<ul>
<li>普里姆(Prim)算法</li>
<li>克鲁斯卡尔(Kruskal)算法</li>
</ul>
<p>普里姆算法</p>
<p><img src="/2019/05/26/数据结构/5 图/图/34 普利姆算法思路.png" alt></p>
<p>初始化</p>
<p><img src="/2019/05/26/数据结构/5 图/图/35 普利姆算法代码0.png" alt></p>
<p>i=1</p>
<p><img src="/2019/05/26/数据结构/5 图/图/35 普利姆算法代码1.png" alt></p>
<p>i=2</p>
<p><img src="/2019/05/26/数据结构/5 图/图/36 普利姆算法代码2-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/37 普利姆算法代码2-2.png" alt></p>
<p>i=3</p>
<p><img src="/2019/05/26/数据结构/5 图/图/38 普利姆算法代码3-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/39 普利姆算法代码3-2.png" alt></p>
<p>i=4</p>
<p><img src="/2019/05/26/数据结构/5 图/图/40 普利姆算法代码4-1.png" alt></p>
<p>i=5</p>
<p><img src="/2019/05/26/数据结构/5 图/图/41 普利姆算法代码5.png" alt></p>
<p>i=6</p>
<p><img src="/2019/05/26/数据结构/5 图/图/42 普利姆算法代码6.png" alt></p>
<p>Prim算法时间复杂度</p>
<p><img src="/2019/05/26/数据结构/5 图/图/43 普利姆算法复杂度.png" alt></p>
<p>克鲁斯卡尔算法(Kruskal)</p>
<p><img src="/2019/05/26/数据结构/5 图/图/44 克鲁斯卡尔算法思路.png" alt></p>
<p>并查集</p>
<p><img src="/2019/05/26/数据结构/5 图/图/45 并查集.png" alt></p>
<p>算法思路</p>
<p>初始化，将边权值进行排序</p>
<p><img src="/2019/05/26/数据结构/5 图/图/46 克鲁斯算法代码初始化.png" alt></p>
<p>第一次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/47 克鲁斯算法过程1-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/48 克鲁斯算法过程1-2.png" alt></p>
<p>第二次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/49 克鲁斯算法过程2-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/50 克鲁斯算法过程2-2.png" alt></p>
<p>第三次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/51 克鲁斯算法过程3-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/52 克鲁斯算法过程3-2.png" alt></p>
<p>第四次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/53 克鲁斯算法过程4-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/54 克鲁斯算法过程4-2.png" alt></p>
<p>第五次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/55 克鲁斯算法过程5.png" alt></p>
<p>第六次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/56 克鲁斯算法过程6-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/57 克鲁斯算法过程6-2.png" alt></p>
<p>第七次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/58 克鲁斯算法过程7-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/59 克鲁斯算法过程7-2.png" alt></p>
<p>4-6之后的边循环都不进行操作了，已经形成六条边(n-1)，形成最小生成树</p>
<p>克鲁斯卡尔算法复杂度</p>
<p><img src="/2019/05/26/数据结构/5 图/图/60 克鲁斯算法复杂度.png" alt></p>
<h6 id="最短路径-Dijkstra、floyd"><a href="#最短路径-Dijkstra、floyd" class="headerlink" title="最短路径(Dijkstra、floyd)"></a>最短路径(Dijkstra、floyd)</h6><p><img src="/2019/05/26/数据结构/5 图/图/61 最短路径.png" alt></p>
<ul>
<li>迪杰斯特拉算法：一个源点到其余顶点的最短路径</li>
<li>弗洛伊德算法：所有顶点到所有顶点的最短路径</li>
</ul>
<p>迪杰斯特拉算法思路：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/62 迪杰斯特拉算法思路.png" alt></p>
<p>迪杰斯特拉算法实例</p>
<p>第一次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/63 迪杰斯特拉算法实例1-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/64 迪杰斯特拉算法实例1-2.png" alt></p>
<p>第二次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/65 迪杰斯特拉算法实例2.png" alt></p>
<p>第三次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/66 迪杰斯特拉算法实例3.png" alt></p>
<p>第四次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/67 迪杰斯特拉算法实例4.png" alt></p>
<p>第五次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/68 迪杰斯特拉算法实例5.png" alt></p>
<p>迪杰斯特拉算法代码</p>
<p><img src="/2019/05/26/数据结构/5 图/图/69 迪杰斯特拉算法代码1-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/70 迪杰斯特拉算法代码1-2.png" alt></p>
<p>迪杰斯特拉复杂度</p>
<p><img src="/2019/05/26/数据结构/5 图/图/71 迪杰斯特拉算法复杂度.png" alt></p>
<p>弗洛伊德算法</p>
<p>弗洛伊德算法是求图中任意一对顶点间的最短路径的算法</p>
<p>算法思想：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/72 佛洛依德算法思路.png" alt></p>
<p>佛洛依德算法实例</p>
<p>初始化</p>
<p><img src="/2019/05/26/数据结构/5 图/图/73 佛洛依德算法实例初始化.png" alt></p>
<p>第一次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/74 佛洛依德算法实例1.png" alt></p>
<p>第二次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/75 弗洛依德算法实例2.png" alt></p>
<p>第三次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/76 弗洛依德算法实例3.png" alt></p>
<p>第四次</p>
<p><img src="/2019/05/26/数据结构/5 图/图/77 弗洛依德算法实例4.png" alt></p>
<p>弗洛伊德算法代码和复杂度</p>
<p><img src="/2019/05/26/数据结构/5 图/图/78 弗洛依德算法实例5.png" alt></p>
<h6 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h6><p>AOV网</p>
<p><img src="/2019/05/26/数据结构/5 图/图/79 AOV网.png" alt></p>
<p>拓扑排序算法思路</p>
<p><img src="/2019/05/26/数据结构/5 图/图/80 拓扑排序算法思路.png" alt></p>
<p>第一轮：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/81 拓扑排序算法过程1.png" alt></p>
<p>第二轮：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/82 拓扑排序算法过程2.png" alt></p>
<p>第三轮：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/83 拓扑排序算法过程3.png" alt></p>
<p>第四轮：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/84 拓扑排序算法过程4.png" alt></p>
<p>第五轮：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/85 拓扑排序算法过程5.png" alt></p>
<p>第六轮：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/86 拓扑排序算法过程6.png" alt></p>
<p>第七轮：</p>
<p><img src="/2019/05/26/数据结构/5 图/图/87 拓扑排序算法过程7.png" alt></p>
<p>拓扑排序算法代码</p>
<p><img src="/2019/05/26/数据结构/5 图/图/88 拓扑排序算法代码.png" alt></p>
<p>拓扑排序算法复杂度</p>
<p><img src="/2019/05/26/数据结构/5 图/图/89 拓扑排序算法复杂度.png" alt></p>
<p>拓扑排序规律</p>
<p><img src="/2019/05/26/数据结构/5 图/图/90 拓扑排序算法规律.png" alt></p>
<h6 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h6><p>AOE网</p>
<p><img src="/2019/05/26/数据结构/5 图/图/91 AOE网.png" alt></p>
<p>关键路径</p>
<p><img src="/2019/05/26/数据结构/5 图/图/92 关键路径.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/93 关键路径规律.png" alt></p>
<p>寻找关键路径步骤</p>
<p><img src="/2019/05/26/数据结构/5 图/图/94 关键路径步骤1.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/95 关键路径步骤2.png" alt></p>
<p><img src="/2019/05/26/数据结构/5 图/图/96 关键路径步骤3.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/数据结构/6 查找/查找/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/数据结构/6 查找/查找/" class="post-title-link" itemprop="url">查找</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 22:23:26" itemprop="dateModified" datetime="2019-10-06T22:23:26+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T22:23:26+08:00" content="2019-10-06">
                2019-10-06 22:23:26
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/数据结构/6 查找/查找/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/数据结构/6 查找/查找/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>查找：在数据集合中寻找满足某种条件的数据元素的过程</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/1 查找表.png" alt></p>
<p>关键字：数据元素中某个可以唯一标识该元素的数据项</p>
<p>平均查找长度</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/2 平均查找长度.png" alt></p>
<h5 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h5><p><img src="/2019/05/26/数据结构/6 查找/查找/3 顺序查找过程.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/4 顺序查找ASL.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/5 顺序查找时间复杂度.png" alt></p>
<h5 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h5><p><img src="/2019/05/26/数据结构/6 查找/查找/6 折半查找.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/7 折半查找判定树.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/8 折半查找时间复杂度.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/9 折半查找成功ASL.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/10 折半查找失败ASL.png" alt></p>
<h5 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h5><p>分块查找又称为索引顺序查找</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/11 分块查找概念.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/12 分块查找思路.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/13 分块查找ASL.png" alt></p>
<h5 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h5><p><img src="/2019/05/26/数据结构/6 查找/查找/14 二叉排序树概念.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/15 二叉排序树查找思路.png" alt></p>
<p>二叉排序树查找递归代码</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/16 二叉排序树查找递归代码.png" alt></p>
<p>二叉排序树查找非递归代码</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/17 二叉排序树非递归代码.png" alt></p>
<p>二叉排序树插入关键字代码</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/18 二叉排序树插入关键字.png" alt></p>
<p>时间复杂度</p>
<p>有n个结点就需要插入n个结点操作，插入一个的时间复杂度为O(log<sub>2</sub>n)，构造复杂度为O(nlog2n)</p>
<p>二叉排序树构造代码</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/19 二叉排序树构造代码.png" alt></p>
<p>二叉排序树删除结点</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/20 二叉排序树删除结点.png" alt></p>
<p>删除叶子结点</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/21 二叉排序树删除叶子结点.png" alt></p>
<p>删除只有左子树或者右子树的结点</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/22 二叉排序树删除只有左子树或右子树结点.png" alt></p>
<p>删除左右子树都有的结点</p>
<p>找到该结点的前驱和后继(即中序遍历的前驱和后继)</p>
<p>前驱替代结点</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/23 二叉排序树删除左右子树都有的结点1.png" alt></p>
<p>后继替代结点</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/24 二叉排序树删除左右子树都有的结点2.png" alt></p>
<p>二叉排序树分析</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/25 二叉排序树分析.png" alt></p>
<h5 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树(AVL树)"></a>平衡二叉树(AVL树)</h5><p><img src="/2019/05/26/数据结构/6 查找/查找/26 平衡二叉树.png" alt></p>
<p>最小不平衡子树</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/27 最小不平衡子树.png" alt></p>
<p>不平衡二叉树类型</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/28 最小不平衡子树类型.png" alt></p>
<p>构建平衡二叉树过程</p>
<p>LL调整</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/29 构建平衡二叉树1.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/30 构建平衡二叉树2.png" alt></p>
<p>RR调整</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/31 构建平衡二叉树3.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/32 构建平衡二叉树4.png" alt></p>
<p>RL调整</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/33 构建平衡二叉树5.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/34 构建平衡二叉树6.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/35 构建平衡二叉树7.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/36 构建平衡二叉树8.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/37 构建平衡二叉树9.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/38 构建平衡二叉树10.png" alt></p>
<p>平衡二叉树结点规律</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/39 平衡二叉树结点规律.png" alt></p>
<h5 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h5><p>2-3树：</p>
<p>2-3是一种多路查找树：2和3的意思就是2-3树包含两种结点</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/40 2-3树.png" alt></p>
<p>2-3-4树：<br><img src="/2019/05/26/数据结构/6 查找/查找/41 2-3-4树.png" alt></p>
<p>B树</p>
<p>磁盘管理系统中的目录管理，以及数据库系统中的索引组织多数都采用B树数据结构</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/42 B树.png" alt></p>
<p>B树查找操作</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/43 B树查找操作.png" alt></p>
<p>B树插入操作</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/44 B树插入操作.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/45 B树插入操作2.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/46 B树插入操作3.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/47 B树插入操作4.png" alt></p>
<p>B树删除操作</p>
<p>删除的关键字在终端结点上(最底层非叶子结点)</p>
<p>第一种情况</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/48 B树删除操作1.png" alt></p>
<p>第二种情况</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/49 B树删除操作2-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/50 B树删除操作2-2.png" alt></p>
<p>第三中情况</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/51 B树删除操作3-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/52 B树删除操作3-2.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/53 B树删除操作3-3.png" alt></p>
<p>删除关键字不在终端结点上(最底层非叶子结点)</p>
<p>第一种情况</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/54 B树删除操作4-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/55 B树删除操作4-2.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/56 B树删除操作4-3.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/57 B树删除操作4-4.png" alt></p>
<p>第二种情况</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/58 B树删除操作5-1.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/59 B树删除操作5-2.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/60 B树删除操作5-3.png" alt></p>
<p>B+树</p>
<p>B+树是B树的变形树，适合用于文件索引系统</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/61 B+树.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/62 B+树与B树区别.png" alt></p>
<h5 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h5><p>散列表基本概念</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/63 散列表基本概念.png" alt></p>
<p>散列函数和冲突处理方法</p>
<p>常用Hash函数的构造方法</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/64 散列表Hash函数构造方法.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/65 散列表Hash函数构造方法2.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/66 散列表Hash函数构造方法3.png" alt></p>
<p>常用Hash函数的冲突处理方法</p>
<p>开放地址法</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/67 散列表冲突处理.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/68 散列表冲突处理2.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/69 散列表冲突处理3.png" alt></p>
<p>拉链法(链地址法)</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/70 散列表冲突处理4.png" alt></p>
<p>散列表的查找过程和性能</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/71 散列表查找过程和性能.png" alt></p>
<p>散列表实例</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/72 散列表实例.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/73 散列表实例2.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/74 散列表实例3.png" alt></p>
<p>ASL计算方式：查找成功ASL看关键字，查找失败ASL看地址个数</p>
<p>开放地址法(线性探测再散列法)计算ASL：<a href="https://blog.csdn.net/wangran51/article/details/8826633/" target="_blank" rel="noopener">https://blog.csdn.net/wangran51/article/details/8826633/</a></p>
<h5 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h5><p>KMP算法是用于解决字符串模式匹配的问题，字符串的模式匹配，是求一个字符串（模式串）在另一个字符串（主串）中的位置</p>
<p>BF(Brute-Force)算法</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/75 字符串模式匹配.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/76 BF算法代码.png" alt></p>
<p>BF算法效率O(n*m)</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/77 BF算法效率.png" alt></p>
<p>KMP算法</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/78 KMP算法.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/79 KMP算法2.png" alt></p>
<p>KMP算法next数组</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/80 KMP算法next数组.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/81 KMP算法next数组代码.png" alt></p>
<p>next例子情况</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/82 KMP算法next数组例子.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/83 KMP算法next数组例子2.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/84 KMP算法next数组例子3.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/85 KMP算法next数组例子4.png" alt></p>
<p>当P[k] == P[j]时，</p>
<p>有next[j+1] == next[j] + 1</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/86 next数组例子5.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/87 next数组例子6.png" alt></p>
<p>当P[k] != P[j]</p>
<p>像上边的例子，我们已经不可能找到[ A，B，A，B ]这个最长的后缀串了，但我们还是可能找到[ A，B ]、[ B ]这样的前缀串的。所以这个过程像不像在定位[ A，B，A，C ]这个串，当C和主串不一样了（也就是k位置不一样了），那当然是把指针移动到next[k]啦。</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/88 next数组例子7.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/89 next数组例子8.png" alt></p>
<p>KMP算法代码</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/90 KMP算法代码.png" alt></p>
<p>KMP算法效率</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/91 KMP算法效率.png" alt></p>
<p>手动求解next数组的值</p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/92 KMP算法手动next数组1.png" alt></p>
<p><img src="/2019/05/26/数据结构/6 查找/查找/93 KMP算法手动next数组2.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://benyzheng.github.io/2019/05/26/数据结构/4 树和二叉树/树与二叉树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Beny">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Beny's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/" class="post-title-link" itemprop="url">树与二叉树</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

             
                
              

              <time title="创建时间：2019-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2019-05-26T12:12:57+08:00">2019-05-26 12:12:57</time>
            

            
              
            <!--  old version
              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
              <time title="修改时间：2019-10-06 22:21:52" itemprop="dateModified" datetime="2019-10-06T22:21:52+08:00">2019-10-06</time> 
              -->
              <!-- new version -->
                        
            <span class="post-updated">
                
                  <span class="post-meta-divider">|</span>
                  

                  <span class="post-meta-item-icon">
                    <i class="fa fa-calendar-check-o"></i>
                  </span>
                  
                    <span class="post-meta-item-text">更新于</span>
                
              <time itemprop="dateUpdated" datetime="2019-10-06T22:21:52+08:00" content="2019-10-06">
                2019-10-06 22:21:52
              </time>
            </span>
          
            
          </span>


          
          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h3><p>一对多的树形结构</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树的结构定义.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树结点相关概念.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树结点相关概念2.png" alt></p>
<h5 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h5><ul>
<li>树中的结点等于所有结点的度数加1</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树的性质1.png" alt></p>
<ul>
<li>度为m的树中第i层上至多有m<sup>i-1</sup>个结点（i&gt;=1）</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树的性质2.png" alt></p>
<ul>
<li><p>高度为h的m叉树至多有（m<sup>h</sup>-1)/(m-1)个结点</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树的性质3.png" alt></p>
</li>
<li><p>具有n个结点的m叉树的最小高度为取上整[log<sub>m</sub>(n(m-1)+1)]</p>
</li>
</ul>
<p>解上一个方程的h即可</p>
<h5 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h5><h6 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h6><p>双亲表示法：用一组连续的存储空间存储树的结点，同时在每个结点中，用一个变量存储该结点的双亲结点在数组中的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//结点数据</span></span><br><span class="line">    <span class="keyword">int</span> parent;<span class="comment">//该结点双亲在数组的下标</span></span><br><span class="line">&#125;TNode;<span class="comment">//结点的数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    TNode nodes[MaxSize];<span class="comment">//结点数组</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//结点的数量</span></span><br><span class="line">&#125;Tree;<span class="comment">//结点双亲表示结构</span></span><br></pre></td></tr></table></figure>
<p>双亲表示法可以根据parent找到该结点的双亲结点，时间复杂度为O(1)。但如果找到某节点的孩子结点就需要遍历</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/顺序存储结构.png" alt></p>
<h6 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h6><p>孩子表示法：把每个结点的孩子结点排列起来存储成一个单链表。所以n个结点就有n个链表；如果时叶子结点，那这个结点的孩子单链表就是空的；然后n个单链表的头指针又存储在一个顺序表（数组）中。</p>
<p>需要设计两种结合结构类型：</p>
<ul>
<li>孩子链表的结点</li>
<li>每个孩子链表的表头结点（存在数组中）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> child;<span class="comment">//该孩子在表头数组的下标</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CNode</span> *<span class="title">next</span>;</span><span class="comment">//指向该结点的下一个孩子结点</span></span><br><span class="line">&#125;CNode,*Child;<span class="comment">//孩子结点数据结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Elemtype data;<span class="comment">//结点数据域</span></span><br><span class="line">    Child firstchild;<span class="comment">//指向该结点的第一个孩子结点</span></span><br><span class="line">&#125;TNode<span class="comment">//孩子结点的数据类型</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    TNode nodes[MaxSize];<span class="comment">//结点数据域</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//树中结点个数</span></span><br><span class="line">&#125;Tree;<span class="comment">//树的孩子表示结构</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/链式存储结构.png" alt></p>
<p>孩子兄弟表示法：要存储孩子结点和兄弟结点，就是设置两个指针，分别指向该结点的第一个孩子结点和该结点的兄弟结点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//该结点的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">rightsib</span>//指向该结点的第一个孩子结点和该结点的右兄弟结点</span></span><br><span class="line"><span class="class">&#125;<span class="title">CSNode</span>;</span><span class="comment">//孩子兄弟结点数据类型</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/链式存储结构2.png" alt></p>
<h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><p>每个结点最多有两颗子树</p>
<p>左右子树有顺序</p>
<p>五种基本形态</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树五种形态.png" alt></p>
<h6 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/斜树.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/满二叉树.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/完全二叉树.png" alt></p>
<h5 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h5><ul>
<li>非空二叉树上叶子结点等于度为2的结点数加1</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树性质1.png" alt></p>
<ul>
<li>非空二叉树上第K层上至多有2<sup>k-1</sup>个结点（k&gt;=1）</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树性质2.png" alt></p>
<ul>
<li>高度为H的二叉树至多有2<sup>H</sup>-1个结点（H&gt;=1）</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树性质3.png" alt></p>
<ul>
<li>具有N个(N&gt;0)结点的完全二叉树的高度为上取整[log<sub>2</sub>(N+1)]或下取整[log<sub>2</sub>N]+1</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树性质4.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树性质5.png" alt></p>
<h5 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h5><h6 id="顺序存储结构-1"><a href="#顺序存储结构-1" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h6><p>二叉树的顺序存储结构就是用一组地址连续的存储单元依次自上而下，自左而右存储完全二叉树上的结点元素</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树顺序存储.png" alt></p>
<h6 id="链式存储结构-1"><a href="#链式存储结构-1" class="headerlink" title="链式存储结构"></a>链式存储结构</h6><p>二叉树每个结点最多两个孩子，所以设计二叉树的结点结构时考虑两个指针指向该结点的两个孩子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//指向该结点的左右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTNode;<span class="comment">//二叉树结点结构</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树链式存储结构.png" alt></p>
<h5 id="二叉树遍历-递归"><a href="#二叉树遍历-递归" class="headerlink" title="二叉树遍历(递归)"></a>二叉树遍历(递归)</h5><p>二叉树的遍历是指按某种次序依次访问树中的每个结点，使得每个结点均被访问一次，而且仅被访问一次</p>
<h6 id="递归先序遍历"><a href="#递归先序遍历" class="headerlink" title="递归先序遍历"></a>递归先序遍历</h6><p>操作过程：</p>
<ul>
<li>访问根结点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data)<span class="comment">//根节点</span></span><br><span class="line">        PreOrder(T-&gt;lchild);<span class="comment">//左子树</span></span><br><span class="line">        PreOrder(T-&gt;rchild);<span class="comment">//右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="递归中序遍历"><a href="#递归中序遍历" class="headerlink" title="递归中序遍历"></a>递归中序遍历</h6><p>操作过程：</p>
<ul>
<li>中序遍历左子树</li>
<li>访问根节点</li>
<li>中序遍历右子树</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="递归后序遍历"><a href="#递归后序遍历" class="headerlink" title="递归后序遍历"></a>递归后序遍历</h6><p>操作过程：</p>
<ul>
<li>后序遍历左子树</li>
<li>后序遍历右子树</li>
<li>访问根节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        PostOrder(T-&gt;lchild);</span><br><span class="line">        PostOrder(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,T-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二叉树遍历-非递归"><a href="#二叉树遍历-非递归" class="headerlink" title="二叉树遍历(非递归)"></a>二叉树遍历(非递归)</h5><h6 id="非递归先序遍历"><a href="#非递归先序遍历" class="headerlink" title="非递归先序遍历"></a>非递归先序遍历</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree b)</span></span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    BitTree p=b;<span class="comment">//工作指针p</span></span><br><span class="line">    <span class="keyword">while</span>(p || !IsEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,p-&gt;data);<span class="comment">//先序先遍历结点</span></span><br><span class="line">            Push(S,p);<span class="comment">//进栈保存</span></span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!IsEmpty(S))&#123;</span><br><span class="line">            p=Pop(S);</span><br><span class="line">            p=p-rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="非递归中序遍历"><a href="#非递归中序遍历" class="headerlink" title="非递归中序遍历"></a>非递归中序遍历</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree b)</span></span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    BitTree p=b;<span class="comment">//工作指针p</span></span><br><span class="line">    <span class="keyword">while</span>(p || !IsEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            Push(S,p);<span class="comment">//进栈保存</span></span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p=Pop(S);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,p-&gt;data);</span><br><span class="line">        p=p-rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="非递归后序遍历"><a href="#非递归后序遍历" class="headerlink" title="非递归后序遍历"></a>非递归后序遍历</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/非递归后续遍历.png" alt></p>
<h6 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h6><p>操作过程：</p>
<p>若树为空，则什么都不做直接返回；</p>
<p>否则从树的第一层开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问</p>
<p>出队-&gt;访问-&gt;左右孩子入队</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree b)</span></span>&#123;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q,b);<span class="comment">//根节点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,p);<span class="comment">//队头元素出队</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q,p-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q,p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h5><p>二叉链表表示的二叉树存在大量空指针</p>
<p>N个结点的二叉树，每个结点都有指向左右孩子的结点指针，所以一共有2N个指针，而N个结点的二叉树一共有N-1个分支，也就是说存在2N-(N-1)=N+1个空指针。</p>
<p>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/线索二叉树.png" alt></p>
<p>对二叉树以某种次序遍历使其变为线索二叉树的过程叫做线索化。</p>
<p>如何区分指针是指向左孩子还是前驱，右孩子还是后继？</p>
<p>在二叉链表结点的结构基础上增加两个标志位ltag和rtag</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,*ThreadTree;<span class="comment">//线索链表</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/线索二叉树结构.png" alt></p>
<ul>
<li>ltag==0表示lchild指向该结点左孩子</li>
<li>ltag==1表示rchild指向该结点前驱</li>
<li>rtag==0表示rchild指向该结点右孩子</li>
<li>rtag==1表示指向该结点后继</li>
</ul>
<h6 id="构造线索二叉树"><a href="#构造线索二叉树" class="headerlink" title="构造线索二叉树"></a>构造线索二叉树</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/构造线索二叉树.png" alt></p>
<h6 id="遍历线索二叉树"><a href="#遍历线索二叉树" class="headerlink" title="遍历线索二叉树"></a>遍历线索二叉树</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/遍历线索二叉树.png" alt></p>
<h5 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h5><p>概念：</p>
<p>权：树中结点相关的数值</p>
<p>路径长度：从树中某个结点到另一个结点之间的分支数目（经过的边数）</p>
<p>带权路径长度：从树的根节点到任意结点的路径长度（经过的边数）与该结点上权值的乘积称为该结点的带权路径长度</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树的带权路径长度.png" alt></p>
<p>哈夫曼树：含有N个带权叶子结点的二叉树中，带有带权路径长度（WPL）最小的二叉树，也成为最优二叉树。</p>
<h6 id="设计哈夫曼树"><a href="#设计哈夫曼树" class="headerlink" title="设计哈夫曼树"></a>设计哈夫曼树</h6><ul>
<li>将这N个结点分别作为N颗仅含一个结点的二叉树，构成森林F</li>
<li>构造一个新结点，并从F中选取两颗根节点权值最小的树作为新结点的左右子树，并且将新结点的权值置为左右子树上根节点的权值之和</li>
<li>从F中删除刚才选出的两棵树，同时将新得到的树加入F中</li>
<li>重复步骤2和3，直至F中只剩下一棵树为止</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/构造哈夫曼树.png" alt></p>
<h6 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h6><p>左子树为0，右子树为1</p>
<p>哈夫曼编码性质</p>
<ul>
<li>哈夫曼编码是前缀编码</li>
<li>哈夫曼编码是最优前缀编码</li>
</ul>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/哈夫曼编码.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/哈夫曼编码2.png" alt></p>
<h5 id="二叉树、树和森林"><a href="#二叉树、树和森林" class="headerlink" title="二叉树、树和森林"></a>二叉树、树和森林</h5><h6 id="树转化成二叉树"><a href="#树转化成二叉树" class="headerlink" title="树转化成二叉树"></a>树转化成二叉树</h6><p>用到一个孩子兄弟表示法（回归本章树的链式存储）</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树转二叉树1.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树转二叉树2.png" alt></p>
<h6 id="二叉树转树"><a href="#二叉树转树" class="headerlink" title="二叉树转树"></a>二叉树转树</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树转树.png" alt></p>
<h6 id="森林转二叉树"><a href="#森林转二叉树" class="headerlink" title="森林转二叉树"></a>森林转二叉树</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/森林转二叉树.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/森林转二叉树2.png" alt></p>
<h6 id="二叉树转森林"><a href="#二叉树转森林" class="headerlink" title="二叉树转森林"></a>二叉树转森林</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/二叉树转森林.png" alt></p>
<h6 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h6><p>树的先序遍历</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树的先序遍历.png" alt></p>
<p>树的后序遍历</p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树的后序遍历.png" alt></p>
<p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/树与二叉树先序后序遍历比较.png" alt></p>
<h6 id="森林遍历"><a href="#森林遍历" class="headerlink" title="森林遍历"></a>森林遍历</h6><p><img src="/2019/05/26/数据结构/4 树和二叉树/树与二叉树/森林先序后序遍历.png" alt></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.jpg" alt="Beny">
            
              <p class="site-author-name" itemprop="name">Beny</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">64</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/1105397915" title="1105397915 &rarr; 1105397915"><i class="fa fa-fw fa-qq"></i>1105397915</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/benyzheng" title="GitHub &rarr; https://github.com/benyzheng" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="/zhengbeny@qq.com" title="zhengbeny@qq.com &rarr; zhengbeny@qq.com"><i class="fa fa-fw fa-envelope"></i>zhengbeny@qq.com</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Beny</span>

  

  
</div>








<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共164.3k字</span>
</div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/libs/jquery/index.js?v=2.1.3"></script>

  
  <script src="/libs/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/libs/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>



  

  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  
  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="/js/src/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: 'oaY0uDqkCsuX94AxTtnV6scO-gzGzoHsz',
    appKey: 'HKU5SJPAd8KyYqk6Q8fdArL5',
    placeholder: '写了评论, offer还会远吗? ----记得填写邮箱哦~如果可以填写你的网站互相参考就更好啦',
    avatar: 'retro',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn'
  });
  //增加以下六行代码去除 power by valine
    var infoEle = document.querySelector('#comments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0){
      infoEle.childNodes.forEach(function(item) {
        item.parentNode.removeChild(item);
      });
    }
</script>





  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  

  

  

  

<!-- 页面点击小红心 -->
<!-- <script type="text/javascript" src="/js/src/click.js"></script>-->
</body>
</html>
